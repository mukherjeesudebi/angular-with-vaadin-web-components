{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2021 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { getFocusableElements, isElementFocused } from './focus-utils.js';\nconst instances = [];\n\n/**\n * A controller for trapping focus within a DOM node.\n */\nexport class FocusTrapController {\n  /**\n   * @param {HTMLElement} host\n   */\n  constructor(host) {\n    /**\n     * The controller host element.\n     *\n     * @type {HTMLElement}\n     */\n    this.host = host;\n\n    /**\n     * A node for trapping focus in.\n     *\n     * @type {HTMLElement | null}\n     * @private\n     */\n    this.__trapNode = null;\n    this.__onKeyDown = this.__onKeyDown.bind(this);\n  }\n\n  /**\n   * An array of tab-ordered focusable elements inside the trap node.\n   *\n   * @return {HTMLElement[]}\n   * @private\n   */\n  get __focusableElements() {\n    return getFocusableElements(this.__trapNode);\n  }\n\n  /**\n   * The index of the element inside the trap node that currently has focus.\n   *\n   * @return {HTMLElement | undefined}\n   * @private\n   */\n  get __focusedElementIndex() {\n    const focusableElements = this.__focusableElements;\n    return focusableElements.indexOf(focusableElements.filter(isElementFocused).pop());\n  }\n  hostConnected() {\n    document.addEventListener('keydown', this.__onKeyDown);\n  }\n  hostDisconnected() {\n    document.removeEventListener('keydown', this.__onKeyDown);\n  }\n\n  /**\n   * Activates a focus trap for a DOM node that will prevent focus from escaping the node.\n   * The trap can be deactivated with the `.releaseFocus()` method.\n   *\n   * If focus is initially outside the trap, the method will move focus inside,\n   * on the first focusable element of the trap in the tab order.\n   * The first focusable element can be the trap node itself if it is focusable\n   * and comes first in the tab order.\n   *\n   * If there are no focusable elements, the method will throw an exception\n   * and the trap will not be set.\n   *\n   * @param {HTMLElement} trapNode\n   */\n  trapFocus(trapNode) {\n    this.__trapNode = trapNode;\n    if (this.__focusableElements.length === 0) {\n      this.__trapNode = null;\n      throw new Error('The trap node should have at least one focusable descendant or be focusable itself.');\n    }\n    instances.push(this);\n    if (this.__focusedElementIndex === -1) {\n      this.__focusableElements[0].focus();\n    }\n  }\n\n  /**\n   * Deactivates the focus trap set with the `.trapFocus()` method\n   * so that it becomes possible to tab outside the trap node.\n   */\n  releaseFocus() {\n    this.__trapNode = null;\n    instances.pop();\n  }\n\n  /**\n   * A `keydown` event handler that manages tabbing navigation when the trap is enabled.\n   *\n   * - Moves focus to the next focusable element of the trap on `Tab` press.\n   * When no next element to focus, the method moves focus to the first focusable element.\n   * - Moves focus to the prev focusable element of the trap on `Shift+Tab` press.\n   * When no prev element to focus, the method moves focus to the last focusable element.\n   *\n   * @param {KeyboardEvent} event\n   * @private\n   */\n  __onKeyDown(event) {\n    if (!this.__trapNode) {\n      return;\n    }\n\n    // Only handle events for the last instance\n    if (this !== Array.from(instances).pop()) {\n      return;\n    }\n    if (event.key === 'Tab') {\n      event.preventDefault();\n      const backward = event.shiftKey;\n      this.__focusNextElement(backward);\n    }\n  }\n\n  /**\n   * - Moves focus to the next focusable element if `backward === false`.\n   * When no next element to focus, the method moves focus to the first focusable element.\n   * - Moves focus to the prev focusable element if `backward === true`.\n   * When no prev element to focus the method moves focus to the last focusable element.\n   *\n   * If no focusable elements, the method returns immediately.\n   *\n   * @param {boolean} backward\n   * @private\n   */\n  __focusNextElement(backward = false) {\n    const focusableElements = this.__focusableElements;\n    const step = backward ? -1 : 1;\n    const currentIndex = this.__focusedElementIndex;\n    const nextIndex = (focusableElements.length + currentIndex + step) % focusableElements.length;\n    const element = focusableElements[nextIndex];\n    element.focus();\n    if (element.localName === 'input') {\n      element.select();\n    }\n  }\n}","map":{"version":3,"names":["getFocusableElements","isElementFocused","instances","FocusTrapController","constructor","host","__trapNode","__onKeyDown","bind","__focusableElements","__focusedElementIndex","focusableElements","indexOf","filter","pop","hostConnected","document","addEventListener","hostDisconnected","removeEventListener","trapFocus","trapNode","length","Error","push","focus","releaseFocus","event","Array","from","key","preventDefault","backward","shiftKey","__focusNextElement","step","currentIndex","nextIndex","element","localName","select"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@vaadin/a11y-base/src/focus-trap-controller.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2021 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { getFocusableElements, isElementFocused } from './focus-utils.js';\n\nconst instances = [];\n\n/**\n * A controller for trapping focus within a DOM node.\n */\nexport class FocusTrapController {\n  /**\n   * @param {HTMLElement} host\n   */\n  constructor(host) {\n    /**\n     * The controller host element.\n     *\n     * @type {HTMLElement}\n     */\n    this.host = host;\n\n    /**\n     * A node for trapping focus in.\n     *\n     * @type {HTMLElement | null}\n     * @private\n     */\n    this.__trapNode = null;\n\n    this.__onKeyDown = this.__onKeyDown.bind(this);\n  }\n\n  /**\n   * An array of tab-ordered focusable elements inside the trap node.\n   *\n   * @return {HTMLElement[]}\n   * @private\n   */\n  get __focusableElements() {\n    return getFocusableElements(this.__trapNode);\n  }\n\n  /**\n   * The index of the element inside the trap node that currently has focus.\n   *\n   * @return {HTMLElement | undefined}\n   * @private\n   */\n  get __focusedElementIndex() {\n    const focusableElements = this.__focusableElements;\n    return focusableElements.indexOf(focusableElements.filter(isElementFocused).pop());\n  }\n\n  hostConnected() {\n    document.addEventListener('keydown', this.__onKeyDown);\n  }\n\n  hostDisconnected() {\n    document.removeEventListener('keydown', this.__onKeyDown);\n  }\n\n  /**\n   * Activates a focus trap for a DOM node that will prevent focus from escaping the node.\n   * The trap can be deactivated with the `.releaseFocus()` method.\n   *\n   * If focus is initially outside the trap, the method will move focus inside,\n   * on the first focusable element of the trap in the tab order.\n   * The first focusable element can be the trap node itself if it is focusable\n   * and comes first in the tab order.\n   *\n   * If there are no focusable elements, the method will throw an exception\n   * and the trap will not be set.\n   *\n   * @param {HTMLElement} trapNode\n   */\n  trapFocus(trapNode) {\n    this.__trapNode = trapNode;\n\n    if (this.__focusableElements.length === 0) {\n      this.__trapNode = null;\n      throw new Error('The trap node should have at least one focusable descendant or be focusable itself.');\n    }\n\n    instances.push(this);\n\n    if (this.__focusedElementIndex === -1) {\n      this.__focusableElements[0].focus();\n    }\n  }\n\n  /**\n   * Deactivates the focus trap set with the `.trapFocus()` method\n   * so that it becomes possible to tab outside the trap node.\n   */\n  releaseFocus() {\n    this.__trapNode = null;\n\n    instances.pop();\n  }\n\n  /**\n   * A `keydown` event handler that manages tabbing navigation when the trap is enabled.\n   *\n   * - Moves focus to the next focusable element of the trap on `Tab` press.\n   * When no next element to focus, the method moves focus to the first focusable element.\n   * - Moves focus to the prev focusable element of the trap on `Shift+Tab` press.\n   * When no prev element to focus, the method moves focus to the last focusable element.\n   *\n   * @param {KeyboardEvent} event\n   * @private\n   */\n  __onKeyDown(event) {\n    if (!this.__trapNode) {\n      return;\n    }\n\n    // Only handle events for the last instance\n    if (this !== Array.from(instances).pop()) {\n      return;\n    }\n\n    if (event.key === 'Tab') {\n      event.preventDefault();\n\n      const backward = event.shiftKey;\n      this.__focusNextElement(backward);\n    }\n  }\n\n  /**\n   * - Moves focus to the next focusable element if `backward === false`.\n   * When no next element to focus, the method moves focus to the first focusable element.\n   * - Moves focus to the prev focusable element if `backward === true`.\n   * When no prev element to focus the method moves focus to the last focusable element.\n   *\n   * If no focusable elements, the method returns immediately.\n   *\n   * @param {boolean} backward\n   * @private\n   */\n  __focusNextElement(backward = false) {\n    const focusableElements = this.__focusableElements;\n    const step = backward ? -1 : 1;\n    const currentIndex = this.__focusedElementIndex;\n    const nextIndex = (focusableElements.length + currentIndex + step) % focusableElements.length;\n    const element = focusableElements[nextIndex];\n    element.focus();\n    if (element.localName === 'input') {\n      element.select();\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}