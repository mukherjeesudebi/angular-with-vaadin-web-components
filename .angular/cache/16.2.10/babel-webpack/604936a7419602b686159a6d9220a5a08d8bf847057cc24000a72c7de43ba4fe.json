{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2016 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { timeOut } from '@vaadin/component-base/src/async.js';\nimport { Debouncer } from '@vaadin/component-base/src/debounce.js';\nimport { get } from '@vaadin/component-base/src/path-utils.js';\nimport { getBodyRowCells, updateCellsPart, updateState } from './vaadin-grid-helpers.js';\n\n/**\n * @private\n */\nexport const ItemCache = class ItemCache {\n  /**\n   * @param {!HTMLElement} grid\n   * @param {!ItemCache | undefined} parentCache\n   * @param {!GridItem | undefined} parentItem\n   */\n  constructor(grid, parentCache, parentItem) {\n    /** @type {!HTMLElement} */\n    this.grid = grid;\n    /** @type {!ItemCache | undefined} */\n    this.parentCache = parentCache;\n    /** @type {!GridItem | undefined} */\n    this.parentItem = parentItem;\n    /** @type {object} */\n    this.itemCaches = {};\n    /** @type {object[]} */\n    this.items = [];\n    /** @type {number} */\n    this.effectiveSize = 0;\n    /** @type {number} */\n    this.size = 0;\n    /** @type {object} */\n    this.pendingRequests = {};\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isLoading() {\n    return Boolean(Object.keys(this.pendingRequests).length || Object.keys(this.itemCaches).filter(index => {\n      return this.itemCaches[index].isLoading();\n    })[0]);\n  }\n\n  /**\n   * @param {number} index\n   * @return {!GridItem | undefined}\n   */\n  getItemForIndex(index) {\n    const {\n      cache,\n      scaledIndex\n    } = this.getCacheAndIndex(index);\n    return cache.items[scaledIndex];\n  }\n  updateSize() {\n    this.effectiveSize = !this.parentItem || this.grid._isExpanded(this.parentItem) ? this.size + Object.keys(this.itemCaches).reduce((prev, curr) => {\n      const subCache = this.itemCaches[curr];\n      subCache.updateSize();\n      return prev + subCache.effectiveSize;\n    }, 0) : 0;\n  }\n\n  /**\n   * @param {number} scaledIndex\n   */\n  ensureSubCacheForScaledIndex(scaledIndex) {\n    if (!this.itemCaches[scaledIndex]) {\n      const subCache = new ItemCache(this.grid, this, this.items[scaledIndex]);\n      this.itemCaches[scaledIndex] = subCache;\n      this.grid._loadPage(0, subCache);\n    }\n  }\n\n  /**\n   * @param {number} index\n   * @return {{cache: !ItemCache, scaledIndex: number}}\n   */\n  getCacheAndIndex(index) {\n    let thisLevelIndex = index;\n    for (const [index, subCache] of Object.entries(this.itemCaches)) {\n      const numberIndex = Number(index);\n      if (thisLevelIndex <= numberIndex) {\n        return {\n          cache: this,\n          scaledIndex: thisLevelIndex\n        };\n      } else if (thisLevelIndex <= numberIndex + subCache.effectiveSize) {\n        return subCache.getCacheAndIndex(thisLevelIndex - numberIndex - 1);\n      }\n      thisLevelIndex -= subCache.effectiveSize;\n    }\n    return {\n      cache: this,\n      scaledIndex: thisLevelIndex\n    };\n  }\n\n  /**\n   * Gets the scaled index as flattened index on this cache level.\n   * In practice, this means that the effective size of any expanded\n   * subcaches preceding the index are added to the value.\n   * @param {number} scaledIndex\n   * @return {number} The flat index on this cache level.\n   */\n  getFlatIndex(scaledIndex) {\n    const clampedIndex = Math.max(0, Math.min(this.size - 1, scaledIndex));\n    return Object.entries(this.itemCaches).reduce((prev, [index, subCache]) => {\n      return clampedIndex > Number(index) ? prev + subCache.effectiveSize : prev;\n    }, clampedIndex);\n  }\n};\n\n/**\n * @polymerMixin\n */\nexport const DataProviderMixin = superClass => class DataProviderMixin extends superClass {\n  static get properties() {\n    return {\n      /**\n       * The number of root-level items in the grid.\n       * @attr {number} size\n       * @type {number}\n       */\n      size: {\n        type: Number,\n        notify: true\n      },\n      /**\n       * Number of items fetched at a time from the dataprovider.\n       * @attr {number} page-size\n       * @type {number}\n       */\n      pageSize: {\n        type: Number,\n        value: 50,\n        observer: '_pageSizeChanged'\n      },\n      /**\n       * Function that provides items lazily. Receives arguments `params`, `callback`\n       *\n       * `params.page` Requested page index\n       *\n       * `params.pageSize` Current page size\n       *\n       * `params.filters` Currently applied filters\n       *\n       * `params.sortOrders` Currently applied sorting orders\n       *\n       * `params.parentItem` When tree is used, and sublevel items\n       * are requested, reference to parent item of the requested sublevel.\n       * Otherwise `undefined`.\n       *\n       * `callback(items, size)` Callback function with arguments:\n       *   - `items` Current page of items\n       *   - `size` Total number of items. When tree sublevel items\n       *     are requested, total number of items in the requested sublevel.\n       *     Optional when tree is not used, required for tree.\n       *\n       * @type {GridDataProvider | null | undefined}\n       */\n      dataProvider: {\n        type: Object,\n        notify: true,\n        observer: '_dataProviderChanged'\n      },\n      /**\n       * `true` while data is being requested from the data provider.\n       */\n      loading: {\n        type: Boolean,\n        notify: true,\n        readOnly: true,\n        reflectToAttribute: true\n      },\n      /**\n       * @type {!ItemCache}\n       * @protected\n       */\n      _cache: {\n        type: Object,\n        value() {\n          const cache = new ItemCache(this);\n          return cache;\n        }\n      },\n      /**\n       * @protected\n       */\n      _hasData: {\n        type: Boolean,\n        value: false\n      },\n      /**\n       * Path to an item sub-property that indicates whether the item has child items.\n       * @attr {string} item-has-children-path\n       */\n      itemHasChildrenPath: {\n        type: String,\n        value: 'children',\n        observer: '__itemHasChildrenPathChanged'\n      },\n      /**\n       * Path to an item sub-property that identifies the item.\n       * @attr {string} item-id-path\n       */\n      itemIdPath: {\n        type: String,\n        value: null\n      },\n      /**\n       * An array that contains the expanded items.\n       * @type {!Array<!GridItem>}\n       */\n      expandedItems: {\n        type: Object,\n        notify: true,\n        value: () => []\n      },\n      /**\n       * @private\n       */\n      __expandedKeys: {\n        type: Object,\n        computed: '__computeExpandedKeys(itemIdPath, expandedItems.*)'\n      }\n    };\n  }\n  static get observers() {\n    return ['_sizeChanged(size)', '_expandedItemsChanged(expandedItems.*)'];\n  }\n\n  /** @private */\n  _sizeChanged(size) {\n    const delta = size - this._cache.size;\n    this._cache.size += delta;\n    this._cache.effectiveSize += delta;\n    this._effectiveSize = this._cache.effectiveSize;\n  }\n\n  /** @private */\n  __itemHasChildrenPathChanged(value, oldValue) {\n    if (!oldValue && value === 'children') {\n      // Avoid an unnecessary content update on init.\n      return;\n    }\n    this.requestContentUpdate();\n  }\n\n  /**\n   * @param {number} index\n   * @param {HTMLElement} el\n   * @protected\n   */\n  _getItem(index, el) {\n    if (index >= this._effectiveSize) {\n      return;\n    }\n    el.index = index;\n    const {\n      cache,\n      scaledIndex\n    } = this._cache.getCacheAndIndex(index);\n    const item = cache.items[scaledIndex];\n    if (item) {\n      this.__updateLoading(el, false);\n      this._updateItem(el, item);\n      if (this._isExpanded(item)) {\n        cache.ensureSubCacheForScaledIndex(scaledIndex);\n      }\n    } else {\n      this.__updateLoading(el, true);\n      this._loadPage(this._getPageForIndex(scaledIndex), cache);\n    }\n  }\n\n  /**\n   * @param {!HTMLElement} row\n   * @param {boolean} loading\n   * @private\n   */\n  __updateLoading(row, loading) {\n    const cells = getBodyRowCells(row);\n\n    // Row state attribute\n    updateState(row, 'loading', loading);\n\n    // Cells part attribute\n    updateCellsPart(cells, 'loading-row-cell', loading);\n  }\n\n  /**\n   * Returns a value that identifies the item. Uses `itemIdPath` if available.\n   * Can be customized by overriding.\n   * @param {!GridItem} item\n   * @return {!GridItem | !unknown}\n   */\n  getItemId(item) {\n    return this.itemIdPath ? get(this.itemIdPath, item) : item;\n  }\n\n  /**\n   * @param {!GridItem} item\n   * @return {boolean}\n   * @protected\n   */\n  _isExpanded(item) {\n    return this.__expandedKeys.has(this.getItemId(item));\n  }\n\n  /** @private */\n  _expandedItemsChanged() {\n    this._cache.updateSize();\n    this._effectiveSize = this._cache.effectiveSize;\n    this.__updateVisibleRows();\n  }\n\n  /** @private */\n  __computeExpandedKeys(itemIdPath, expandedItems) {\n    const expanded = expandedItems.base || [];\n    const expandedKeys = new Set();\n    expanded.forEach(item => {\n      expandedKeys.add(this.getItemId(item));\n    });\n    return expandedKeys;\n  }\n\n  /**\n   * Expands the given item tree.\n   * @param {!GridItem} item\n   */\n  expandItem(item) {\n    if (!this._isExpanded(item)) {\n      this.expandedItems = [...this.expandedItems, item];\n    }\n  }\n\n  /**\n   * Collapses the given item tree.\n   * @param {!GridItem} item\n   */\n  collapseItem(item) {\n    if (this._isExpanded(item)) {\n      this.expandedItems = this.expandedItems.filter(i => !this._itemsEqual(i, item));\n    }\n  }\n\n  /**\n   * @param {number} index\n   * @return {number}\n   * @protected\n   */\n  _getIndexLevel(index) {\n    let {\n      cache\n    } = this._cache.getCacheAndIndex(index);\n    let level = 0;\n    while (cache.parentCache) {\n      cache = cache.parentCache;\n      level += 1;\n    }\n    return level;\n  }\n\n  /**\n   * @param {number} page\n   * @param {ItemCache} cache\n   * @protected\n   */\n  _loadPage(page, cache) {\n    // Make sure same page isn't requested multiple times.\n    if (!cache.pendingRequests[page] && this.dataProvider) {\n      this._setLoading(true);\n      cache.pendingRequests[page] = true;\n      const params = {\n        page,\n        pageSize: this.pageSize,\n        sortOrders: this._mapSorters(),\n        filters: this._mapFilters(),\n        parentItem: cache.parentItem\n      };\n      this.dataProvider(params, (items, size) => {\n        if (size !== undefined) {\n          cache.size = size;\n        } else if (params.parentItem) {\n          cache.size = items.length;\n        }\n\n        // Populate the cache with new items\n        items.forEach((item, itemsIndex) => {\n          const itemIndex = page * this.pageSize + itemsIndex;\n          cache.items[itemIndex] = item;\n        });\n\n        // With the new items added, update the cache size and the grid's effective size\n        this._cache.updateSize();\n        this._effectiveSize = this._cache.effectiveSize;\n\n        // After updating the cache, check if some of the expanded items should have sub-caches loaded\n        this._getRenderedRows().forEach(row => {\n          const {\n            cache,\n            scaledIndex\n          } = this._cache.getCacheAndIndex(row.index);\n          const item = cache.items[scaledIndex];\n          if (item && this._isExpanded(item)) {\n            cache.ensureSubCacheForScaledIndex(scaledIndex);\n          }\n        });\n        this._hasData = true;\n\n        // Remove the pending request\n        delete cache.pendingRequests[page];\n\n        // Schedule a debouncer to update the visible rows\n        this._debouncerApplyCachedData = Debouncer.debounce(this._debouncerApplyCachedData, timeOut.after(0), () => {\n          this._setLoading(false);\n          this._getRenderedRows().forEach(row => {\n            const cachedItem = this._cache.getItemForIndex(row.index);\n            if (cachedItem) {\n              this._getItem(row.index, row);\n            }\n          });\n          this.__scrollToPendingIndexes();\n          this.__dispatchPendingBodyCellFocus();\n        });\n\n        // If the grid is not loading anything, flush the debouncer immediately\n        if (!this._cache.isLoading()) {\n          this._debouncerApplyCachedData.flush();\n        }\n\n        // Notify that new data has been received\n        this._onDataProviderPageLoaded();\n      });\n    }\n  }\n\n  /** @protected */\n  _onDataProviderPageLoaded() {}\n\n  /**\n   * @param {number} index\n   * @return {number}\n   * @private\n   */\n  _getPageForIndex(index) {\n    return Math.floor(index / this.pageSize);\n  }\n\n  /**\n   * Clears the cached pages and reloads data from dataprovider when needed.\n   */\n  clearCache() {\n    this._cache = new ItemCache(this);\n    this._cache.size = this.size || 0;\n    this._cache.updateSize();\n    this._hasData = false;\n    this.__updateVisibleRows();\n    if (!this._effectiveSize) {\n      this._loadPage(0, this._cache);\n    }\n  }\n\n  /** @private */\n  _pageSizeChanged(pageSize, oldPageSize) {\n    if (oldPageSize !== undefined && pageSize !== oldPageSize) {\n      this.clearCache();\n    }\n  }\n\n  /** @protected */\n  _checkSize() {\n    if (this.size === undefined && this._effectiveSize === 0) {\n      console.warn('The <vaadin-grid> needs the total number of items in' + ' order to display rows, which you can specify either by setting' + ' the `size` property, or by providing it to the second argument' + ' of the `dataProvider` function `callback` call.');\n    }\n  }\n\n  /** @private */\n  _dataProviderChanged(dataProvider, oldDataProvider) {\n    if (oldDataProvider !== undefined) {\n      this.clearCache();\n    }\n    this._ensureFirstPageLoaded();\n    this._debouncerCheckSize = Debouncer.debounce(this._debouncerCheckSize, timeOut.after(2000), this._checkSize.bind(this));\n  }\n\n  /** @protected */\n  _ensureFirstPageLoaded() {\n    if (!this._hasData) {\n      // Load data before adding rows to make sure they have content when\n      // rendered for the first time.\n      this._loadPage(0, this._cache);\n    }\n  }\n\n  /**\n   * @param {!GridItem} item1\n   * @param {!GridItem} item2\n   * @return {boolean}\n   * @protected\n   */\n  _itemsEqual(item1, item2) {\n    return this.getItemId(item1) === this.getItemId(item2);\n  }\n\n  /**\n   * @param {!GridItem} item\n   * @param {!Array<!GridItem>} array\n   * @return {number}\n   * @protected\n   */\n  _getItemIndexInArray(item, array) {\n    let result = -1;\n    array.forEach((i, idx) => {\n      if (this._itemsEqual(i, item)) {\n        result = idx;\n      }\n    });\n    return result;\n  }\n\n  /**\n   * Scroll to a specific row index in the virtual list. Note that the row index is\n   * not always the same for any particular item. For example, sorting or filtering\n   * items can affect the row index related to an item.\n   *\n   * The `indexes` parameter can be either a single number or multiple numbers.\n   * The grid will first try to scroll to the item at the first index on the top level.\n   * In case the item at the first index is expanded, the grid will then try scroll to the\n   * item at the second index within the children of the expanded first item, and so on.\n   * Each given index points to a child of the item at the previous index.\n   *\n   * Using `Infinity` as an index will point to the last item on the level.\n   *\n   * @param indexes {...number} Row indexes to scroll to\n   */\n  scrollToIndex(...indexes) {\n    // Synchronous data provider may cause changes to the cache on scroll without\n    // ending up in a loading state. Try scrolling to the index until the target\n    // index stabilizes.\n    let targetIndex;\n    while (targetIndex !== (targetIndex = this.__getGlobalFlatIndex(indexes))) {\n      this._scrollToFlatIndex(targetIndex);\n    }\n    if (this._cache.isLoading() || !this.clientHeight) {\n      this.__pendingScrollToIndexes = indexes;\n    }\n  }\n\n  /**\n   * Recursively returns the globally flat index of the item the given indexes point to.\n   * Each index in the array points to a sub-item of the previous index.\n   * Using `Infinity` as an index will point to the last item on the level.\n   *\n   * @param {!Array<number>} indexes\n   * @param {!ItemCache} cache\n   * @param {number} flatIndex\n   * @return {number}\n   * @private\n   */\n  __getGlobalFlatIndex([levelIndex, ...subIndexes], cache = this._cache, flatIndex = 0) {\n    if (levelIndex === Infinity) {\n      // Treat Infinity as the last index on the level\n      levelIndex = cache.size - 1;\n    }\n    const flatIndexOnLevel = cache.getFlatIndex(levelIndex);\n    const subCache = cache.itemCaches[levelIndex];\n    if (subCache && subCache.effectiveSize && subIndexes.length) {\n      return this.__getGlobalFlatIndex(subIndexes, subCache, flatIndex + flatIndexOnLevel + 1);\n    }\n    return flatIndex + flatIndexOnLevel;\n  }\n\n  /** @private */\n  __scrollToPendingIndexes() {\n    if (this.__pendingScrollToIndexes && this.$.items.children.length) {\n      const indexes = this.__pendingScrollToIndexes;\n      delete this.__pendingScrollToIndexes;\n      this.scrollToIndex(...indexes);\n    }\n  }\n\n  /**\n   * Fired when the `expandedItems` property changes.\n   *\n   * @event expanded-items-changed\n   */\n\n  /**\n   * Fired when the `loading` property changes.\n   *\n   * @event loading-changed\n   */\n};","map":{"version":3,"names":["timeOut","Debouncer","get","getBodyRowCells","updateCellsPart","updateState","ItemCache","constructor","grid","parentCache","parentItem","itemCaches","items","effectiveSize","size","pendingRequests","isLoading","Boolean","Object","keys","length","filter","index","getItemForIndex","cache","scaledIndex","getCacheAndIndex","updateSize","_isExpanded","reduce","prev","curr","subCache","ensureSubCacheForScaledIndex","_loadPage","thisLevelIndex","entries","numberIndex","Number","getFlatIndex","clampedIndex","Math","max","min","DataProviderMixin","superClass","properties","type","notify","pageSize","value","observer","dataProvider","loading","readOnly","reflectToAttribute","_cache","_hasData","itemHasChildrenPath","String","itemIdPath","expandedItems","__expandedKeys","computed","observers","_sizeChanged","delta","_effectiveSize","__itemHasChildrenPathChanged","oldValue","requestContentUpdate","_getItem","el","item","__updateLoading","_updateItem","_getPageForIndex","row","cells","getItemId","has","_expandedItemsChanged","__updateVisibleRows","__computeExpandedKeys","expanded","base","expandedKeys","Set","forEach","add","expandItem","collapseItem","i","_itemsEqual","_getIndexLevel","level","page","_setLoading","params","sortOrders","_mapSorters","filters","_mapFilters","undefined","itemsIndex","itemIndex","_getRenderedRows","_debouncerApplyCachedData","debounce","after","cachedItem","__scrollToPendingIndexes","__dispatchPendingBodyCellFocus","flush","_onDataProviderPageLoaded","floor","clearCache","_pageSizeChanged","oldPageSize","_checkSize","console","warn","_dataProviderChanged","oldDataProvider","_ensureFirstPageLoaded","_debouncerCheckSize","bind","item1","item2","_getItemIndexInArray","array","result","idx","scrollToIndex","indexes","targetIndex","__getGlobalFlatIndex","_scrollToFlatIndex","clientHeight","__pendingScrollToIndexes","levelIndex","subIndexes","flatIndex","Infinity","flatIndexOnLevel","$","children"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@vaadin/grid/src/vaadin-grid-data-provider-mixin.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2016 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { timeOut } from '@vaadin/component-base/src/async.js';\nimport { Debouncer } from '@vaadin/component-base/src/debounce.js';\nimport { get } from '@vaadin/component-base/src/path-utils.js';\nimport { getBodyRowCells, updateCellsPart, updateState } from './vaadin-grid-helpers.js';\n\n/**\n * @private\n */\nexport const ItemCache = class ItemCache {\n  /**\n   * @param {!HTMLElement} grid\n   * @param {!ItemCache | undefined} parentCache\n   * @param {!GridItem | undefined} parentItem\n   */\n  constructor(grid, parentCache, parentItem) {\n    /** @type {!HTMLElement} */\n    this.grid = grid;\n    /** @type {!ItemCache | undefined} */\n    this.parentCache = parentCache;\n    /** @type {!GridItem | undefined} */\n    this.parentItem = parentItem;\n    /** @type {object} */\n    this.itemCaches = {};\n    /** @type {object[]} */\n    this.items = [];\n    /** @type {number} */\n    this.effectiveSize = 0;\n    /** @type {number} */\n    this.size = 0;\n    /** @type {object} */\n    this.pendingRequests = {};\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isLoading() {\n    return Boolean(\n      Object.keys(this.pendingRequests).length ||\n        Object.keys(this.itemCaches).filter((index) => {\n          return this.itemCaches[index].isLoading();\n        })[0],\n    );\n  }\n\n  /**\n   * @param {number} index\n   * @return {!GridItem | undefined}\n   */\n  getItemForIndex(index) {\n    const { cache, scaledIndex } = this.getCacheAndIndex(index);\n    return cache.items[scaledIndex];\n  }\n\n  updateSize() {\n    this.effectiveSize =\n      !this.parentItem || this.grid._isExpanded(this.parentItem)\n        ? this.size +\n          Object.keys(this.itemCaches).reduce((prev, curr) => {\n            const subCache = this.itemCaches[curr];\n            subCache.updateSize();\n            return prev + subCache.effectiveSize;\n          }, 0)\n        : 0;\n  }\n\n  /**\n   * @param {number} scaledIndex\n   */\n  ensureSubCacheForScaledIndex(scaledIndex) {\n    if (!this.itemCaches[scaledIndex]) {\n      const subCache = new ItemCache(this.grid, this, this.items[scaledIndex]);\n      this.itemCaches[scaledIndex] = subCache;\n      this.grid._loadPage(0, subCache);\n    }\n  }\n\n  /**\n   * @param {number} index\n   * @return {{cache: !ItemCache, scaledIndex: number}}\n   */\n  getCacheAndIndex(index) {\n    let thisLevelIndex = index;\n    for (const [index, subCache] of Object.entries(this.itemCaches)) {\n      const numberIndex = Number(index);\n      if (thisLevelIndex <= numberIndex) {\n        return { cache: this, scaledIndex: thisLevelIndex };\n      } else if (thisLevelIndex <= numberIndex + subCache.effectiveSize) {\n        return subCache.getCacheAndIndex(thisLevelIndex - numberIndex - 1);\n      }\n      thisLevelIndex -= subCache.effectiveSize;\n    }\n    return { cache: this, scaledIndex: thisLevelIndex };\n  }\n\n  /**\n   * Gets the scaled index as flattened index on this cache level.\n   * In practice, this means that the effective size of any expanded\n   * subcaches preceding the index are added to the value.\n   * @param {number} scaledIndex\n   * @return {number} The flat index on this cache level.\n   */\n  getFlatIndex(scaledIndex) {\n    const clampedIndex = Math.max(0, Math.min(this.size - 1, scaledIndex));\n\n    return Object.entries(this.itemCaches).reduce((prev, [index, subCache]) => {\n      return clampedIndex > Number(index) ? prev + subCache.effectiveSize : prev;\n    }, clampedIndex);\n  }\n};\n\n/**\n * @polymerMixin\n */\nexport const DataProviderMixin = (superClass) =>\n  class DataProviderMixin extends superClass {\n    static get properties() {\n      return {\n        /**\n         * The number of root-level items in the grid.\n         * @attr {number} size\n         * @type {number}\n         */\n        size: {\n          type: Number,\n          notify: true,\n        },\n\n        /**\n         * Number of items fetched at a time from the dataprovider.\n         * @attr {number} page-size\n         * @type {number}\n         */\n        pageSize: {\n          type: Number,\n          value: 50,\n          observer: '_pageSizeChanged',\n        },\n\n        /**\n         * Function that provides items lazily. Receives arguments `params`, `callback`\n         *\n         * `params.page` Requested page index\n         *\n         * `params.pageSize` Current page size\n         *\n         * `params.filters` Currently applied filters\n         *\n         * `params.sortOrders` Currently applied sorting orders\n         *\n         * `params.parentItem` When tree is used, and sublevel items\n         * are requested, reference to parent item of the requested sublevel.\n         * Otherwise `undefined`.\n         *\n         * `callback(items, size)` Callback function with arguments:\n         *   - `items` Current page of items\n         *   - `size` Total number of items. When tree sublevel items\n         *     are requested, total number of items in the requested sublevel.\n         *     Optional when tree is not used, required for tree.\n         *\n         * @type {GridDataProvider | null | undefined}\n         */\n        dataProvider: {\n          type: Object,\n          notify: true,\n          observer: '_dataProviderChanged',\n        },\n\n        /**\n         * `true` while data is being requested from the data provider.\n         */\n        loading: {\n          type: Boolean,\n          notify: true,\n          readOnly: true,\n          reflectToAttribute: true,\n        },\n\n        /**\n         * @type {!ItemCache}\n         * @protected\n         */\n        _cache: {\n          type: Object,\n          value() {\n            const cache = new ItemCache(this);\n            return cache;\n          },\n        },\n\n        /**\n         * @protected\n         */\n        _hasData: {\n          type: Boolean,\n          value: false,\n        },\n\n        /**\n         * Path to an item sub-property that indicates whether the item has child items.\n         * @attr {string} item-has-children-path\n         */\n        itemHasChildrenPath: {\n          type: String,\n          value: 'children',\n          observer: '__itemHasChildrenPathChanged',\n        },\n\n        /**\n         * Path to an item sub-property that identifies the item.\n         * @attr {string} item-id-path\n         */\n        itemIdPath: {\n          type: String,\n          value: null,\n        },\n\n        /**\n         * An array that contains the expanded items.\n         * @type {!Array<!GridItem>}\n         */\n        expandedItems: {\n          type: Object,\n          notify: true,\n          value: () => [],\n        },\n\n        /**\n         * @private\n         */\n        __expandedKeys: {\n          type: Object,\n          computed: '__computeExpandedKeys(itemIdPath, expandedItems.*)',\n        },\n      };\n    }\n\n    static get observers() {\n      return ['_sizeChanged(size)', '_expandedItemsChanged(expandedItems.*)'];\n    }\n\n    /** @private */\n    _sizeChanged(size) {\n      const delta = size - this._cache.size;\n      this._cache.size += delta;\n      this._cache.effectiveSize += delta;\n      this._effectiveSize = this._cache.effectiveSize;\n    }\n\n    /** @private */\n    __itemHasChildrenPathChanged(value, oldValue) {\n      if (!oldValue && value === 'children') {\n        // Avoid an unnecessary content update on init.\n        return;\n      }\n      this.requestContentUpdate();\n    }\n\n    /**\n     * @param {number} index\n     * @param {HTMLElement} el\n     * @protected\n     */\n    _getItem(index, el) {\n      if (index >= this._effectiveSize) {\n        return;\n      }\n\n      el.index = index;\n      const { cache, scaledIndex } = this._cache.getCacheAndIndex(index);\n      const item = cache.items[scaledIndex];\n      if (item) {\n        this.__updateLoading(el, false);\n        this._updateItem(el, item);\n        if (this._isExpanded(item)) {\n          cache.ensureSubCacheForScaledIndex(scaledIndex);\n        }\n      } else {\n        this.__updateLoading(el, true);\n        this._loadPage(this._getPageForIndex(scaledIndex), cache);\n      }\n    }\n\n    /**\n     * @param {!HTMLElement} row\n     * @param {boolean} loading\n     * @private\n     */\n    __updateLoading(row, loading) {\n      const cells = getBodyRowCells(row);\n\n      // Row state attribute\n      updateState(row, 'loading', loading);\n\n      // Cells part attribute\n      updateCellsPart(cells, 'loading-row-cell', loading);\n    }\n\n    /**\n     * Returns a value that identifies the item. Uses `itemIdPath` if available.\n     * Can be customized by overriding.\n     * @param {!GridItem} item\n     * @return {!GridItem | !unknown}\n     */\n    getItemId(item) {\n      return this.itemIdPath ? get(this.itemIdPath, item) : item;\n    }\n\n    /**\n     * @param {!GridItem} item\n     * @return {boolean}\n     * @protected\n     */\n    _isExpanded(item) {\n      return this.__expandedKeys.has(this.getItemId(item));\n    }\n\n    /** @private */\n    _expandedItemsChanged() {\n      this._cache.updateSize();\n      this._effectiveSize = this._cache.effectiveSize;\n      this.__updateVisibleRows();\n    }\n\n    /** @private */\n    __computeExpandedKeys(itemIdPath, expandedItems) {\n      const expanded = expandedItems.base || [];\n      const expandedKeys = new Set();\n      expanded.forEach((item) => {\n        expandedKeys.add(this.getItemId(item));\n      });\n\n      return expandedKeys;\n    }\n\n    /**\n     * Expands the given item tree.\n     * @param {!GridItem} item\n     */\n    expandItem(item) {\n      if (!this._isExpanded(item)) {\n        this.expandedItems = [...this.expandedItems, item];\n      }\n    }\n\n    /**\n     * Collapses the given item tree.\n     * @param {!GridItem} item\n     */\n    collapseItem(item) {\n      if (this._isExpanded(item)) {\n        this.expandedItems = this.expandedItems.filter((i) => !this._itemsEqual(i, item));\n      }\n    }\n\n    /**\n     * @param {number} index\n     * @return {number}\n     * @protected\n     */\n    _getIndexLevel(index) {\n      let { cache } = this._cache.getCacheAndIndex(index);\n      let level = 0;\n      while (cache.parentCache) {\n        cache = cache.parentCache;\n        level += 1;\n      }\n      return level;\n    }\n\n    /**\n     * @param {number} page\n     * @param {ItemCache} cache\n     * @protected\n     */\n    _loadPage(page, cache) {\n      // Make sure same page isn't requested multiple times.\n      if (!cache.pendingRequests[page] && this.dataProvider) {\n        this._setLoading(true);\n        cache.pendingRequests[page] = true;\n        const params = {\n          page,\n          pageSize: this.pageSize,\n          sortOrders: this._mapSorters(),\n          filters: this._mapFilters(),\n          parentItem: cache.parentItem,\n        };\n\n        this.dataProvider(params, (items, size) => {\n          if (size !== undefined) {\n            cache.size = size;\n          } else if (params.parentItem) {\n            cache.size = items.length;\n          }\n\n          // Populate the cache with new items\n          items.forEach((item, itemsIndex) => {\n            const itemIndex = page * this.pageSize + itemsIndex;\n            cache.items[itemIndex] = item;\n          });\n\n          // With the new items added, update the cache size and the grid's effective size\n          this._cache.updateSize();\n          this._effectiveSize = this._cache.effectiveSize;\n\n          // After updating the cache, check if some of the expanded items should have sub-caches loaded\n          this._getRenderedRows().forEach((row) => {\n            const { cache, scaledIndex } = this._cache.getCacheAndIndex(row.index);\n            const item = cache.items[scaledIndex];\n            if (item && this._isExpanded(item)) {\n              cache.ensureSubCacheForScaledIndex(scaledIndex);\n            }\n          });\n\n          this._hasData = true;\n\n          // Remove the pending request\n          delete cache.pendingRequests[page];\n\n          // Schedule a debouncer to update the visible rows\n          this._debouncerApplyCachedData = Debouncer.debounce(this._debouncerApplyCachedData, timeOut.after(0), () => {\n            this._setLoading(false);\n\n            this._getRenderedRows().forEach((row) => {\n              const cachedItem = this._cache.getItemForIndex(row.index);\n              if (cachedItem) {\n                this._getItem(row.index, row);\n              }\n            });\n\n            this.__scrollToPendingIndexes();\n            this.__dispatchPendingBodyCellFocus();\n          });\n\n          // If the grid is not loading anything, flush the debouncer immediately\n          if (!this._cache.isLoading()) {\n            this._debouncerApplyCachedData.flush();\n          }\n\n          // Notify that new data has been received\n          this._onDataProviderPageLoaded();\n        });\n      }\n    }\n\n    /** @protected */\n    _onDataProviderPageLoaded() {}\n\n    /**\n     * @param {number} index\n     * @return {number}\n     * @private\n     */\n    _getPageForIndex(index) {\n      return Math.floor(index / this.pageSize);\n    }\n\n    /**\n     * Clears the cached pages and reloads data from dataprovider when needed.\n     */\n    clearCache() {\n      this._cache = new ItemCache(this);\n      this._cache.size = this.size || 0;\n      this._cache.updateSize();\n      this._hasData = false;\n      this.__updateVisibleRows();\n\n      if (!this._effectiveSize) {\n        this._loadPage(0, this._cache);\n      }\n    }\n\n    /** @private */\n    _pageSizeChanged(pageSize, oldPageSize) {\n      if (oldPageSize !== undefined && pageSize !== oldPageSize) {\n        this.clearCache();\n      }\n    }\n\n    /** @protected */\n    _checkSize() {\n      if (this.size === undefined && this._effectiveSize === 0) {\n        console.warn(\n          'The <vaadin-grid> needs the total number of items in' +\n            ' order to display rows, which you can specify either by setting' +\n            ' the `size` property, or by providing it to the second argument' +\n            ' of the `dataProvider` function `callback` call.',\n        );\n      }\n    }\n\n    /** @private */\n    _dataProviderChanged(dataProvider, oldDataProvider) {\n      if (oldDataProvider !== undefined) {\n        this.clearCache();\n      }\n\n      this._ensureFirstPageLoaded();\n\n      this._debouncerCheckSize = Debouncer.debounce(\n        this._debouncerCheckSize,\n        timeOut.after(2000),\n        this._checkSize.bind(this),\n      );\n    }\n\n    /** @protected */\n    _ensureFirstPageLoaded() {\n      if (!this._hasData) {\n        // Load data before adding rows to make sure they have content when\n        // rendered for the first time.\n        this._loadPage(0, this._cache);\n      }\n    }\n\n    /**\n     * @param {!GridItem} item1\n     * @param {!GridItem} item2\n     * @return {boolean}\n     * @protected\n     */\n    _itemsEqual(item1, item2) {\n      return this.getItemId(item1) === this.getItemId(item2);\n    }\n\n    /**\n     * @param {!GridItem} item\n     * @param {!Array<!GridItem>} array\n     * @return {number}\n     * @protected\n     */\n    _getItemIndexInArray(item, array) {\n      let result = -1;\n      array.forEach((i, idx) => {\n        if (this._itemsEqual(i, item)) {\n          result = idx;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * Scroll to a specific row index in the virtual list. Note that the row index is\n     * not always the same for any particular item. For example, sorting or filtering\n     * items can affect the row index related to an item.\n     *\n     * The `indexes` parameter can be either a single number or multiple numbers.\n     * The grid will first try to scroll to the item at the first index on the top level.\n     * In case the item at the first index is expanded, the grid will then try scroll to the\n     * item at the second index within the children of the expanded first item, and so on.\n     * Each given index points to a child of the item at the previous index.\n     *\n     * Using `Infinity` as an index will point to the last item on the level.\n     *\n     * @param indexes {...number} Row indexes to scroll to\n     */\n    scrollToIndex(...indexes) {\n      // Synchronous data provider may cause changes to the cache on scroll without\n      // ending up in a loading state. Try scrolling to the index until the target\n      // index stabilizes.\n      let targetIndex;\n      while (targetIndex !== (targetIndex = this.__getGlobalFlatIndex(indexes))) {\n        this._scrollToFlatIndex(targetIndex);\n      }\n\n      if (this._cache.isLoading() || !this.clientHeight) {\n        this.__pendingScrollToIndexes = indexes;\n      }\n    }\n\n    /**\n     * Recursively returns the globally flat index of the item the given indexes point to.\n     * Each index in the array points to a sub-item of the previous index.\n     * Using `Infinity` as an index will point to the last item on the level.\n     *\n     * @param {!Array<number>} indexes\n     * @param {!ItemCache} cache\n     * @param {number} flatIndex\n     * @return {number}\n     * @private\n     */\n    __getGlobalFlatIndex([levelIndex, ...subIndexes], cache = this._cache, flatIndex = 0) {\n      if (levelIndex === Infinity) {\n        // Treat Infinity as the last index on the level\n        levelIndex = cache.size - 1;\n      }\n      const flatIndexOnLevel = cache.getFlatIndex(levelIndex);\n      const subCache = cache.itemCaches[levelIndex];\n      if (subCache && subCache.effectiveSize && subIndexes.length) {\n        return this.__getGlobalFlatIndex(subIndexes, subCache, flatIndex + flatIndexOnLevel + 1);\n      }\n      return flatIndex + flatIndexOnLevel;\n    }\n\n    /** @private */\n    __scrollToPendingIndexes() {\n      if (this.__pendingScrollToIndexes && this.$.items.children.length) {\n        const indexes = this.__pendingScrollToIndexes;\n        delete this.__pendingScrollToIndexes;\n        this.scrollToIndex(...indexes);\n      }\n    }\n\n    /**\n     * Fired when the `expandedItems` property changes.\n     *\n     * @event expanded-items-changed\n     */\n\n    /**\n     * Fired when the `loading` property changes.\n     *\n     * @event loading-changed\n     */\n  };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}