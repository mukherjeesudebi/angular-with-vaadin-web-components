{"ast":null,"code":"/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n/**\n\nThis is a fork of <iron-list> for <vaadin-grid>'s internal purposes only!\nTo update:\n1. Get the most recent code from https://github.com/PolymerElements/iron-list/\n2. Remove the  <dom-module id=\"iron-list\"> to avoid collisions with actual <iron-list>\n3. Change \"Polymer({\" to \"window.PolymerIronList = Polymer.Class({\" to expose the class\n3.1. Add @namespace\n4. Optional: Remove all properties and functions not needed by <vaadin-grid>\n5. Profit!\n\n*/\n/*\n  FIXME(polymer-modulizer): the above comments were extracted\n  from HTML and may be out of place here. Review them and\n  then delete this comment!\n*/\nimport '@polymer/polymer/polymer-legacy.js';\nimport { IronResizableBehavior } from '@polymer/iron-resizable-behavior/iron-resizable-behavior.js';\nimport { IronScrollTargetBehavior } from '@polymer/iron-scroll-target-behavior/iron-scroll-target-behavior.js';\nimport { animationFrame, idlePeriod, microTask } from '@polymer/polymer/lib/utils/async.js';\nimport { Class } from '@polymer/polymer/lib/legacy/class.js';\nimport { flush, enqueueDebouncer } from '@polymer/polymer/lib/utils/flush.js';\nimport { flush as flush$0 } from '@polymer/polymer/lib/legacy/polymer.dom.js';\nimport { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\nvar IOS = navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\\d+)/);\nvar IOS_TOUCH_SCROLLING = IOS && IOS[1] >= 8;\nvar DEFAULT_PHYSICAL_COUNT = 3;\nvar ANIMATION_FRAME = animationFrame;\nvar IDLE_TIME = idlePeriod;\nvar MICRO_TASK = microTask;\nexport const PolymerIronList = Class({\n  behaviors: [IronResizableBehavior, IronScrollTargetBehavior],\n  /**\n   * The ratio of hidden tiles that should remain in the scroll direction.\n   * Recommended value ~0.5, so it will distribute tiles evenly in both directions.\n   */\n  _ratio: 0.5,\n  /**\n   * The padding-top value for the list.\n   */\n  _scrollerPaddingTop: 0,\n  /**\n   * This value is the same as `scrollTop`.\n   */\n  _scrollPosition: 0,\n  /**\n   * The sum of the heights of all the tiles in the DOM.\n   */\n  _physicalSize: 0,\n  /**\n   * The average `offsetHeight` of the tiles observed till now.\n   */\n  _physicalAverage: 0,\n  /**\n   * The number of tiles which `offsetHeight` > 0 observed until now.\n   */\n  _physicalAverageCount: 0,\n  /**\n   * The Y position of the item rendered in the `_physicalStart`\n   * tile relative to the scrolling list.\n   */\n  _physicalTop: 0,\n  /**\n   * The number of items in the list.\n   */\n  _virtualCount: 0,\n  /**\n   * The estimated scroll height based on `_physicalAverage`\n   */\n  _estScrollHeight: 0,\n  /**\n   * The scroll height of the dom node\n   */\n  _scrollHeight: 0,\n  /**\n   * The height of the list. This is referred as the viewport in the context of list.\n   */\n  _viewportHeight: 0,\n  /**\n   * The width of the list. This is referred as the viewport in the context of list.\n   */\n  _viewportWidth: 0,\n  /**\n   * An array of DOM nodes that are currently in the tree\n   * @type {?Array<!TemplatizerNode>}\n   */\n  _physicalItems: null,\n  /**\n   * An array of heights for each item in `_physicalItems`\n   * @type {?Array<number>}\n   */\n  _physicalSizes: null,\n  /**\n   * A cached value for the first visible index.\n   * See `firstVisibleIndex`\n   * @type {?number}\n   */\n  _firstVisibleIndexVal: null,\n  /**\n   * A Polymer collection for the items.\n   * @type {?Polymer.Collection}\n   */\n  _collection: null,\n  /**\n   * A cached value for the last visible index.\n   * See `lastVisibleIndex`\n   * @type {?number}\n   */\n  _lastVisibleIndexVal: null,\n  /**\n   * The max number of pages to render. One page is equivalent to the height of the list.\n   */\n  _maxPages: 2,\n  /**\n   * The virtual index of the focused item.\n   */\n  _focusedVirtualIndex: -1,\n  /**\n   * The maximum items per row\n   */\n  _itemsPerRow: 1,\n  /**\n   * The height of the row in grid layout.\n   */\n  _rowHeight: 0,\n  /**\n   * The cost of stamping a template in ms.\n   */\n  _templateCost: 0,\n  /**\n   * The bottom of the physical content.\n   */\n  get _physicalBottom() {\n    return this._physicalTop + this._physicalSize;\n  },\n  /**\n   * The bottom of the scroll.\n   */\n  get _scrollBottom() {\n    return this._scrollPosition + this._viewportHeight;\n  },\n  /**\n   * The n-th item rendered in the last physical item.\n   */\n  get _virtualEnd() {\n    return this._virtualStart + this._physicalCount - 1;\n  },\n  /**\n   * The height of the physical content that isn't on the screen.\n   */\n  get _hiddenContentSize() {\n    var size = this.grid ? this._physicalRows * this._rowHeight : this._physicalSize;\n    return size - this._viewportHeight;\n  },\n  /**\n   * The maximum scroll top value.\n   */\n  get _maxScrollTop() {\n    return this._estScrollHeight - this._viewportHeight + this._scrollOffset;\n  },\n  /**\n   * The largest n-th value for an item such that it can be rendered in `_physicalStart`.\n   */\n  get _maxVirtualStart() {\n    var virtualCount = this._convertIndexToCompleteRow(this._virtualCount);\n    return Math.max(0, virtualCount - this._physicalCount);\n  },\n  set _virtualStart(val) {\n    val = this._clamp(val, 0, this._maxVirtualStart);\n    if (this.grid) {\n      val = val - val % this._itemsPerRow;\n    }\n    this._virtualStartVal = val;\n  },\n  get _virtualStart() {\n    return this._virtualStartVal || 0;\n  },\n  /**\n   * The k-th tile that is at the top of the scrolling list.\n   */\n  set _physicalStart(val) {\n    val = val % this._physicalCount;\n    if (val < 0) {\n      val = this._physicalCount + val;\n    }\n    if (this.grid) {\n      val = val - val % this._itemsPerRow;\n    }\n    this._physicalStartVal = val;\n  },\n  get _physicalStart() {\n    return this._physicalStartVal || 0;\n  },\n  /**\n   * The k-th tile that is at the bottom of the scrolling list.\n   */\n  get _physicalEnd() {\n    return (this._physicalStart + this._physicalCount - 1) % this._physicalCount;\n  },\n  set _physicalCount(val) {\n    this._physicalCountVal = val;\n  },\n  get _physicalCount() {\n    return this._physicalCountVal || 0;\n  },\n  /**\n   * An optimal physical size such that we will have enough physical items\n   * to fill up the viewport and recycle when the user scrolls.\n   *\n   * This default value assumes that we will at least have the equivalent\n   * to a viewport of physical items above and below the user's viewport.\n   */\n  get _optPhysicalSize() {\n    return this._viewportHeight === 0 ? Infinity : this._viewportHeight * this._maxPages;\n  },\n  /**\n   * True if the current list is visible.\n   */\n  get _isVisible() {\n    return Boolean(this.offsetWidth || this.offsetHeight);\n  },\n  /**\n   * Gets the index of the first visible item in the viewport.\n   *\n   * @type {number}\n   */\n  get firstVisibleIndex() {\n    var idx = this._firstVisibleIndexVal;\n    if (idx == null) {\n      var physicalOffset = this._physicalTop + this._scrollOffset;\n      idx = this._iterateItems(function (pidx, vidx) {\n        physicalOffset += this._getPhysicalSizeIncrement(pidx);\n        if (physicalOffset > this._scrollPosition) {\n          return this.grid ? vidx - vidx % this._itemsPerRow : vidx;\n        }\n        // Handle a partially rendered final row in grid mode\n        if (this.grid && this._virtualCount - 1 === vidx) {\n          return vidx - vidx % this._itemsPerRow;\n        }\n      }) || 0;\n      this._firstVisibleIndexVal = idx;\n    }\n    return idx;\n  },\n  /**\n   * Gets the index of the last visible item in the viewport.\n   *\n   * @type {number}\n   */\n  get lastVisibleIndex() {\n    var idx = this._lastVisibleIndexVal;\n    if (idx == null) {\n      if (this.grid) {\n        idx = Math.min(this._virtualCount, this.firstVisibleIndex + this._estRowsInView * this._itemsPerRow - 1);\n      } else {\n        var physicalOffset = this._physicalTop + this._scrollOffset;\n        this._iterateItems(function (pidx, vidx) {\n          if (physicalOffset < this._scrollBottom) {\n            idx = vidx;\n          }\n          physicalOffset += this._getPhysicalSizeIncrement(pidx);\n        });\n      }\n      this._lastVisibleIndexVal = idx;\n    }\n    return idx;\n  },\n  get _scrollOffset() {\n    return this._scrollerPaddingTop;\n  },\n  attached: function () {\n    this._debounce('_render', this._render, ANIMATION_FRAME);\n    // `iron-resize` is fired when the list is attached if the event is added\n    // before attached causing unnecessary work.\n    this.listen(this, 'iron-resize', '_resizeHandler');\n  },\n  detached: function () {\n    this.unlisten(this, 'iron-resize', '_resizeHandler');\n  },\n  /**\n   * Invoke this method if you dynamically update the viewport's\n   * size or CSS padding.\n   *\n   * @method updateViewportBoundaries\n   */\n  updateViewportBoundaries: function () {\n    var styles = window.getComputedStyle(this);\n    this._scrollerPaddingTop = this.scrollTarget === this ? 0 : parseInt(styles['padding-top'], 10);\n    this._isRTL = Boolean(styles.direction === 'rtl');\n    this._viewportWidth = this.$.items.offsetWidth;\n    this._viewportHeight = this._scrollTargetHeight;\n    this.grid && this._updateGridMetrics();\n  },\n  /**\n   * Recycles the physical items when needed.\n   */\n  _scrollHandler: function () {\n    var scrollTop = Math.max(0, Math.min(this._maxScrollTop, this._scrollTop));\n    var delta = scrollTop - this._scrollPosition;\n    var isScrollingDown = delta >= 0;\n    // Track the current scroll position.\n    this._scrollPosition = scrollTop;\n    // Clear indexes for first and last visible indexes.\n    this._firstVisibleIndexVal = null;\n    this._lastVisibleIndexVal = null;\n    // Random access.\n    if (Math.abs(delta) > this._physicalSize && this._physicalSize > 0) {\n      delta = delta - this._scrollOffset;\n      var idxAdjustment = Math.round(delta / this._physicalAverage) * this._itemsPerRow;\n      this._virtualStart = this._virtualStart + idxAdjustment;\n      this._physicalStart = this._physicalStart + idxAdjustment;\n      // Estimate new physical offset.\n      this._physicalTop = Math.floor(this._virtualStart / this._itemsPerRow) * this._physicalAverage;\n      this._update();\n    } else if (this._physicalCount > 0) {\n      var reusables = this._getReusables(isScrollingDown);\n      if (isScrollingDown) {\n        this._physicalTop = reusables.physicalTop;\n        this._virtualStart = this._virtualStart + reusables.indexes.length;\n        this._physicalStart = this._physicalStart + reusables.indexes.length;\n      } else {\n        this._virtualStart = this._virtualStart - reusables.indexes.length;\n        this._physicalStart = this._physicalStart - reusables.indexes.length;\n      }\n      this._update(reusables.indexes, isScrollingDown ? null : reusables.indexes);\n      this._debounce('_increasePoolIfNeeded', this._increasePoolIfNeeded.bind(this, 0), MICRO_TASK);\n    }\n  },\n  /**\n   * Returns an object that contains the indexes of the physical items\n   * that might be reused and the physicalTop.\n   *\n   * @param {boolean} fromTop If the potential reusable items are above the scrolling region.\n   */\n  _getReusables: function (fromTop) {\n    var ith, offsetContent, physicalItemHeight;\n    var idxs = [];\n    var protectedOffsetContent = this._hiddenContentSize * this._ratio;\n    var virtualStart = this._virtualStart;\n    var virtualEnd = this._virtualEnd;\n    var physicalCount = this._physicalCount;\n    var top = this._physicalTop + this._scrollOffset;\n    var bottom = this._physicalBottom + this._scrollOffset;\n    var scrollTop = this._scrollTop;\n    var scrollBottom = this._scrollBottom;\n    if (fromTop) {\n      ith = this._physicalStart;\n      offsetContent = scrollTop - top;\n    } else {\n      ith = this._physicalEnd;\n      offsetContent = bottom - scrollBottom;\n    }\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      physicalItemHeight = this._getPhysicalSizeIncrement(ith);\n      offsetContent = offsetContent - physicalItemHeight;\n      if (idxs.length >= physicalCount || offsetContent <= protectedOffsetContent) {\n        break;\n      }\n      if (fromTop) {\n        // Check that index is within the valid range.\n        if (virtualEnd + idxs.length + 1 >= this._virtualCount) {\n          break;\n        }\n        // Check that the index is not visible.\n        if (top + physicalItemHeight >= scrollTop - this._scrollOffset) {\n          break;\n        }\n        idxs.push(ith);\n        top = top + physicalItemHeight;\n        ith = (ith + 1) % physicalCount;\n      } else {\n        // Check that index is within the valid range.\n        if (virtualStart - idxs.length <= 0) {\n          break;\n        }\n        // Check that the index is not visible.\n        if (top + this._physicalSize - physicalItemHeight <= scrollBottom) {\n          break;\n        }\n        idxs.push(ith);\n        top = top - physicalItemHeight;\n        ith = ith === 0 ? physicalCount - 1 : ith - 1;\n      }\n    }\n    return {\n      indexes: idxs,\n      physicalTop: top - this._scrollOffset\n    };\n  },\n  /**\n   * Update the list of items, starting from the `_virtualStart` item.\n   * @param {!Array<number>=} itemSet\n   * @param {!Array<number>=} movingUp\n   */\n  _update: function (itemSet, movingUp) {\n    if (itemSet && itemSet.length === 0 || this._physicalCount === 0) {\n      return;\n    }\n    this._manageFocus();\n    this._assignModels(itemSet);\n    this._updateMetrics(itemSet);\n    // Adjust offset after measuring.\n    if (movingUp) {\n      while (movingUp.length) {\n        var idx = movingUp.pop();\n        this._physicalTop -= this._getPhysicalSizeIncrement(idx);\n      }\n    }\n    this._positionItems();\n    this._updateScrollerSize();\n  },\n  _isClientFull: function () {\n    return this._scrollBottom != 0 && this._physicalBottom - 1 >= this._scrollBottom && this._physicalTop <= this._scrollPosition;\n  },\n  /**\n   * Increases the pool size.\n   */\n  _increasePoolIfNeeded: function (count) {\n    var nextPhysicalCount = this._clamp(this._physicalCount + count, DEFAULT_PHYSICAL_COUNT, this._virtualCount - this._virtualStart);\n    nextPhysicalCount = this._convertIndexToCompleteRow(nextPhysicalCount);\n    var delta = nextPhysicalCount - this._physicalCount;\n    var nextIncrease = Math.round(this._physicalCount * 0.5);\n    if (delta < 0) {\n      return;\n    }\n    if (delta > 0) {\n      var ts = window.performance.now();\n      // Concat arrays in place.\n      [].push.apply(this._physicalItems, this._createPool(delta));\n      // Push 0s into physicalSizes. Can't use Array.fill because IE11 doesn't support it.\n      for (var i = 0; i < delta; i++) {\n        this._physicalSizes.push(0);\n      }\n      this._physicalCount = this._physicalCount + delta;\n      // Update the physical start if it needs to preserve the model of the focused item.\n      // In this situation, the focused item is currently rendered and its model would\n      // have changed after increasing the pool if the physical start remained unchanged.\n      if (this._physicalStart > this._physicalEnd && this._isIndexRendered(this._focusedVirtualIndex) && this._getPhysicalIndex(this._focusedVirtualIndex) < this._physicalEnd) {\n        this._physicalStart = this._physicalStart + delta;\n      }\n      this._update();\n      this._templateCost = (window.performance.now() - ts) / delta;\n      nextIncrease = Math.round(this._physicalCount * 0.5);\n    }\n    // The upper bounds is not fixed when dealing with a grid that doesn't\n    // fill it's last row with the exact number of items per row.\n    if (this._virtualEnd >= this._virtualCount - 1 || nextIncrease === 0) {\n      // Do nothing.\n    } else if (!this._isClientFull()) {\n      this._debounce('_increasePoolIfNeeded', this._increasePoolIfNeeded.bind(this, nextIncrease), MICRO_TASK);\n    } else if (this._physicalSize < this._optPhysicalSize) {\n      // Yield and increase the pool during idle time until the physical size is optimal.\n      this._debounce('_increasePoolIfNeeded', this._increasePoolIfNeeded.bind(this, this._clamp(Math.round(50 / this._templateCost), 1, nextIncrease)), IDLE_TIME);\n    }\n  },\n  /**\n   * Renders the a new list.\n   */\n  _render: function () {\n    if (!this.isAttached || !this._isVisible) {\n      return;\n    }\n    if (this._physicalCount !== 0) {\n      var reusables = this._getReusables(true);\n      this._physicalTop = reusables.physicalTop;\n      this._virtualStart = this._virtualStart + reusables.indexes.length;\n      this._physicalStart = this._physicalStart + reusables.indexes.length;\n      this._update(reusables.indexes);\n      this._update();\n      this._increasePoolIfNeeded(0);\n    } else if (this._virtualCount > 0) {\n      // Initial render\n      this.updateViewportBoundaries();\n      this._increasePoolIfNeeded(DEFAULT_PHYSICAL_COUNT);\n    }\n  },\n  /**\n   * Called when the items have changed. That is, reassignments\n   * to `items`, splices or updates to a single item.\n   */\n  _itemsChanged: function (change) {\n    if (change.path === 'items') {\n      this._virtualStart = 0;\n      this._physicalTop = 0;\n      this._virtualCount = this.items ? this.items.length : 0;\n      this._collection = this.items && undefined ? undefined.get(this.items) : null;\n      this._physicalIndexForKey = {};\n      this._firstVisibleIndexVal = null;\n      this._lastVisibleIndexVal = null;\n      this._physicalCount = this._physicalCount || 0;\n      this._physicalItems = this._physicalItems || [];\n      this._physicalSizes = this._physicalSizes || [];\n      this._physicalStart = 0;\n      if (this._scrollTop > this._scrollOffset) {\n        this._resetScrollPosition(0);\n      }\n      this._removeFocusedItem();\n      this._debounce('_render', this._render, ANIMATION_FRAME);\n    }\n  },\n  /**\n   * Executes a provided function per every physical index in `itemSet`\n   * `itemSet` default value is equivalent to the entire set of physical indexes.\n   *\n   * @param {!function(number, number)} fn\n   * @param {!Array<number>=} itemSet\n   */\n  _iterateItems: function (fn, itemSet) {\n    var pidx, vidx, rtn, i;\n    if (arguments.length === 2 && itemSet) {\n      for (i = 0; i < itemSet.length; i++) {\n        pidx = itemSet[i];\n        vidx = this._computeVidx(pidx);\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n    } else {\n      pidx = this._physicalStart;\n      vidx = this._virtualStart;\n      for (; pidx < this._physicalCount; pidx++, vidx++) {\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n      for (pidx = 0; pidx < this._physicalStart; pidx++, vidx++) {\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n    }\n  },\n  /**\n   * Returns the virtual index for a given physical index\n   *\n   * @param {number} pidx Physical index\n   * @return {number}\n   */\n  _computeVidx: function (pidx) {\n    if (pidx >= this._physicalStart) {\n      return this._virtualStart + (pidx - this._physicalStart);\n    }\n    return this._virtualStart + (this._physicalCount - this._physicalStart) + pidx;\n  },\n  /**\n   * Updates the height for a given set of items.\n   *\n   * @param {!Array<number>=} itemSet\n   */\n  _updateMetrics: function (itemSet) {\n    // Make sure we distributed all the physical items\n    // so we can measure them.\n    flush ? flush() : flush$0();\n    var newPhysicalSize = 0;\n    var oldPhysicalSize = 0;\n    var prevAvgCount = this._physicalAverageCount;\n    var prevPhysicalAvg = this._physicalAverage;\n    this._iterateItems(function (pidx, vidx) {\n      oldPhysicalSize += this._physicalSizes[pidx];\n      this._physicalSizes[pidx] = this._physicalItems[pidx].offsetHeight;\n      newPhysicalSize += this._physicalSizes[pidx];\n      this._physicalAverageCount += this._physicalSizes[pidx] ? 1 : 0;\n    }, itemSet);\n    if (this.grid) {\n      this._updateGridMetrics();\n      this._physicalSize = Math.ceil(this._physicalCount / this._itemsPerRow) * this._rowHeight;\n    } else {\n      oldPhysicalSize = this._itemsPerRow === 1 ? oldPhysicalSize : Math.ceil(this._physicalCount / this._itemsPerRow) * this._rowHeight;\n      this._physicalSize = this._physicalSize + newPhysicalSize - oldPhysicalSize;\n      this._itemsPerRow = 1;\n    }\n    // Update the average if it measured something.\n    if (this._physicalAverageCount !== prevAvgCount) {\n      this._physicalAverage = Math.round((prevPhysicalAvg * prevAvgCount + newPhysicalSize) / this._physicalAverageCount);\n    }\n  },\n  /**\n   * Updates the position of the physical items.\n   */\n  _positionItems: function () {\n    this._adjustScrollPosition();\n    var y = this._physicalTop;\n    this._iterateItems(function (pidx, vidx) {\n      this.translate3d(0, y + 'px', 0, this._physicalItems[pidx]);\n      y += this._physicalSizes[pidx];\n    });\n  },\n  _getPhysicalSizeIncrement: function (pidx) {\n    if (!this.grid) {\n      return this._physicalSizes[pidx];\n    }\n    if (this._computeVidx(pidx) % this._itemsPerRow !== this._itemsPerRow - 1) {\n      return 0;\n    }\n    return this._rowHeight;\n  },\n  /**\n   * Adjusts the scroll position when it was overestimated.\n   */\n  _adjustScrollPosition: function () {\n    var deltaHeight = this._virtualStart === 0 ? this._physicalTop : Math.min(this._scrollPosition + this._physicalTop, 0);\n    // Note: the delta can be positive or negative.\n    if (deltaHeight !== 0) {\n      this._physicalTop = this._physicalTop - deltaHeight;\n      var scrollTop = this._scrollTop;\n      // juking scroll position during interial scrolling on iOS is no bueno\n      if (!IOS_TOUCH_SCROLLING && scrollTop > 0) {\n        this._resetScrollPosition(scrollTop - deltaHeight);\n      }\n    }\n  },\n  /**\n   * Sets the position of the scroll.\n   */\n  _resetScrollPosition: function (pos) {\n    if (this.scrollTarget && pos >= 0) {\n      this._scrollTop = pos;\n      this._scrollPosition = this._scrollTop;\n    }\n  },\n  /**\n   * Sets the scroll height, that's the height of the content,\n   *\n   * @param {boolean=} forceUpdate If true, updates the height no matter what.\n   */\n  _updateScrollerSize: function (forceUpdate) {\n    if (this.grid) {\n      this._estScrollHeight = this._virtualRowCount * this._rowHeight;\n    } else {\n      this._estScrollHeight = this._physicalBottom + Math.max(this._virtualCount - this._physicalCount - this._virtualStart, 0) * this._physicalAverage;\n    }\n    forceUpdate = forceUpdate || this._scrollHeight === 0;\n    forceUpdate = forceUpdate || this._scrollPosition >= this._estScrollHeight - this._physicalSize;\n    forceUpdate = forceUpdate || this.grid && this.$.items.style.height < this._estScrollHeight;\n    // Amortize height adjustment, so it won't trigger large repaints too often.\n    if (forceUpdate || Math.abs(this._estScrollHeight - this._scrollHeight) >= this._viewportHeight) {\n      this.$.items.style.height = this._estScrollHeight + 'px';\n      this._scrollHeight = this._estScrollHeight;\n    }\n  },\n  /**\n   * Scroll to a specific index in the virtual list regardless\n   * of the physical items in the DOM tree.\n   *\n   * @method scrollToIndex\n   * @param {number} idx The index of the item\n   */\n  scrollToIndex: function (idx) {\n    if (typeof idx !== 'number' || idx < 0 || idx > this.items.length - 1) {\n      return;\n    }\n    flush ? flush() : flush$0();\n    // Items should have been rendered prior scrolling to an index.\n    if (this._physicalCount === 0) {\n      return;\n    }\n    idx = this._clamp(idx, 0, this._virtualCount - 1);\n    // Update the virtual start only when needed.\n    if (!this._isIndexRendered(idx) || idx >= this._maxVirtualStart) {\n      this._virtualStart = this.grid ? idx - this._itemsPerRow * 2 : idx - 1;\n    }\n    this._manageFocus();\n    this._assignModels();\n    this._updateMetrics();\n    // Estimate new physical offset.\n    this._physicalTop = Math.floor(this._virtualStart / this._itemsPerRow) * this._physicalAverage;\n    var currentTopItem = this._physicalStart;\n    var currentVirtualItem = this._virtualStart;\n    var targetOffsetTop = 0;\n    var hiddenContentSize = this._hiddenContentSize;\n    // scroll to the item as much as we can.\n    while (currentVirtualItem < idx && targetOffsetTop <= hiddenContentSize) {\n      targetOffsetTop = targetOffsetTop + this._getPhysicalSizeIncrement(currentTopItem);\n      currentTopItem = (currentTopItem + 1) % this._physicalCount;\n      currentVirtualItem++;\n    }\n    this._updateScrollerSize(true);\n    this._positionItems();\n    this._resetScrollPosition(this._physicalTop + this._scrollOffset + targetOffsetTop);\n    this._increasePoolIfNeeded(0);\n    // clear cached visible index.\n    this._firstVisibleIndexVal = null;\n    this._lastVisibleIndexVal = null;\n  },\n  /**\n   * Reset the physical average and the average count.\n   */\n  _resetAverage: function () {\n    this._physicalAverage = 0;\n    this._physicalAverageCount = 0;\n  },\n  /**\n   * A handler for the `iron-resize` event triggered by `IronResizableBehavior`\n   * when the element is resized.\n   */\n  _resizeHandler: function () {\n    this._debounce('_render', function () {\n      // clear cached visible index.\n      this._firstVisibleIndexVal = null;\n      this._lastVisibleIndexVal = null;\n      // Skip the resize event on touch devices when the address bar slides up.\n      this.updateViewportBoundaries();\n      if (this._isVisible) {\n        // Reinstall the scroll event listener.\n        this.toggleScrollListener(true);\n        this._resetAverage();\n        this._render();\n      } else {\n        // Uninstall the scroll event listener.\n        this.toggleScrollListener(false);\n      }\n    }, ANIMATION_FRAME);\n  },\n  /**\n   * Converts a random index to the index of the item that completes it's row.\n   * Allows for better order and fill computation when grid == true.\n   */\n  _convertIndexToCompleteRow: function (idx) {\n    // when grid == false _itemPerRow can be unset.\n    this._itemsPerRow = this._itemsPerRow || 1;\n    return this.grid ? Math.ceil(idx / this._itemsPerRow) * this._itemsPerRow : idx;\n  },\n  _isIndexRendered: function (idx) {\n    return idx >= this._virtualStart && idx <= this._virtualEnd;\n  },\n  _getPhysicalIndex: function (vidx) {\n    return (this._physicalStart + (vidx - this._virtualStart)) % this._physicalCount;\n  },\n  _clamp: function (v, min, max) {\n    return Math.min(max, Math.max(min, v));\n  },\n  _debounce: function (name, cb, asyncModule) {\n    this._debouncers = this._debouncers || {};\n    this._debouncers[name] = Debouncer.debounce(this._debouncers[name], asyncModule, cb.bind(this));\n    enqueueDebouncer(this._debouncers[name]);\n  }\n});","map":{"version":3,"names":["IronResizableBehavior","IronScrollTargetBehavior","animationFrame","idlePeriod","microTask","Class","flush","enqueueDebouncer","flush$0","Debouncer","IOS","navigator","userAgent","match","IOS_TOUCH_SCROLLING","DEFAULT_PHYSICAL_COUNT","ANIMATION_FRAME","IDLE_TIME","MICRO_TASK","PolymerIronList","behaviors","_ratio","_scrollerPaddingTop","_scrollPosition","_physicalSize","_physicalAverage","_physicalAverageCount","_physicalTop","_virtualCount","_estScrollHeight","_scrollHeight","_viewportHeight","_viewportWidth","_physicalItems","_physicalSizes","_firstVisibleIndexVal","_collection","_lastVisibleIndexVal","_maxPages","_focusedVirtualIndex","_itemsPerRow","_rowHeight","_templateCost","_physicalBottom","_scrollBottom","_virtualEnd","_virtualStart","_physicalCount","_hiddenContentSize","size","grid","_physicalRows","_maxScrollTop","_scrollOffset","_maxVirtualStart","virtualCount","_convertIndexToCompleteRow","Math","max","val","_clamp","_virtualStartVal","_physicalStart","_physicalStartVal","_physicalEnd","_physicalCountVal","_optPhysicalSize","Infinity","_isVisible","Boolean","offsetWidth","offsetHeight","firstVisibleIndex","idx","physicalOffset","_iterateItems","pidx","vidx","_getPhysicalSizeIncrement","lastVisibleIndex","min","_estRowsInView","attached","_debounce","_render","listen","detached","unlisten","updateViewportBoundaries","styles","window","getComputedStyle","scrollTarget","parseInt","_isRTL","direction","$","items","_scrollTargetHeight","_updateGridMetrics","_scrollHandler","scrollTop","_scrollTop","delta","isScrollingDown","abs","idxAdjustment","round","floor","_update","reusables","_getReusables","physicalTop","indexes","length","_increasePoolIfNeeded","bind","fromTop","ith","offsetContent","physicalItemHeight","idxs","protectedOffsetContent","virtualStart","virtualEnd","physicalCount","top","bottom","scrollBottom","push","itemSet","movingUp","_manageFocus","_assignModels","_updateMetrics","pop","_positionItems","_updateScrollerSize","_isClientFull","count","nextPhysicalCount","nextIncrease","ts","performance","now","apply","_createPool","i","_isIndexRendered","_getPhysicalIndex","isAttached","_itemsChanged","change","path","undefined","get","_physicalIndexForKey","_resetScrollPosition","_removeFocusedItem","fn","rtn","arguments","_computeVidx","call","newPhysicalSize","oldPhysicalSize","prevAvgCount","prevPhysicalAvg","ceil","_adjustScrollPosition","y","translate3d","deltaHeight","pos","forceUpdate","_virtualRowCount","style","height","scrollToIndex","currentTopItem","currentVirtualItem","targetOffsetTop","hiddenContentSize","_resetAverage","_resizeHandler","toggleScrollListener","v","name","cb","asyncModule","_debouncers","debounce"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@vaadin/vaadin-grid/src/iron-list.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n/**\n\nThis is a fork of <iron-list> for <vaadin-grid>'s internal purposes only!\nTo update:\n1. Get the most recent code from https://github.com/PolymerElements/iron-list/\n2. Remove the  <dom-module id=\"iron-list\"> to avoid collisions with actual <iron-list>\n3. Change \"Polymer({\" to \"window.PolymerIronList = Polymer.Class({\" to expose the class\n3.1. Add @namespace\n4. Optional: Remove all properties and functions not needed by <vaadin-grid>\n5. Profit!\n\n*/\n/*\n  FIXME(polymer-modulizer): the above comments were extracted\n  from HTML and may be out of place here. Review them and\n  then delete this comment!\n*/\nimport '@polymer/polymer/polymer-legacy.js';\n\nimport { IronResizableBehavior } from '@polymer/iron-resizable-behavior/iron-resizable-behavior.js';\nimport { IronScrollTargetBehavior } from '@polymer/iron-scroll-target-behavior/iron-scroll-target-behavior.js';\nimport { animationFrame, idlePeriod, microTask } from '@polymer/polymer/lib/utils/async.js';\nimport { Class } from '@polymer/polymer/lib/legacy/class.js';\nimport { flush, enqueueDebouncer } from '@polymer/polymer/lib/utils/flush.js';\nimport { flush as flush$0 } from '@polymer/polymer/lib/legacy/polymer.dom.js';\nimport { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\nvar IOS = navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\\d+)/);\nvar IOS_TOUCH_SCROLLING = IOS && IOS[1] >= 8;\nvar DEFAULT_PHYSICAL_COUNT = 3;\nvar ANIMATION_FRAME = animationFrame;\nvar IDLE_TIME = idlePeriod;\nvar MICRO_TASK = microTask;\n\nexport const PolymerIronList = Class({\n\n  behaviors: [\n    IronResizableBehavior,\n    IronScrollTargetBehavior\n  ],\n\n  /**\n   * The ratio of hidden tiles that should remain in the scroll direction.\n   * Recommended value ~0.5, so it will distribute tiles evenly in both directions.\n   */\n  _ratio: 0.5,\n\n  /**\n   * The padding-top value for the list.\n   */\n  _scrollerPaddingTop: 0,\n\n  /**\n   * This value is the same as `scrollTop`.\n   */\n  _scrollPosition: 0,\n\n  /**\n   * The sum of the heights of all the tiles in the DOM.\n   */\n  _physicalSize: 0,\n\n  /**\n   * The average `offsetHeight` of the tiles observed till now.\n   */\n  _physicalAverage: 0,\n\n  /**\n   * The number of tiles which `offsetHeight` > 0 observed until now.\n   */\n  _physicalAverageCount: 0,\n\n  /**\n   * The Y position of the item rendered in the `_physicalStart`\n   * tile relative to the scrolling list.\n   */\n  _physicalTop: 0,\n\n  /**\n   * The number of items in the list.\n   */\n  _virtualCount: 0,\n\n  /**\n   * The estimated scroll height based on `_physicalAverage`\n   */\n  _estScrollHeight: 0,\n\n  /**\n   * The scroll height of the dom node\n   */\n  _scrollHeight: 0,\n\n  /**\n   * The height of the list. This is referred as the viewport in the context of list.\n   */\n  _viewportHeight: 0,\n\n  /**\n   * The width of the list. This is referred as the viewport in the context of list.\n   */\n  _viewportWidth: 0,\n\n  /**\n   * An array of DOM nodes that are currently in the tree\n   * @type {?Array<!TemplatizerNode>}\n   */\n  _physicalItems: null,\n\n  /**\n   * An array of heights for each item in `_physicalItems`\n   * @type {?Array<number>}\n   */\n  _physicalSizes: null,\n\n  /**\n   * A cached value for the first visible index.\n   * See `firstVisibleIndex`\n   * @type {?number}\n   */\n  _firstVisibleIndexVal: null,\n\n  /**\n   * A Polymer collection for the items.\n   * @type {?Polymer.Collection}\n   */\n  _collection: null,\n\n  /**\n   * A cached value for the last visible index.\n   * See `lastVisibleIndex`\n   * @type {?number}\n   */\n  _lastVisibleIndexVal: null,\n\n  /**\n   * The max number of pages to render. One page is equivalent to the height of the list.\n   */\n  _maxPages: 2,\n\n  /**\n   * The virtual index of the focused item.\n   */\n  _focusedVirtualIndex: -1,\n\n  /**\n   * The maximum items per row\n   */\n  _itemsPerRow: 1,\n\n  /**\n   * The height of the row in grid layout.\n   */\n  _rowHeight: 0,\n\n  /**\n   * The cost of stamping a template in ms.\n   */\n  _templateCost: 0,\n\n  /**\n   * The bottom of the physical content.\n   */\n  get _physicalBottom() {\n    return this._physicalTop + this._physicalSize;\n  },\n\n  /**\n   * The bottom of the scroll.\n   */\n  get _scrollBottom() {\n    return this._scrollPosition + this._viewportHeight;\n  },\n\n  /**\n   * The n-th item rendered in the last physical item.\n   */\n  get _virtualEnd() {\n    return this._virtualStart + this._physicalCount - 1;\n  },\n\n  /**\n   * The height of the physical content that isn't on the screen.\n   */\n  get _hiddenContentSize() {\n    var size = this.grid ? this._physicalRows * this._rowHeight : this._physicalSize;\n    return size - this._viewportHeight;\n  },\n\n  /**\n   * The maximum scroll top value.\n   */\n  get _maxScrollTop() {\n    return this._estScrollHeight - this._viewportHeight + this._scrollOffset;\n  },\n\n  /**\n   * The largest n-th value for an item such that it can be rendered in `_physicalStart`.\n   */\n  get _maxVirtualStart() {\n    var virtualCount = this._convertIndexToCompleteRow(this._virtualCount);\n    return Math.max(0, virtualCount - this._physicalCount);\n  },\n\n  set _virtualStart(val) {\n    val = this._clamp(val, 0, this._maxVirtualStart);\n    if (this.grid) {\n      val = val - (val % this._itemsPerRow);\n    }\n    this._virtualStartVal = val;\n  },\n\n  get _virtualStart() {\n    return this._virtualStartVal || 0;\n  },\n\n  /**\n   * The k-th tile that is at the top of the scrolling list.\n   */\n  set _physicalStart(val) {\n    val = val % this._physicalCount;\n    if (val < 0) {\n      val = this._physicalCount + val;\n    }\n    if (this.grid) {\n      val = val - (val % this._itemsPerRow);\n    }\n    this._physicalStartVal = val;\n  },\n\n  get _physicalStart() {\n    return this._physicalStartVal || 0;\n  },\n\n  /**\n   * The k-th tile that is at the bottom of the scrolling list.\n   */\n  get _physicalEnd() {\n    return (this._physicalStart + this._physicalCount - 1) % this._physicalCount;\n  },\n\n  set _physicalCount(val) {\n    this._physicalCountVal = val;\n  },\n\n  get _physicalCount() {\n    return this._physicalCountVal || 0;\n  },\n\n  /**\n   * An optimal physical size such that we will have enough physical items\n   * to fill up the viewport and recycle when the user scrolls.\n   *\n   * This default value assumes that we will at least have the equivalent\n   * to a viewport of physical items above and below the user's viewport.\n   */\n  get _optPhysicalSize() {\n    return this._viewportHeight === 0 ? Infinity : this._viewportHeight * this._maxPages;\n  },\n\n  /**\n   * True if the current list is visible.\n   */\n  get _isVisible() {\n    return Boolean(this.offsetWidth || this.offsetHeight);\n  },\n\n  /**\n   * Gets the index of the first visible item in the viewport.\n   *\n   * @type {number}\n   */\n  get firstVisibleIndex() {\n    var idx = this._firstVisibleIndexVal;\n    if (idx == null) {\n      var physicalOffset = this._physicalTop + this._scrollOffset;\n\n      idx = this._iterateItems(function(pidx, vidx) {\n        physicalOffset += this._getPhysicalSizeIncrement(pidx);\n\n        if (physicalOffset > this._scrollPosition) {\n          return this.grid ? vidx - (vidx % this._itemsPerRow) : vidx;\n        }\n        // Handle a partially rendered final row in grid mode\n        if (this.grid && this._virtualCount - 1 === vidx) {\n          return vidx - (vidx % this._itemsPerRow);\n        }\n      }) || 0;\n      this._firstVisibleIndexVal = idx;\n    }\n    return idx;\n  },\n\n  /**\n   * Gets the index of the last visible item in the viewport.\n   *\n   * @type {number}\n   */\n  get lastVisibleIndex() {\n    var idx = this._lastVisibleIndexVal;\n    if (idx == null) {\n      if (this.grid) {\n        idx = Math.min(this._virtualCount, this.firstVisibleIndex + this._estRowsInView * this._itemsPerRow - 1);\n      } else {\n        var physicalOffset = this._physicalTop + this._scrollOffset;\n        this._iterateItems(function(pidx, vidx) {\n          if (physicalOffset < this._scrollBottom) {\n            idx = vidx;\n          }\n          physicalOffset += this._getPhysicalSizeIncrement(pidx);\n        });\n      }\n      this._lastVisibleIndexVal = idx;\n    }\n    return idx;\n  },\n\n  get _scrollOffset() {\n    return this._scrollerPaddingTop;\n  },\n\n  attached: function() {\n    this._debounce('_render', this._render, ANIMATION_FRAME);\n    // `iron-resize` is fired when the list is attached if the event is added\n    // before attached causing unnecessary work.\n    this.listen(this, 'iron-resize', '_resizeHandler');\n  },\n\n  detached: function() {\n    this.unlisten(this, 'iron-resize', '_resizeHandler');\n  },\n\n  /**\n   * Invoke this method if you dynamically update the viewport's\n   * size or CSS padding.\n   *\n   * @method updateViewportBoundaries\n   */\n  updateViewportBoundaries: function() {\n    var styles = window.getComputedStyle(this);\n    this._scrollerPaddingTop = this.scrollTarget === this ? 0 : parseInt(styles['padding-top'], 10);\n    this._isRTL = Boolean(styles.direction === 'rtl');\n    this._viewportWidth = this.$.items.offsetWidth;\n    this._viewportHeight = this._scrollTargetHeight;\n    this.grid && this._updateGridMetrics();\n  },\n\n  /**\n   * Recycles the physical items when needed.\n   */\n  _scrollHandler: function() {\n    var scrollTop = Math.max(0, Math.min(this._maxScrollTop, this._scrollTop));\n    var delta = scrollTop - this._scrollPosition;\n    var isScrollingDown = delta >= 0;\n    // Track the current scroll position.\n    this._scrollPosition = scrollTop;\n    // Clear indexes for first and last visible indexes.\n    this._firstVisibleIndexVal = null;\n    this._lastVisibleIndexVal = null;\n    // Random access.\n    if (Math.abs(delta) > this._physicalSize && this._physicalSize > 0) {\n      delta = delta - this._scrollOffset;\n      var idxAdjustment = Math.round(delta / this._physicalAverage) * this._itemsPerRow;\n      this._virtualStart = this._virtualStart + idxAdjustment;\n      this._physicalStart = this._physicalStart + idxAdjustment;\n      // Estimate new physical offset.\n      this._physicalTop = Math.floor(this._virtualStart / this._itemsPerRow) * this._physicalAverage;\n      this._update();\n    } else if (this._physicalCount > 0) {\n      var reusables = this._getReusables(isScrollingDown);\n      if (isScrollingDown) {\n        this._physicalTop = reusables.physicalTop;\n        this._virtualStart = this._virtualStart + reusables.indexes.length;\n        this._physicalStart = this._physicalStart + reusables.indexes.length;\n      } else {\n        this._virtualStart = this._virtualStart - reusables.indexes.length;\n        this._physicalStart = this._physicalStart - reusables.indexes.length;\n      }\n      this._update(reusables.indexes, isScrollingDown ? null : reusables.indexes);\n      this._debounce('_increasePoolIfNeeded', this._increasePoolIfNeeded.bind(this, 0), MICRO_TASK);\n    }\n  },\n\n  /**\n   * Returns an object that contains the indexes of the physical items\n   * that might be reused and the physicalTop.\n   *\n   * @param {boolean} fromTop If the potential reusable items are above the scrolling region.\n   */\n  _getReusables: function(fromTop) {\n    var ith, offsetContent, physicalItemHeight;\n    var idxs = [];\n    var protectedOffsetContent = this._hiddenContentSize * this._ratio;\n    var virtualStart = this._virtualStart;\n    var virtualEnd = this._virtualEnd;\n    var physicalCount = this._physicalCount;\n    var top = this._physicalTop + this._scrollOffset;\n    var bottom = this._physicalBottom + this._scrollOffset;\n    var scrollTop = this._scrollTop;\n    var scrollBottom = this._scrollBottom;\n\n    if (fromTop) {\n      ith = this._physicalStart;\n      offsetContent = scrollTop - top;\n    } else {\n      ith = this._physicalEnd;\n      offsetContent = bottom - scrollBottom;\n    }\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      physicalItemHeight = this._getPhysicalSizeIncrement(ith);\n      offsetContent = offsetContent - physicalItemHeight;\n      if (idxs.length >= physicalCount || offsetContent <= protectedOffsetContent) {\n        break;\n      }\n      if (fromTop) {\n        // Check that index is within the valid range.\n        if (virtualEnd + idxs.length + 1 >= this._virtualCount) {\n          break;\n        }\n        // Check that the index is not visible.\n        if (top + physicalItemHeight >= scrollTop - this._scrollOffset) {\n          break;\n        }\n        idxs.push(ith);\n        top = top + physicalItemHeight;\n        ith = (ith + 1) % physicalCount;\n      } else {\n        // Check that index is within the valid range.\n        if (virtualStart - idxs.length <= 0) {\n          break;\n        }\n        // Check that the index is not visible.\n        if (top + this._physicalSize - physicalItemHeight <= scrollBottom) {\n          break;\n        }\n        idxs.push(ith);\n        top = top - physicalItemHeight;\n        ith = (ith === 0) ? physicalCount - 1 : ith - 1;\n      }\n    }\n    return {indexes: idxs, physicalTop: top - this._scrollOffset};\n  },\n\n  /**\n   * Update the list of items, starting from the `_virtualStart` item.\n   * @param {!Array<number>=} itemSet\n   * @param {!Array<number>=} movingUp\n   */\n  _update: function(itemSet, movingUp) {\n    if ((itemSet && itemSet.length === 0) || this._physicalCount === 0) {\n      return;\n    }\n    this._manageFocus();\n    this._assignModels(itemSet);\n    this._updateMetrics(itemSet);\n    // Adjust offset after measuring.\n    if (movingUp) {\n      while (movingUp.length) {\n        var idx = movingUp.pop();\n        this._physicalTop -= this._getPhysicalSizeIncrement(idx);\n      }\n    }\n    this._positionItems();\n    this._updateScrollerSize();\n  },\n\n  _isClientFull: function() {\n    return this._scrollBottom != 0 && this._physicalBottom - 1 >= this._scrollBottom &&\n        this._physicalTop <= this._scrollPosition;\n  },\n\n  /**\n   * Increases the pool size.\n   */\n  _increasePoolIfNeeded: function(count) {\n    var nextPhysicalCount = this._clamp(this._physicalCount + count,\n      DEFAULT_PHYSICAL_COUNT, this._virtualCount - this._virtualStart);\n    nextPhysicalCount = this._convertIndexToCompleteRow(nextPhysicalCount);\n    var delta = nextPhysicalCount - this._physicalCount;\n    var nextIncrease = Math.round(this._physicalCount * 0.5);\n\n    if (delta < 0) {\n      return;\n    }\n    if (delta > 0) {\n      var ts = window.performance.now();\n      // Concat arrays in place.\n      [].push.apply(this._physicalItems, this._createPool(delta));\n      // Push 0s into physicalSizes. Can't use Array.fill because IE11 doesn't support it.\n      for (var i = 0; i < delta; i++) {\n        this._physicalSizes.push(0);\n      }\n      this._physicalCount = this._physicalCount + delta;\n      // Update the physical start if it needs to preserve the model of the focused item.\n      // In this situation, the focused item is currently rendered and its model would\n      // have changed after increasing the pool if the physical start remained unchanged.\n      if (this._physicalStart > this._physicalEnd &&\n          this._isIndexRendered(this._focusedVirtualIndex) &&\n          this._getPhysicalIndex(this._focusedVirtualIndex) < this._physicalEnd) {\n        this._physicalStart = this._physicalStart + delta;\n      }\n      this._update();\n      this._templateCost = (window.performance.now() - ts) / delta;\n      nextIncrease = Math.round(this._physicalCount * 0.5);\n    }\n    // The upper bounds is not fixed when dealing with a grid that doesn't\n    // fill it's last row with the exact number of items per row.\n    if (this._virtualEnd >= this._virtualCount - 1 || nextIncrease === 0) {\n      // Do nothing.\n    } else if (!this._isClientFull()) {\n      this._debounce(\n        '_increasePoolIfNeeded',\n        this._increasePoolIfNeeded.bind(\n          this,\n          nextIncrease\n        ), MICRO_TASK);\n    } else if (this._physicalSize < this._optPhysicalSize) {\n      // Yield and increase the pool during idle time until the physical size is optimal.\n      this._debounce(\n        '_increasePoolIfNeeded',\n        this._increasePoolIfNeeded.bind(\n          this,\n          this._clamp(Math.round(50 / this._templateCost), 1, nextIncrease)\n        ), IDLE_TIME);\n    }\n  },\n\n  /**\n   * Renders the a new list.\n   */\n  _render: function() {\n    if (!this.isAttached || !this._isVisible) {\n      return;\n    }\n    if (this._physicalCount !== 0) {\n      var reusables = this._getReusables(true);\n      this._physicalTop = reusables.physicalTop;\n      this._virtualStart = this._virtualStart + reusables.indexes.length;\n      this._physicalStart = this._physicalStart + reusables.indexes.length;\n      this._update(reusables.indexes);\n      this._update();\n      this._increasePoolIfNeeded(0);\n    } else if (this._virtualCount > 0) {\n      // Initial render\n      this.updateViewportBoundaries();\n      this._increasePoolIfNeeded(DEFAULT_PHYSICAL_COUNT);\n    }\n  },\n\n  /**\n   * Called when the items have changed. That is, reassignments\n   * to `items`, splices or updates to a single item.\n   */\n  _itemsChanged: function(change) {\n    if (change.path === 'items') {\n      this._virtualStart = 0;\n      this._physicalTop = 0;\n      this._virtualCount = this.items ? this.items.length : 0;\n      this._collection = this.items && undefined ?\n        undefined.get(this.items) : null;\n      this._physicalIndexForKey = {};\n      this._firstVisibleIndexVal = null;\n      this._lastVisibleIndexVal = null;\n      this._physicalCount = this._physicalCount || 0;\n      this._physicalItems = this._physicalItems || [];\n      this._physicalSizes = this._physicalSizes || [];\n      this._physicalStart = 0;\n      if (this._scrollTop > this._scrollOffset) {\n        this._resetScrollPosition(0);\n      }\n      this._removeFocusedItem();\n      this._debounce('_render', this._render, ANIMATION_FRAME);\n    }\n  },\n\n  /**\n   * Executes a provided function per every physical index in `itemSet`\n   * `itemSet` default value is equivalent to the entire set of physical indexes.\n   *\n   * @param {!function(number, number)} fn\n   * @param {!Array<number>=} itemSet\n   */\n  _iterateItems: function(fn, itemSet) {\n    var pidx, vidx, rtn, i;\n\n    if (arguments.length === 2 && itemSet) {\n      for (i = 0; i < itemSet.length; i++) {\n        pidx = itemSet[i];\n        vidx = this._computeVidx(pidx);\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n    } else {\n      pidx = this._physicalStart;\n      vidx = this._virtualStart;\n      for (; pidx < this._physicalCount; pidx++, vidx++) {\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n      for (pidx = 0; pidx < this._physicalStart; pidx++, vidx++) {\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n    }\n  },\n\n  /**\n   * Returns the virtual index for a given physical index\n   *\n   * @param {number} pidx Physical index\n   * @return {number}\n   */\n  _computeVidx: function(pidx) {\n    if (pidx >= this._physicalStart) {\n      return this._virtualStart + (pidx - this._physicalStart);\n    }\n    return this._virtualStart + (this._physicalCount - this._physicalStart) + pidx;\n  },\n\n  /**\n   * Updates the height for a given set of items.\n   *\n   * @param {!Array<number>=} itemSet\n   */\n  _updateMetrics: function(itemSet) {\n    // Make sure we distributed all the physical items\n    // so we can measure them.\n    flush ? flush() : flush$0();\n\n    var newPhysicalSize = 0;\n    var oldPhysicalSize = 0;\n    var prevAvgCount = this._physicalAverageCount;\n    var prevPhysicalAvg = this._physicalAverage;\n\n    this._iterateItems(function(pidx, vidx) {\n      oldPhysicalSize += this._physicalSizes[pidx];\n      this._physicalSizes[pidx] = this._physicalItems[pidx].offsetHeight;\n      newPhysicalSize += this._physicalSizes[pidx];\n      this._physicalAverageCount += this._physicalSizes[pidx] ? 1 : 0;\n    }, itemSet);\n\n    if (this.grid) {\n      this._updateGridMetrics();\n      this._physicalSize = Math.ceil(this._physicalCount / this._itemsPerRow) * this._rowHeight;\n    } else {\n      oldPhysicalSize = (this._itemsPerRow === 1) ?\n        oldPhysicalSize :\n        Math.ceil(this._physicalCount / this._itemsPerRow) * this._rowHeight;\n      this._physicalSize = this._physicalSize + newPhysicalSize - oldPhysicalSize;\n      this._itemsPerRow = 1;\n    }\n    // Update the average if it measured something.\n    if (this._physicalAverageCount !== prevAvgCount) {\n      this._physicalAverage = Math.round(\n        ((prevPhysicalAvg * prevAvgCount) + newPhysicalSize) /\n        this._physicalAverageCount);\n    }\n  },\n\n  /**\n   * Updates the position of the physical items.\n   */\n  _positionItems: function() {\n    this._adjustScrollPosition();\n\n    var y = this._physicalTop;\n\n    this._iterateItems(function(pidx, vidx) {\n      this.translate3d(0, y + 'px', 0, this._physicalItems[pidx]);\n      y += this._physicalSizes[pidx];\n    });\n  },\n\n  _getPhysicalSizeIncrement: function(pidx) {\n    if (!this.grid) {\n      return this._physicalSizes[pidx];\n    }\n    if (this._computeVidx(pidx) % this._itemsPerRow !== this._itemsPerRow - 1) {\n      return 0;\n    }\n    return this._rowHeight;\n  },\n\n  /**\n   * Adjusts the scroll position when it was overestimated.\n   */\n  _adjustScrollPosition: function() {\n    var deltaHeight = this._virtualStart === 0 ? this._physicalTop : Math.min(this._scrollPosition + this._physicalTop, 0);\n    // Note: the delta can be positive or negative.\n    if (deltaHeight !== 0) {\n      this._physicalTop = this._physicalTop - deltaHeight;\n      var scrollTop = this._scrollTop;\n      // juking scroll position during interial scrolling on iOS is no bueno\n      if (!IOS_TOUCH_SCROLLING && scrollTop > 0) {\n        this._resetScrollPosition(scrollTop - deltaHeight);\n      }\n    }\n  },\n\n  /**\n   * Sets the position of the scroll.\n   */\n  _resetScrollPosition: function(pos) {\n    if (this.scrollTarget && pos >= 0) {\n      this._scrollTop = pos;\n      this._scrollPosition = this._scrollTop;\n    }\n  },\n\n  /**\n   * Sets the scroll height, that's the height of the content,\n   *\n   * @param {boolean=} forceUpdate If true, updates the height no matter what.\n   */\n  _updateScrollerSize: function(forceUpdate) {\n    if (this.grid) {\n      this._estScrollHeight = this._virtualRowCount * this._rowHeight;\n    } else {\n      this._estScrollHeight = (this._physicalBottom +\n          Math.max(this._virtualCount - this._physicalCount - this._virtualStart, 0) * this._physicalAverage);\n    }\n    forceUpdate = forceUpdate || this._scrollHeight === 0;\n    forceUpdate = forceUpdate || this._scrollPosition >= this._estScrollHeight - this._physicalSize;\n    forceUpdate = forceUpdate || this.grid && this.$.items.style.height < this._estScrollHeight;\n    // Amortize height adjustment, so it won't trigger large repaints too often.\n    if (forceUpdate || Math.abs(this._estScrollHeight - this._scrollHeight) >= this._viewportHeight) {\n      this.$.items.style.height = this._estScrollHeight + 'px';\n      this._scrollHeight = this._estScrollHeight;\n    }\n  },\n\n  /**\n   * Scroll to a specific index in the virtual list regardless\n   * of the physical items in the DOM tree.\n   *\n   * @method scrollToIndex\n   * @param {number} idx The index of the item\n   */\n  scrollToIndex: function(idx) {\n    if (typeof idx !== 'number' || idx < 0 || idx > this.items.length - 1) {\n      return;\n    }\n    flush ? flush() : flush$0();\n    // Items should have been rendered prior scrolling to an index.\n    if (this._physicalCount === 0) {\n      return;\n    }\n    idx = this._clamp(idx, 0, this._virtualCount - 1);\n    // Update the virtual start only when needed.\n    if (!this._isIndexRendered(idx) || idx >= this._maxVirtualStart) {\n      this._virtualStart = this.grid ? (idx - this._itemsPerRow * 2) : (idx - 1);\n    }\n    this._manageFocus();\n    this._assignModels();\n    this._updateMetrics();\n    // Estimate new physical offset.\n    this._physicalTop = Math.floor(this._virtualStart / this._itemsPerRow) * this._physicalAverage;\n\n    var currentTopItem = this._physicalStart;\n    var currentVirtualItem = this._virtualStart;\n    var targetOffsetTop = 0;\n    var hiddenContentSize = this._hiddenContentSize;\n    // scroll to the item as much as we can.\n    while (currentVirtualItem < idx && targetOffsetTop <= hiddenContentSize) {\n      targetOffsetTop = targetOffsetTop + this._getPhysicalSizeIncrement(currentTopItem);\n      currentTopItem = (currentTopItem + 1) % this._physicalCount;\n      currentVirtualItem++;\n    }\n    this._updateScrollerSize(true);\n    this._positionItems();\n    this._resetScrollPosition(this._physicalTop + this._scrollOffset + targetOffsetTop);\n    this._increasePoolIfNeeded(0);\n    // clear cached visible index.\n    this._firstVisibleIndexVal = null;\n    this._lastVisibleIndexVal = null;\n  },\n\n  /**\n   * Reset the physical average and the average count.\n   */\n  _resetAverage: function() {\n    this._physicalAverage = 0;\n    this._physicalAverageCount = 0;\n  },\n\n  /**\n   * A handler for the `iron-resize` event triggered by `IronResizableBehavior`\n   * when the element is resized.\n   */\n  _resizeHandler: function() {\n    this._debounce('_render', function() {\n      // clear cached visible index.\n      this._firstVisibleIndexVal = null;\n      this._lastVisibleIndexVal = null;\n      // Skip the resize event on touch devices when the address bar slides up.\n      this.updateViewportBoundaries();\n      if (this._isVisible) {\n        // Reinstall the scroll event listener.\n        this.toggleScrollListener(true);\n        this._resetAverage();\n        this._render();\n      } else {\n        // Uninstall the scroll event listener.\n        this.toggleScrollListener(false);\n      }\n    }, ANIMATION_FRAME);\n  },\n\n  /**\n   * Converts a random index to the index of the item that completes it's row.\n   * Allows for better order and fill computation when grid == true.\n   */\n  _convertIndexToCompleteRow: function(idx) {\n    // when grid == false _itemPerRow can be unset.\n    this._itemsPerRow = this._itemsPerRow || 1;\n    return this.grid ? Math.ceil(idx / this._itemsPerRow) * this._itemsPerRow : idx;\n  },\n\n  _isIndexRendered: function(idx) {\n    return idx >= this._virtualStart && idx <= this._virtualEnd;\n  },\n\n  _getPhysicalIndex: function(vidx) {\n    return (this._physicalStart + (vidx - this._virtualStart)) % this._physicalCount;\n  },\n\n  _clamp: function(v, min, max) {\n    return Math.min(max, Math.max(min, v));\n  },\n\n  _debounce: function(name, cb, asyncModule) {\n    this._debouncers = this._debouncers || {};\n    this._debouncers[name] = Debouncer.debounce(\n      this._debouncers[name],\n      asyncModule,\n      cb.bind(this));\n    enqueueDebouncer(this._debouncers[name]);\n  }\n\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}