{"ast":null,"code":"/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\nimport { nativeShadow, nativeCssVariables, cssBuild } from './style-settings.js';\nimport { parse, stringify, types, StyleNode } from './css-parse.js'; // eslint-disable-line no-unused-vars\nimport { MEDIA_MATCH } from './common-regex.js';\nimport { processUnscopedStyle, isUnscopedStyle } from './unscoped-style-handler.js';\n\n/**\n * @param {string|StyleNode} rules\n * @param {function(StyleNode)=} callback\n * @return {string}\n */\nexport function toCssText(rules, callback) {\n  if (!rules) {\n    return '';\n  }\n  if (typeof rules === 'string') {\n    rules = parse(rules);\n  }\n  if (callback) {\n    forEachRule(rules, callback);\n  }\n  return stringify(rules, nativeCssVariables);\n}\n\n/**\n * @param {HTMLStyleElement} style\n * @return {StyleNode}\n */\nexport function rulesForStyle(style) {\n  if (!style['__cssRules'] && style.textContent) {\n    style['__cssRules'] = parse(style.textContent);\n  }\n  return style['__cssRules'] || null;\n}\n\n// Tests if a rule is a keyframes selector, which looks almost exactly\n// like a normal selector but is not (it has nothing to do with scoping\n// for example).\n/**\n * @param {StyleNode} rule\n * @return {boolean}\n */\nexport function isKeyframesSelector(rule) {\n  return Boolean(rule['parent']) && rule['parent']['type'] === types.KEYFRAMES_RULE;\n}\n\n/**\n * @param {StyleNode} node\n * @param {Function=} styleRuleCallback\n * @param {Function=} keyframesRuleCallback\n * @param {boolean=} onlyActiveRules\n */\nexport function forEachRule(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {\n  if (!node) {\n    return;\n  }\n  let skipRules = false;\n  let type = node['type'];\n  if (onlyActiveRules) {\n    if (type === types.MEDIA_RULE) {\n      let matchMedia = node['selector'].match(MEDIA_MATCH);\n      if (matchMedia) {\n        // if rule is a non matching @media rule, skip subrules\n        if (!window.matchMedia(matchMedia[1]).matches) {\n          skipRules = true;\n        }\n      }\n    }\n  }\n  if (type === types.STYLE_RULE) {\n    styleRuleCallback(node);\n  } else if (keyframesRuleCallback && type === types.KEYFRAMES_RULE) {\n    keyframesRuleCallback(node);\n  } else if (type === types.MIXIN_RULE) {\n    skipRules = true;\n  }\n  let r$ = node['rules'];\n  if (r$ && !skipRules) {\n    for (let i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n      forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);\n    }\n  }\n}\n\n// add a string of cssText to the document.\n/**\n * @param {string} cssText\n * @param {string} moniker\n * @param {Node} target\n * @param {Node} contextNode\n * @return {HTMLStyleElement}\n */\nexport function applyCss(cssText, moniker, target, contextNode) {\n  let style = createScopeStyle(cssText, moniker);\n  applyStyle(style, target, contextNode);\n  return style;\n}\n\n/**\n * @param {string} cssText\n * @param {string} moniker\n * @return {HTMLStyleElement}\n */\nexport function createScopeStyle(cssText, moniker) {\n  let style = /** @type {HTMLStyleElement} */document.createElement('style');\n  if (moniker) {\n    style.setAttribute('scope', moniker);\n  }\n  style.textContent = cssText;\n  return style;\n}\n\n/**\n * Track the position of the last added style for placing placeholders\n * @type {Node}\n */\nlet lastHeadApplyNode = null;\n\n// insert a comment node as a styling position placeholder.\n/**\n * @param {string} moniker\n * @return {!Comment}\n */\nexport function applyStylePlaceHolder(moniker) {\n  let placeHolder = document.createComment(' Shady DOM styles for ' + moniker + ' ');\n  let after = lastHeadApplyNode ? lastHeadApplyNode['nextSibling'] : null;\n  let scope = document.head;\n  scope.insertBefore(placeHolder, after || scope.firstChild);\n  lastHeadApplyNode = placeHolder;\n  return placeHolder;\n}\n\n/**\n * @param {HTMLStyleElement} style\n * @param {?Node} target\n * @param {?Node} contextNode\n */\nexport function applyStyle(style, target, contextNode) {\n  target = target || document.head;\n  let after = contextNode && contextNode.nextSibling || target.firstChild;\n  target.insertBefore(style, after);\n  if (!lastHeadApplyNode) {\n    lastHeadApplyNode = style;\n  } else {\n    // only update lastHeadApplyNode if the new style is inserted after the old lastHeadApplyNode\n    let position = style.compareDocumentPosition(lastHeadApplyNode);\n    if (position === Node.DOCUMENT_POSITION_PRECEDING) {\n      lastHeadApplyNode = style;\n    }\n  }\n}\n\n/**\n * @param {string} buildType\n * @return {boolean}\n */\nexport function isTargetedBuild(buildType) {\n  return nativeShadow ? buildType === 'shadow' : buildType === 'shady';\n}\n\n/**\n * Walk from text[start] matching parens and\n * returns position of the outer end paren\n * @param {string} text\n * @param {number} start\n * @return {number}\n */\nexport function findMatchingParen(text, start) {\n  let level = 0;\n  for (let i = start, l = text.length; i < l; i++) {\n    if (text[i] === '(') {\n      level++;\n    } else if (text[i] === ')') {\n      if (--level === 0) {\n        return i;\n      }\n    }\n  }\n  return -1;\n}\n\n/**\n * @param {string} str\n * @param {function(string, string, string, string)} callback\n */\nexport function processVariableAndFallback(str, callback) {\n  // find 'var('\n  let start = str.indexOf('var(');\n  if (start === -1) {\n    // no var?, everything is prefix\n    return callback(str, '', '', '');\n  }\n  //${prefix}var(${inner})${suffix}\n  let end = findMatchingParen(str, start + 3);\n  let inner = str.substring(start + 4, end);\n  let prefix = str.substring(0, start);\n  // suffix may have other variables\n  let suffix = processVariableAndFallback(str.substring(end + 1), callback);\n  let comma = inner.indexOf(',');\n  // value and fallback args should be trimmed to match in property lookup\n  if (comma === -1) {\n    // variable, no fallback\n    return callback(prefix, inner.trim(), '', suffix);\n  }\n  // var(${value},${fallback})\n  let value = inner.substring(0, comma).trim();\n  let fallback = inner.substring(comma + 1).trim();\n  return callback(prefix, value, fallback, suffix);\n}\n\n/**\n * @param {Element} element\n * @param {string} value\n */\nexport function setElementClassRaw(element, value) {\n  // use native setAttribute provided by ShadyDOM when setAttribute is patched\n  if (nativeShadow) {\n    element.setAttribute('class', value);\n  } else {\n    window['ShadyDOM']['nativeMethods']['setAttribute'].call(element, 'class', value);\n  }\n}\n\n/**\n * @type {function(*):*}\n */\nexport const wrap = window['ShadyDOM'] && window['ShadyDOM']['wrap'] || (node => node);\n\n/**\n * @param {Element | {is: string, extends: string}} element\n * @return {{is: string, typeExtension: string}}\n */\nexport function getIsExtends(element) {\n  let localName = element['localName'];\n  let is = '',\n    typeExtension = '';\n  /*\n  NOTE: technically, this can be wrong for certain svg elements\n  with `-` in the name like `<font-face>`\n  */\n  if (localName) {\n    if (localName.indexOf('-') > -1) {\n      is = localName;\n    } else {\n      typeExtension = localName;\n      is = element.getAttribute && element.getAttribute('is') || '';\n    }\n  } else {\n    is = /** @type {?} */element.is;\n    typeExtension = /** @type {?} */element.extends;\n  }\n  return {\n    is,\n    typeExtension\n  };\n}\n\n/**\n * @param {Element|DocumentFragment} element\n * @return {string}\n */\nexport function gatherStyleText(element) {\n  /** @type {!Array<string>} */\n  const styleTextParts = [];\n  const styles = /** @type {!NodeList<!HTMLStyleElement>} */element.querySelectorAll('style');\n  for (let i = 0; i < styles.length; i++) {\n    const style = styles[i];\n    if (isUnscopedStyle(style)) {\n      if (!nativeShadow) {\n        processUnscopedStyle(style);\n        style.parentNode.removeChild(style);\n      }\n    } else {\n      styleTextParts.push(style.textContent);\n      style.parentNode.removeChild(style);\n    }\n  }\n  return styleTextParts.join('').trim();\n}\n\n/**\n * Split a selector separated by commas into an array in a smart way\n * @param {string} selector\n * @return {!Array<string>}\n */\nexport function splitSelectorList(selector) {\n  const parts = [];\n  let part = '';\n  for (let i = 0; i >= 0 && i < selector.length; i++) {\n    // A selector with parentheses will be one complete part\n    if (selector[i] === '(') {\n      // find the matching paren\n      const end = findMatchingParen(selector, i);\n      // push the paren block into the part\n      part += selector.slice(i, end + 1);\n      // move the index to after the paren block\n      i = end;\n    } else if (selector[i] === ',') {\n      parts.push(part);\n      part = '';\n    } else {\n      part += selector[i];\n    }\n  }\n  // catch any pieces after the last comma\n  if (part) {\n    parts.push(part);\n  }\n  return parts;\n}\nconst CSS_BUILD_ATTR = 'css-build';\n\n/**\n * Return the polymer-css-build \"build type\" applied to this element\n *\n * @param {!HTMLElement} element\n * @return {string} Can be \"\", \"shady\", or \"shadow\"\n */\nexport function getCssBuild(element) {\n  if (cssBuild !== undefined) {\n    return /** @type {string} */cssBuild;\n  }\n  if (element.__cssBuild === undefined) {\n    // try attribute first, as it is the common case\n    const attrValue = element.getAttribute(CSS_BUILD_ATTR);\n    if (attrValue) {\n      element.__cssBuild = attrValue;\n    } else {\n      const buildComment = getBuildComment(element);\n      if (buildComment !== '') {\n        // remove build comment so it is not needlessly copied into every element instance\n        removeBuildComment(element);\n      }\n      element.__cssBuild = buildComment;\n    }\n  }\n  return element.__cssBuild || '';\n}\n\n/**\n * Check if the given element, either a <template> or <style>, has been processed\n * by polymer-css-build.\n *\n * If so, then we can make a number of optimizations:\n * - polymer-css-build will decompose mixins into individual CSS Custom Properties,\n * so the ApplyShim can be skipped entirely.\n * - Under native ShadowDOM, the style text can just be copied into each instance\n * without modification\n * - If the build is \"shady\" and ShadyDOM is in use, the styling does not need\n * scoping beyond the shimming of CSS Custom Properties\n *\n * @param {!HTMLElement} element\n * @return {boolean}\n */\nexport function elementHasBuiltCss(element) {\n  return getCssBuild(element) !== '';\n}\n\n/**\n * For templates made with tagged template literals, polymer-css-build will\n * insert a comment of the form `<!--css-build:shadow-->`\n *\n * @param {!HTMLElement} element\n * @return {string}\n */\nexport function getBuildComment(element) {\n  const buildComment = element.localName === 'template' ? /** @type {!HTMLTemplateElement} */element.content.firstChild : element.firstChild;\n  if (buildComment instanceof Comment) {\n    const commentParts = buildComment.textContent.trim().split(':');\n    if (commentParts[0] === CSS_BUILD_ATTR) {\n      return commentParts[1];\n    }\n  }\n  return '';\n}\n\n/**\n * Check if the css build status is optimal, and do no unneeded work.\n *\n * @param {string=} cssBuild CSS build status\n * @return {boolean} css build is optimal or not\n */\nexport function isOptimalCssBuild(cssBuild = '') {\n  // CSS custom property shim always requires work\n  if (cssBuild === '' || !nativeCssVariables) {\n    return false;\n  }\n  return nativeShadow ? cssBuild === 'shadow' : cssBuild === 'shady';\n}\n\n/**\n * @param {!HTMLElement} element\n */\nfunction removeBuildComment(element) {\n  const buildComment = element.localName === 'template' ? /** @type {!HTMLTemplateElement} */element.content.firstChild : element.firstChild;\n  buildComment.parentNode.removeChild(buildComment);\n}","map":{"version":3,"names":["nativeShadow","nativeCssVariables","cssBuild","parse","stringify","types","StyleNode","MEDIA_MATCH","processUnscopedStyle","isUnscopedStyle","toCssText","rules","callback","forEachRule","rulesForStyle","style","textContent","isKeyframesSelector","rule","Boolean","KEYFRAMES_RULE","node","styleRuleCallback","keyframesRuleCallback","onlyActiveRules","skipRules","type","MEDIA_RULE","matchMedia","match","window","matches","STYLE_RULE","MIXIN_RULE","r$","i","l","length","r","applyCss","cssText","moniker","target","contextNode","createScopeStyle","applyStyle","document","createElement","setAttribute","lastHeadApplyNode","applyStylePlaceHolder","placeHolder","createComment","after","scope","head","insertBefore","firstChild","nextSibling","position","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","isTargetedBuild","buildType","findMatchingParen","text","start","level","processVariableAndFallback","str","indexOf","end","inner","substring","prefix","suffix","comma","trim","value","fallback","setElementClassRaw","element","call","wrap","getIsExtends","localName","is","typeExtension","getAttribute","extends","gatherStyleText","styleTextParts","styles","querySelectorAll","parentNode","removeChild","push","join","splitSelectorList","selector","parts","part","slice","CSS_BUILD_ATTR","getCssBuild","undefined","__cssBuild","attrValue","buildComment","getBuildComment","removeBuildComment","elementHasBuiltCss","content","Comment","commentParts","split","isOptimalCssBuild"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@webcomponents/shadycss/src/style-util.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\nimport {nativeShadow, nativeCssVariables, cssBuild} from './style-settings.js';\nimport {parse, stringify, types, StyleNode} from './css-parse.js'; // eslint-disable-line no-unused-vars\nimport {MEDIA_MATCH} from './common-regex.js';\nimport {processUnscopedStyle, isUnscopedStyle} from './unscoped-style-handler.js';\n\n/**\n * @param {string|StyleNode} rules\n * @param {function(StyleNode)=} callback\n * @return {string}\n */\nexport function toCssText (rules, callback) {\n  if (!rules) {\n    return '';\n  }\n  if (typeof rules === 'string') {\n    rules = parse(rules);\n  }\n  if (callback) {\n    forEachRule(rules, callback);\n  }\n  return stringify(rules, nativeCssVariables);\n}\n\n/**\n * @param {HTMLStyleElement} style\n * @return {StyleNode}\n */\nexport function rulesForStyle(style) {\n  if (!style['__cssRules'] && style.textContent) {\n    style['__cssRules'] = parse(style.textContent);\n  }\n  return style['__cssRules'] || null;\n}\n\n// Tests if a rule is a keyframes selector, which looks almost exactly\n// like a normal selector but is not (it has nothing to do with scoping\n// for example).\n/**\n * @param {StyleNode} rule\n * @return {boolean}\n */\nexport function isKeyframesSelector(rule) {\n  return Boolean(rule['parent']) &&\n  rule['parent']['type'] === types.KEYFRAMES_RULE;\n}\n\n/**\n * @param {StyleNode} node\n * @param {Function=} styleRuleCallback\n * @param {Function=} keyframesRuleCallback\n * @param {boolean=} onlyActiveRules\n */\nexport function forEachRule(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {\n  if (!node) {\n    return;\n  }\n  let skipRules = false;\n  let type = node['type'];\n  if (onlyActiveRules) {\n    if (type === types.MEDIA_RULE) {\n      let matchMedia = node['selector'].match(MEDIA_MATCH);\n      if (matchMedia) {\n        // if rule is a non matching @media rule, skip subrules\n        if (!window.matchMedia(matchMedia[1]).matches) {\n          skipRules = true;\n        }\n      }\n    }\n  }\n  if (type === types.STYLE_RULE) {\n    styleRuleCallback(node);\n  } else if (keyframesRuleCallback &&\n    type === types.KEYFRAMES_RULE) {\n    keyframesRuleCallback(node);\n  } else if (type === types.MIXIN_RULE) {\n    skipRules = true;\n  }\n  let r$ = node['rules'];\n  if (r$ && !skipRules) {\n    for (let i=0, l=r$.length, r; (i<l) && (r=r$[i]); i++) {\n      forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);\n    }\n  }\n}\n\n// add a string of cssText to the document.\n/**\n * @param {string} cssText\n * @param {string} moniker\n * @param {Node} target\n * @param {Node} contextNode\n * @return {HTMLStyleElement}\n */\nexport function applyCss(cssText, moniker, target, contextNode) {\n  let style = createScopeStyle(cssText, moniker);\n  applyStyle(style, target, contextNode);\n  return style;\n}\n\n/**\n * @param {string} cssText\n * @param {string} moniker\n * @return {HTMLStyleElement}\n */\nexport function createScopeStyle(cssText, moniker) {\n  let style = /** @type {HTMLStyleElement} */(document.createElement('style'));\n  if (moniker) {\n    style.setAttribute('scope', moniker);\n  }\n  style.textContent = cssText;\n  return style;\n}\n\n/**\n * Track the position of the last added style for placing placeholders\n * @type {Node}\n */\nlet lastHeadApplyNode = null;\n\n// insert a comment node as a styling position placeholder.\n/**\n * @param {string} moniker\n * @return {!Comment}\n */\nexport function applyStylePlaceHolder(moniker) {\n  let placeHolder = document.createComment(' Shady DOM styles for ' +\n    moniker + ' ');\n  let after = lastHeadApplyNode ?\n    lastHeadApplyNode['nextSibling'] : null;\n  let scope = document.head;\n  scope.insertBefore(placeHolder, after || scope.firstChild);\n  lastHeadApplyNode = placeHolder;\n  return placeHolder;\n}\n\n/**\n * @param {HTMLStyleElement} style\n * @param {?Node} target\n * @param {?Node} contextNode\n */\nexport function applyStyle(style, target, contextNode) {\n  target = target || document.head;\n  let after = (contextNode && contextNode.nextSibling) ||\n    target.firstChild;\n  target.insertBefore(style, after);\n  if (!lastHeadApplyNode) {\n    lastHeadApplyNode = style;\n  } else {\n    // only update lastHeadApplyNode if the new style is inserted after the old lastHeadApplyNode\n    let position = style.compareDocumentPosition(lastHeadApplyNode);\n    if (position === Node.DOCUMENT_POSITION_PRECEDING) {\n      lastHeadApplyNode = style;\n    }\n  }\n}\n\n/**\n * @param {string} buildType\n * @return {boolean}\n */\nexport function isTargetedBuild(buildType) {\n  return nativeShadow ? buildType === 'shadow' : buildType === 'shady';\n}\n\n/**\n * Walk from text[start] matching parens and\n * returns position of the outer end paren\n * @param {string} text\n * @param {number} start\n * @return {number}\n */\nexport function findMatchingParen(text, start) {\n  let level = 0;\n  for (let i=start, l=text.length; i < l; i++) {\n    if (text[i] === '(') {\n      level++;\n    } else if (text[i] === ')') {\n      if (--level === 0) {\n        return i;\n      }\n    }\n  }\n  return -1;\n}\n\n/**\n * @param {string} str\n * @param {function(string, string, string, string)} callback\n */\nexport function processVariableAndFallback(str, callback) {\n  // find 'var('\n  let start = str.indexOf('var(');\n  if (start === -1) {\n    // no var?, everything is prefix\n    return callback(str, '', '', '');\n  }\n  //${prefix}var(${inner})${suffix}\n  let end = findMatchingParen(str, start + 3);\n  let inner = str.substring(start + 4, end);\n  let prefix = str.substring(0, start);\n  // suffix may have other variables\n  let suffix = processVariableAndFallback(str.substring(end + 1), callback);\n  let comma = inner.indexOf(',');\n  // value and fallback args should be trimmed to match in property lookup\n  if (comma === -1) {\n    // variable, no fallback\n    return callback(prefix, inner.trim(), '', suffix);\n  }\n  // var(${value},${fallback})\n  let value = inner.substring(0, comma).trim();\n  let fallback = inner.substring(comma + 1).trim();\n  return callback(prefix, value, fallback, suffix);\n}\n\n/**\n * @param {Element} element\n * @param {string} value\n */\nexport function setElementClassRaw(element, value) {\n  // use native setAttribute provided by ShadyDOM when setAttribute is patched\n  if (nativeShadow) {\n    element.setAttribute('class', value);\n  } else {\n    window['ShadyDOM']['nativeMethods']['setAttribute'].call(element, 'class', value);\n  }\n}\n\n/**\n * @type {function(*):*}\n */\nexport const wrap = window['ShadyDOM'] && window['ShadyDOM']['wrap'] || ((node) => node);\n\n/**\n * @param {Element | {is: string, extends: string}} element\n * @return {{is: string, typeExtension: string}}\n */\nexport function getIsExtends(element) {\n  let localName = element['localName'];\n  let is = '', typeExtension = '';\n  /*\n  NOTE: technically, this can be wrong for certain svg elements\n  with `-` in the name like `<font-face>`\n  */\n  if (localName) {\n    if (localName.indexOf('-') > -1) {\n      is = localName;\n    } else {\n      typeExtension = localName;\n      is = (element.getAttribute && element.getAttribute('is')) || '';\n    }\n  } else {\n    is = /** @type {?} */(element).is;\n    typeExtension = /** @type {?} */(element).extends;\n  }\n  return {is, typeExtension};\n}\n\n/**\n * @param {Element|DocumentFragment} element\n * @return {string}\n */\nexport function gatherStyleText(element) {\n  /** @type {!Array<string>} */\n  const styleTextParts = [];\n  const styles = /** @type {!NodeList<!HTMLStyleElement>} */(element.querySelectorAll('style'));\n  for (let i = 0; i < styles.length; i++) {\n    const style = styles[i];\n    if (isUnscopedStyle(style)) {\n      if (!nativeShadow) {\n        processUnscopedStyle(style);\n        style.parentNode.removeChild(style);\n      }\n    } else {\n      styleTextParts.push(style.textContent);\n      style.parentNode.removeChild(style);\n    }\n  }\n  return styleTextParts.join('').trim();\n}\n\n/**\n * Split a selector separated by commas into an array in a smart way\n * @param {string} selector\n * @return {!Array<string>}\n */\nexport function splitSelectorList(selector) {\n  const parts = [];\n  let part = '';\n  for (let i = 0; i >= 0 && i < selector.length; i++) {\n    // A selector with parentheses will be one complete part\n    if (selector[i] === '(') {\n      // find the matching paren\n      const end = findMatchingParen(selector, i);\n      // push the paren block into the part\n      part += selector.slice(i, end + 1);\n      // move the index to after the paren block\n      i = end;\n    } else if (selector[i] === ',') {\n      parts.push(part);\n      part = '';\n    } else {\n      part += selector[i];\n    }\n  }\n  // catch any pieces after the last comma\n  if (part) {\n    parts.push(part);\n  }\n  return parts;\n}\n\nconst CSS_BUILD_ATTR = 'css-build';\n\n/**\n * Return the polymer-css-build \"build type\" applied to this element\n *\n * @param {!HTMLElement} element\n * @return {string} Can be \"\", \"shady\", or \"shadow\"\n */\nexport function getCssBuild(element) {\n  if (cssBuild !== undefined) {\n    return /** @type {string} */(cssBuild);\n  }\n  if (element.__cssBuild === undefined) {\n    // try attribute first, as it is the common case\n    const attrValue = element.getAttribute(CSS_BUILD_ATTR);\n    if (attrValue) {\n      element.__cssBuild = attrValue;\n    } else {\n      const buildComment = getBuildComment(element);\n      if (buildComment !== '') {\n        // remove build comment so it is not needlessly copied into every element instance\n        removeBuildComment(element);\n      }\n      element.__cssBuild = buildComment;\n    }\n  }\n  return element.__cssBuild || '';\n}\n\n/**\n * Check if the given element, either a <template> or <style>, has been processed\n * by polymer-css-build.\n *\n * If so, then we can make a number of optimizations:\n * - polymer-css-build will decompose mixins into individual CSS Custom Properties,\n * so the ApplyShim can be skipped entirely.\n * - Under native ShadowDOM, the style text can just be copied into each instance\n * without modification\n * - If the build is \"shady\" and ShadyDOM is in use, the styling does not need\n * scoping beyond the shimming of CSS Custom Properties\n *\n * @param {!HTMLElement} element\n * @return {boolean}\n */\nexport function elementHasBuiltCss(element) {\n  return getCssBuild(element) !== '';\n}\n\n/**\n * For templates made with tagged template literals, polymer-css-build will\n * insert a comment of the form `<!--css-build:shadow-->`\n *\n * @param {!HTMLElement} element\n * @return {string}\n */\nexport function getBuildComment(element) {\n  const buildComment = element.localName === 'template' ?\n      /** @type {!HTMLTemplateElement} */ (element).content.firstChild :\n      element.firstChild;\n  if (buildComment instanceof Comment) {\n    const commentParts = buildComment.textContent.trim().split(':');\n    if (commentParts[0] === CSS_BUILD_ATTR) {\n      return commentParts[1];\n    }\n  }\n  return '';\n}\n\n/**\n * Check if the css build status is optimal, and do no unneeded work.\n *\n * @param {string=} cssBuild CSS build status\n * @return {boolean} css build is optimal or not\n */\nexport function isOptimalCssBuild(cssBuild = '') {\n  // CSS custom property shim always requires work\n  if (cssBuild === '' || !nativeCssVariables) {\n    return false;\n  }\n  return nativeShadow ? cssBuild === 'shadow' : cssBuild === 'shady';\n}\n\n/**\n * @param {!HTMLElement} element\n */\nfunction removeBuildComment(element) {\n  const buildComment = element.localName === 'template' ?\n      /** @type {!HTMLTemplateElement} */ (element).content.firstChild :\n      element.firstChild;\n  buildComment.parentNode.removeChild(buildComment);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}