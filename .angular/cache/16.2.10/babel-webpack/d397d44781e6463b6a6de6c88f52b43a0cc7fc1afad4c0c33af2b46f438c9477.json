{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2021 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n/* eslint-disable @typescript-eslint/member-ordering */\n// https://github.com/vaadin/eslint-config-vaadin/issues/33\nimport { animationFrame, timeOut } from './async.js';\nimport { isSafari } from './browser-utils.js';\nimport { Debouncer, flush } from './debounce.js';\nimport { ironList } from './iron-list-core.js';\n\n// Iron-list can by default handle sizes up to around 100000.\n// When the size is larger than MAX_VIRTUAL_COUNT _vidxOffset is used\nconst MAX_VIRTUAL_COUNT = 100000;\nconst OFFSET_ADJUST_MIN_THRESHOLD = 1000;\nexport class IronListAdapter {\n  constructor({\n    createElements,\n    updateElement,\n    scrollTarget,\n    scrollContainer,\n    elementsContainer,\n    reorderElements\n  }) {\n    this.isAttached = true;\n    this._vidxOffset = 0;\n    this.createElements = createElements;\n    this.updateElement = updateElement;\n    this.scrollTarget = scrollTarget;\n    this.scrollContainer = scrollContainer;\n    this.elementsContainer = elementsContainer || scrollContainer;\n    this.reorderElements = reorderElements;\n    // Iron-list uses this value to determine how many pages of elements to render\n    this._maxPages = 1.3;\n\n    // Placeholder height (used for sizing elements that have intrinsic 0 height after update)\n    this.__placeholderHeight = 200;\n    // A queue of 10 previous element heights\n    this.__elementHeightQueue = Array(10);\n    this.timeouts = {\n      SCROLL_REORDER: 500,\n      IGNORE_WHEEL: 500,\n      FIX_INVALID_ITEM_POSITIONING: 100\n    };\n    this.__resizeObserver = new ResizeObserver(() => this._resizeHandler());\n    if (getComputedStyle(this.scrollTarget).overflow === 'visible') {\n      this.scrollTarget.style.overflow = 'auto';\n    }\n    if (getComputedStyle(this.scrollContainer).position === 'static') {\n      this.scrollContainer.style.position = 'relative';\n    }\n    this.__resizeObserver.observe(this.scrollTarget);\n    this.scrollTarget.addEventListener('scroll', () => this._scrollHandler());\n    this._scrollLineHeight = this._getScrollLineHeight();\n    this.scrollTarget.addEventListener('wheel', e => this.__onWheel(e));\n    if (this.reorderElements) {\n      // Reordering the physical elements cancels the user's grab of the scroll bar handle on Safari.\n      // Need to defer reordering until the user lets go of the scroll bar handle.\n      this.scrollTarget.addEventListener('mousedown', () => {\n        this.__mouseDown = true;\n      });\n      this.scrollTarget.addEventListener('mouseup', () => {\n        this.__mouseDown = false;\n        if (this.__pendingReorder) {\n          this.__reorderElements();\n        }\n      });\n    }\n  }\n  get scrollOffset() {\n    return 0;\n  }\n  get adjustedFirstVisibleIndex() {\n    return this.firstVisibleIndex + this._vidxOffset;\n  }\n  get adjustedLastVisibleIndex() {\n    return this.lastVisibleIndex + this._vidxOffset;\n  }\n  scrollToIndex(index) {\n    if (typeof index !== 'number' || isNaN(index) || this.size === 0 || !this.scrollTarget.offsetHeight) {\n      return;\n    }\n    index = this._clamp(index, 0, this.size - 1);\n    const visibleElementCount = this.__getVisibleElements().length;\n    let targetVirtualIndex = Math.floor(index / this.size * this._virtualCount);\n    if (this._virtualCount - targetVirtualIndex < visibleElementCount) {\n      targetVirtualIndex = this._virtualCount - (this.size - index);\n      this._vidxOffset = this.size - this._virtualCount;\n    } else if (targetVirtualIndex < visibleElementCount) {\n      if (index < OFFSET_ADJUST_MIN_THRESHOLD) {\n        targetVirtualIndex = index;\n        this._vidxOffset = 0;\n      } else {\n        targetVirtualIndex = OFFSET_ADJUST_MIN_THRESHOLD;\n        this._vidxOffset = index - targetVirtualIndex;\n      }\n    } else {\n      this._vidxOffset = index - targetVirtualIndex;\n    }\n    this.__skipNextVirtualIndexAdjust = true;\n    super.scrollToIndex(targetVirtualIndex);\n    if (this.adjustedFirstVisibleIndex !== index && this._scrollTop < this._maxScrollTop && !this.grid) {\n      // Workaround an iron-list issue by manually adjusting the scroll position\n      this._scrollTop -= this.__getIndexScrollOffset(index) || 0;\n    }\n    this._scrollHandler();\n  }\n  flush() {\n    // The scroll target is hidden.\n    if (this.scrollTarget.offsetHeight === 0) {\n      return;\n    }\n    this._resizeHandler();\n    flush();\n    this._scrollHandler();\n    if (this.__fixInvalidItemPositioningDebouncer) {\n      this.__fixInvalidItemPositioningDebouncer.flush();\n    }\n    if (this.__scrollReorderDebouncer) {\n      this.__scrollReorderDebouncer.flush();\n    }\n    if (this.__debouncerWheelAnimationFrame) {\n      this.__debouncerWheelAnimationFrame.flush();\n    }\n  }\n  update(startIndex = 0, endIndex = this.size - 1) {\n    const updatedElements = [];\n    this.__getVisibleElements().forEach(el => {\n      if (el.__virtualIndex >= startIndex && el.__virtualIndex <= endIndex) {\n        this.__updateElement(el, el.__virtualIndex, true);\n        updatedElements.push(el);\n      }\n    });\n    this.__afterElementsUpdated(updatedElements);\n  }\n\n  /**\n   * Updates the height for a given set of items.\n   *\n   * @param {!Array<number>=} itemSet\n   */\n  _updateMetrics(itemSet) {\n    // Make sure we distributed all the physical items\n    // so we can measure them.\n    flush();\n    let newPhysicalSize = 0;\n    let oldPhysicalSize = 0;\n    const prevAvgCount = this._physicalAverageCount;\n    const prevPhysicalAvg = this._physicalAverage;\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._iterateItems((pidx, vidx) => {\n      oldPhysicalSize += this._physicalSizes[pidx];\n      this._physicalSizes[pidx] = Math.ceil(this.__getBorderBoxHeight(this._physicalItems[pidx]));\n      newPhysicalSize += this._physicalSizes[pidx];\n      this._physicalAverageCount += this._physicalSizes[pidx] ? 1 : 0;\n    }, itemSet);\n    this._physicalSize = this._physicalSize + newPhysicalSize - oldPhysicalSize;\n\n    // Update the average if it measured something.\n    if (this._physicalAverageCount !== prevAvgCount) {\n      this._physicalAverage = Math.round((prevPhysicalAvg * prevAvgCount + newPhysicalSize) / this._physicalAverageCount);\n    }\n  }\n  __getBorderBoxHeight(el) {\n    const style = getComputedStyle(el);\n    const itemHeight = parseFloat(style.height) || 0;\n    if (style.boxSizing === 'border-box') {\n      return itemHeight;\n    }\n    const paddingBottom = parseFloat(style.paddingBottom) || 0;\n    const paddingTop = parseFloat(style.paddingTop) || 0;\n    const borderBottomWidth = parseFloat(style.borderBottomWidth) || 0;\n    const borderTopWidth = parseFloat(style.borderTopWidth) || 0;\n    return itemHeight + paddingBottom + paddingTop + borderBottomWidth + borderTopWidth;\n  }\n  __updateElement(el, index, forceSameIndexUpdates) {\n    // Clean up temporary placeholder sizing\n    if (el.style.paddingTop) {\n      el.style.paddingTop = '';\n    }\n    if (!this.__preventElementUpdates && (el.__lastUpdatedIndex !== index || forceSameIndexUpdates)) {\n      this.updateElement(el, index);\n      el.__lastUpdatedIndex = index;\n    }\n  }\n\n  /**\n   * Called synchronously right after elements have been updated.\n   * This is a good place to do any post-update work.\n   *\n   * @param {!Array<!HTMLElement>} updatedElements\n   */\n  __afterElementsUpdated(updatedElements) {\n    updatedElements.forEach(el => {\n      const elementHeight = el.offsetHeight;\n      if (elementHeight === 0) {\n        // If the elements have 0 height after update (for example due to lazy rendering),\n        // it results in iron-list requesting to create an unlimited count of elements.\n        // Assign a temporary placeholder sizing to elements that would otherwise end up having\n        // no height.\n        el.style.paddingTop = `${this.__placeholderHeight}px`;\n\n        // Manually schedule the resize handler to make sure the placeholder padding is\n        // cleared in case the resize observer never triggers.\n        this.__placeholderClearDebouncer = Debouncer.debounce(this.__placeholderClearDebouncer, animationFrame, () => this._resizeHandler());\n      } else {\n        // Add element height to the queue\n        this.__elementHeightQueue.push(elementHeight);\n        this.__elementHeightQueue.shift();\n\n        // Calculate new placeholder height based on the average of the defined values in the\n        // element height queue\n        const filteredHeights = this.__elementHeightQueue.filter(h => h !== undefined);\n        this.__placeholderHeight = Math.round(filteredHeights.reduce((a, b) => a + b, 0) / filteredHeights.length);\n      }\n    });\n  }\n  __getIndexScrollOffset(index) {\n    const element = this.__getVisibleElements().find(el => el.__virtualIndex === index);\n    return element ? this.scrollTarget.getBoundingClientRect().top - element.getBoundingClientRect().top : undefined;\n  }\n  get size() {\n    return this.__size;\n  }\n  set size(size) {\n    if (size === this.size) {\n      return;\n    }\n    // Cancel active debouncers\n    if (this.__fixInvalidItemPositioningDebouncer) {\n      this.__fixInvalidItemPositioningDebouncer.cancel();\n    }\n    if (this._debouncers && this._debouncers._increasePoolIfNeeded) {\n      // Avoid creating unnecessary elements on the following flush()\n      this._debouncers._increasePoolIfNeeded.cancel();\n    }\n\n    // Change the size\n    this.__size = size;\n    if (!this._physicalItems) {\n      // Not initialized yet\n      this._itemsChanged({\n        path: 'items'\n      });\n      this.__preventElementUpdates = true;\n      flush();\n      this.__preventElementUpdates = false;\n    } else {\n      // Already initialized, just update _virtualCount\n      this._virtualCount = this.items.length;\n    }\n\n    // When reducing size while invisible, iron-list does not update items, so\n    // their hidden state is not updated and their __lastUpdatedIndex is not\n    // reset. In that case force an update here.\n    if (!this._isVisible) {\n      this._assignModels();\n    }\n    if (!this.elementsContainer.children.length) {\n      requestAnimationFrame(() => this._resizeHandler());\n    }\n\n    // Schedule and flush a resize handler. This will cause a\n    // re-render for the elements.\n    this._resizeHandler();\n    flush();\n  }\n\n  /** @private */\n  get _scrollTop() {\n    return this.scrollTarget.scrollTop;\n  }\n\n  /** @private */\n  set _scrollTop(top) {\n    this.scrollTarget.scrollTop = top;\n  }\n\n  /** @private */\n  get items() {\n    return {\n      length: Math.min(this.size, MAX_VIRTUAL_COUNT)\n    };\n  }\n\n  /** @private */\n  get offsetHeight() {\n    return this.scrollTarget.offsetHeight;\n  }\n\n  /** @private */\n  get $() {\n    return {\n      items: this.scrollContainer\n    };\n  }\n\n  /** @private */\n  updateViewportBoundaries() {\n    const styles = window.getComputedStyle(this.scrollTarget);\n    this._scrollerPaddingTop = this.scrollTarget === this ? 0 : parseInt(styles['padding-top'], 10);\n    this._isRTL = Boolean(styles.direction === 'rtl');\n    this._viewportWidth = this.elementsContainer.offsetWidth;\n    this._viewportHeight = this.scrollTarget.offsetHeight;\n    this._scrollPageHeight = this._viewportHeight - this._scrollLineHeight;\n    if (this.grid) {\n      this._updateGridMetrics();\n    }\n  }\n\n  /** @private */\n  setAttribute() {}\n\n  /** @private */\n  _createPool(size) {\n    const physicalItems = this.createElements(size);\n    const fragment = document.createDocumentFragment();\n    physicalItems.forEach(el => {\n      el.style.position = 'absolute';\n      fragment.appendChild(el);\n      this.__resizeObserver.observe(el);\n    });\n    this.elementsContainer.appendChild(fragment);\n    return physicalItems;\n  }\n\n  /** @private */\n  _assignModels(itemSet) {\n    const updatedElements = [];\n    this._iterateItems((pidx, vidx) => {\n      const el = this._physicalItems[pidx];\n      el.hidden = vidx >= this.size;\n      if (!el.hidden) {\n        el.__virtualIndex = vidx + (this._vidxOffset || 0);\n        this.__updateElement(el, el.__virtualIndex);\n        updatedElements.push(el);\n      } else {\n        delete el.__lastUpdatedIndex;\n      }\n    }, itemSet);\n    this.__afterElementsUpdated(updatedElements);\n  }\n\n  /** @private */\n  _isClientFull() {\n    // Workaround an issue in iron-list that can cause it to freeze on fast scroll\n    setTimeout(() => {\n      this.__clientFull = true;\n    });\n    return this.__clientFull || super._isClientFull();\n  }\n\n  /** @private */\n  translate3d(_x, y, _z, el) {\n    el.style.transform = `translateY(${y})`;\n  }\n\n  /** @private */\n  toggleScrollListener() {}\n  _scrollHandler() {\n    // The scroll target is hidden.\n    if (this.scrollTarget.offsetHeight === 0) {\n      return;\n    }\n    this._adjustVirtualIndexOffset(this._scrollTop - (this.__previousScrollTop || 0));\n    const delta = this.scrollTarget.scrollTop - this._scrollPosition;\n    super._scrollHandler();\n    if (this._physicalCount !== 0) {\n      const isScrollingDown = delta >= 0;\n      const reusables = this._getReusables(!isScrollingDown);\n      if (reusables.indexes.length) {\n        // After running super._scrollHandler, fix internal properties to workaround an iron-list issue.\n        // See https://github.com/vaadin/web-components/issues/1691\n        this._physicalTop = reusables.physicalTop;\n        if (isScrollingDown) {\n          this._virtualStart -= reusables.indexes.length;\n          this._physicalStart -= reusables.indexes.length;\n        } else {\n          this._virtualStart += reusables.indexes.length;\n          this._physicalStart += reusables.indexes.length;\n        }\n        this._resizeHandler();\n      }\n    }\n    if (delta) {\n      // There was a change in scroll top. Schedule a check for invalid item positioning.\n      this.__fixInvalidItemPositioningDebouncer = Debouncer.debounce(this.__fixInvalidItemPositioningDebouncer, timeOut.after(this.timeouts.FIX_INVALID_ITEM_POSITIONING), () => this.__fixInvalidItemPositioning());\n    }\n    if (this.reorderElements) {\n      this.__scrollReorderDebouncer = Debouncer.debounce(this.__scrollReorderDebouncer, timeOut.after(this.timeouts.SCROLL_REORDER), () => this.__reorderElements());\n    }\n    this.__previousScrollTop = this._scrollTop;\n\n    // If the first visible index is not 0 when scrolled to the top,\n    // scroll to index 0 to fix the issue.\n    if (this._scrollTop === 0 && this.firstVisibleIndex !== 0 && Math.abs(delta) > 0) {\n      this.scrollToIndex(0);\n    }\n  }\n\n  /**\n   * Work around an iron-list issue with invalid item positioning.\n   * See https://github.com/vaadin/flow-components/issues/4306\n   * @private\n   */\n  __fixInvalidItemPositioning() {\n    if (!this.scrollTarget.isConnected) {\n      return;\n    }\n\n    // Check if the first physical item element is below the top of the viewport\n    const physicalTopBelowTop = this._physicalTop > this._scrollTop;\n    // Check if the last physical item element is above the bottom of the viewport\n    const physicalBottomAboveBottom = this._physicalBottom < this._scrollBottom;\n\n    // Check if the first index is visible\n    const firstIndexVisible = this.adjustedFirstVisibleIndex === 0;\n    // Check if the last index is visible\n    const lastIndexVisible = this.adjustedLastVisibleIndex === this.size - 1;\n    if (physicalTopBelowTop && !firstIndexVisible || physicalBottomAboveBottom && !lastIndexVisible) {\n      // Invalid state! Try to recover.\n\n      const isScrollingDown = physicalBottomAboveBottom;\n      // Set the \"_ratio\" property temporarily to 0 to make iron-list's _getReusables\n      // place all the free physical items on one side of the viewport.\n      const originalRatio = this._ratio;\n      this._ratio = 0;\n      // Fake a scroll change to make _scrollHandler place the physical items\n      // on the desired side.\n      this._scrollPosition = this._scrollTop + (isScrollingDown ? -1 : 1);\n      this._scrollHandler();\n      // Restore the original \"_ratio\" value.\n      this._ratio = originalRatio;\n    }\n  }\n\n  /** @private */\n  __onWheel(e) {\n    if (e.ctrlKey || this._hasScrolledAncestor(e.target, e.deltaX, e.deltaY)) {\n      return;\n    }\n    let deltaY = e.deltaY;\n    if (e.deltaMode === WheelEvent.DOM_DELTA_LINE) {\n      // Scrolling by \"lines of text\" instead of pixels\n      deltaY *= this._scrollLineHeight;\n    } else if (e.deltaMode === WheelEvent.DOM_DELTA_PAGE) {\n      // Scrolling by \"pages\" instead of pixels\n      deltaY *= this._scrollPageHeight;\n    }\n    if (!this._deltaYAcc) {\n      this._deltaYAcc = 0;\n    }\n    if (this._wheelAnimationFrame) {\n      // Accumulate wheel delta while a frame is being processed\n      this._deltaYAcc += deltaY;\n      e.preventDefault();\n      return;\n    }\n    deltaY += this._deltaYAcc;\n    this._deltaYAcc = 0;\n    this._wheelAnimationFrame = true;\n    this.__debouncerWheelAnimationFrame = Debouncer.debounce(this.__debouncerWheelAnimationFrame, animationFrame, () => {\n      this._wheelAnimationFrame = false;\n    });\n    const momentum = Math.abs(e.deltaX) + Math.abs(deltaY);\n    if (this._canScroll(this.scrollTarget, e.deltaX, deltaY)) {\n      e.preventDefault();\n      this.scrollTarget.scrollTop += deltaY;\n      this.scrollTarget.scrollLeft += e.deltaX;\n      this._hasResidualMomentum = true;\n      this._ignoreNewWheel = true;\n      this._debouncerIgnoreNewWheel = Debouncer.debounce(this._debouncerIgnoreNewWheel, timeOut.after(this.timeouts.IGNORE_WHEEL), () => {\n        this._ignoreNewWheel = false;\n      });\n    } else if (this._hasResidualMomentum && momentum <= this._previousMomentum || this._ignoreNewWheel) {\n      e.preventDefault();\n    } else if (momentum > this._previousMomentum) {\n      this._hasResidualMomentum = false;\n    }\n    this._previousMomentum = momentum;\n  }\n\n  /**\n   * Determines if the element has an ancestor that handles the scroll delta prior to this\n   *\n   * @private\n   */\n  _hasScrolledAncestor(el, deltaX, deltaY) {\n    if (el === this.scrollTarget || el === this.scrollTarget.getRootNode().host) {\n      return false;\n    } else if (this._canScroll(el, deltaX, deltaY) && ['auto', 'scroll'].indexOf(getComputedStyle(el).overflow) !== -1) {\n      return true;\n    } else if (el !== this && el.parentElement) {\n      return this._hasScrolledAncestor(el.parentElement, deltaX, deltaY);\n    }\n  }\n  _canScroll(el, deltaX, deltaY) {\n    return deltaY > 0 && el.scrollTop < el.scrollHeight - el.offsetHeight || deltaY < 0 && el.scrollTop > 0 || deltaX > 0 && el.scrollLeft < el.scrollWidth - el.offsetWidth || deltaX < 0 && el.scrollLeft > 0;\n  }\n\n  /**\n   * Increases the pool size.\n   * @override\n   */\n  _increasePoolIfNeeded(count) {\n    if (this._physicalCount > 2 && count) {\n      // The iron-list logic has already created some physical items and\n      // has decided to create more. Since each item creation round is\n      // expensive, let's try to create the remaining items in one go.\n\n      // Calculate the total item count that would be needed to fill the viewport\n      // plus the buffer assuming rest of the items to be of the average size\n      // of the items already created.\n      const totalItemCount = Math.ceil(this._optPhysicalSize / this._physicalAverage);\n      const missingItemCount = totalItemCount - this._physicalCount;\n      // Create the remaining items in one go. Use a maximum of 100 items\n      // as a safety measure.\n      super._increasePoolIfNeeded(Math.max(count, Math.min(100, missingItemCount)));\n    } else {\n      super._increasePoolIfNeeded(count);\n    }\n  }\n\n  /**\n   * @returns {Number|undefined} - The browser's default font-size in pixels\n   * @private\n   */\n  _getScrollLineHeight() {\n    const el = document.createElement('div');\n    el.style.fontSize = 'initial';\n    el.style.display = 'none';\n    document.body.appendChild(el);\n    const fontSize = window.getComputedStyle(el).fontSize;\n    document.body.removeChild(el);\n    return fontSize ? window.parseInt(fontSize) : undefined;\n  }\n  __getVisibleElements() {\n    return Array.from(this.elementsContainer.children).filter(element => !element.hidden);\n  }\n\n  /** @private */\n  __reorderElements() {\n    if (this.__mouseDown) {\n      this.__pendingReorder = true;\n      return;\n    }\n    this.__pendingReorder = false;\n    const adjustedVirtualStart = this._virtualStart + (this._vidxOffset || 0);\n\n    // Which row to use as a target?\n    const visibleElements = this.__getVisibleElements();\n    const elementWithFocus = visibleElements.find(element => element.contains(this.elementsContainer.getRootNode().activeElement) || element.contains(this.scrollTarget.getRootNode().activeElement));\n    const targetElement = elementWithFocus || visibleElements[0];\n    if (!targetElement) {\n      // All elements are hidden, don't reorder\n      return;\n    }\n\n    // Where the target row should be?\n    const targetPhysicalIndex = targetElement.__virtualIndex - adjustedVirtualStart;\n\n    // Reodrer the DOM elements to keep the target row at the target physical index\n    const delta = visibleElements.indexOf(targetElement) - targetPhysicalIndex;\n    if (delta > 0) {\n      for (let i = 0; i < delta; i++) {\n        this.elementsContainer.appendChild(visibleElements[i]);\n      }\n    } else if (delta < 0) {\n      for (let i = visibleElements.length + delta; i < visibleElements.length; i++) {\n        this.elementsContainer.insertBefore(visibleElements[i], visibleElements[0]);\n      }\n    }\n\n    // Due to a rendering bug, reordering the rows can make parts of the scroll target disappear\n    // on Safari when using sticky positioning in case the scroll target is inside a flexbox.\n    // This issue manifests with grid (the header can disappear if grid is used inside a flexbox)\n    if (isSafari) {\n      const {\n        transform\n      } = this.scrollTarget.style;\n      this.scrollTarget.style.transform = 'translateZ(0)';\n      setTimeout(() => {\n        this.scrollTarget.style.transform = transform;\n      });\n    }\n  }\n\n  /** @private */\n  _adjustVirtualIndexOffset(delta) {\n    if (this._virtualCount >= this.size) {\n      this._vidxOffset = 0;\n    } else if (this.__skipNextVirtualIndexAdjust) {\n      this.__skipNextVirtualIndexAdjust = false;\n    } else if (Math.abs(delta) > 10000) {\n      // Process a large scroll position change\n      const scale = this._scrollTop / (this.scrollTarget.scrollHeight - this.scrollTarget.offsetHeight);\n      const offset = scale * this.size;\n      this._vidxOffset = Math.round(offset - scale * this._virtualCount);\n    } else {\n      // Make sure user can always swipe/wheel scroll to the start and end\n      const oldOffset = this._vidxOffset;\n      const threshold = OFFSET_ADJUST_MIN_THRESHOLD;\n      const maxShift = 100;\n\n      // Near start\n      if (this._scrollTop === 0) {\n        this._vidxOffset = 0;\n        if (oldOffset !== this._vidxOffset) {\n          super.scrollToIndex(0);\n        }\n      } else if (this.firstVisibleIndex < threshold && this._vidxOffset > 0) {\n        this._vidxOffset -= Math.min(this._vidxOffset, maxShift);\n        super.scrollToIndex(this.firstVisibleIndex + (oldOffset - this._vidxOffset));\n      }\n\n      // Near end\n      const maxOffset = this.size - this._virtualCount;\n      if (this._scrollTop >= this._maxScrollTop && this._maxScrollTop > 0) {\n        this._vidxOffset = maxOffset;\n        if (oldOffset !== this._vidxOffset) {\n          super.scrollToIndex(this._virtualCount - 1);\n        }\n      } else if (this.firstVisibleIndex > this._virtualCount - threshold && this._vidxOffset < maxOffset) {\n        this._vidxOffset += Math.min(maxOffset - this._vidxOffset, maxShift);\n        super.scrollToIndex(this.firstVisibleIndex - (this._vidxOffset - oldOffset));\n      }\n    }\n  }\n}\nObject.setPrototypeOf(IronListAdapter.prototype, ironList);","map":{"version":3,"names":["animationFrame","timeOut","isSafari","Debouncer","flush","ironList","MAX_VIRTUAL_COUNT","OFFSET_ADJUST_MIN_THRESHOLD","IronListAdapter","constructor","createElements","updateElement","scrollTarget","scrollContainer","elementsContainer","reorderElements","isAttached","_vidxOffset","_maxPages","__placeholderHeight","__elementHeightQueue","Array","timeouts","SCROLL_REORDER","IGNORE_WHEEL","FIX_INVALID_ITEM_POSITIONING","__resizeObserver","ResizeObserver","_resizeHandler","getComputedStyle","overflow","style","position","observe","addEventListener","_scrollHandler","_scrollLineHeight","_getScrollLineHeight","e","__onWheel","__mouseDown","__pendingReorder","__reorderElements","scrollOffset","adjustedFirstVisibleIndex","firstVisibleIndex","adjustedLastVisibleIndex","lastVisibleIndex","scrollToIndex","index","isNaN","size","offsetHeight","_clamp","visibleElementCount","__getVisibleElements","length","targetVirtualIndex","Math","floor","_virtualCount","__skipNextVirtualIndexAdjust","_scrollTop","_maxScrollTop","grid","__getIndexScrollOffset","__fixInvalidItemPositioningDebouncer","__scrollReorderDebouncer","__debouncerWheelAnimationFrame","update","startIndex","endIndex","updatedElements","forEach","el","__virtualIndex","__updateElement","push","__afterElementsUpdated","_updateMetrics","itemSet","newPhysicalSize","oldPhysicalSize","prevAvgCount","_physicalAverageCount","prevPhysicalAvg","_physicalAverage","_iterateItems","pidx","vidx","_physicalSizes","ceil","__getBorderBoxHeight","_physicalItems","_physicalSize","round","itemHeight","parseFloat","height","boxSizing","paddingBottom","paddingTop","borderBottomWidth","borderTopWidth","forceSameIndexUpdates","__preventElementUpdates","__lastUpdatedIndex","elementHeight","__placeholderClearDebouncer","debounce","shift","filteredHeights","filter","h","undefined","reduce","a","b","element","find","getBoundingClientRect","top","__size","cancel","_debouncers","_increasePoolIfNeeded","_itemsChanged","path","items","_isVisible","_assignModels","children","requestAnimationFrame","scrollTop","min","$","updateViewportBoundaries","styles","window","_scrollerPaddingTop","parseInt","_isRTL","Boolean","direction","_viewportWidth","offsetWidth","_viewportHeight","_scrollPageHeight","_updateGridMetrics","setAttribute","_createPool","physicalItems","fragment","document","createDocumentFragment","appendChild","hidden","_isClientFull","setTimeout","__clientFull","translate3d","_x","y","_z","transform","toggleScrollListener","_adjustVirtualIndexOffset","__previousScrollTop","delta","_scrollPosition","_physicalCount","isScrollingDown","reusables","_getReusables","indexes","_physicalTop","physicalTop","_virtualStart","_physicalStart","after","__fixInvalidItemPositioning","abs","isConnected","physicalTopBelowTop","physicalBottomAboveBottom","_physicalBottom","_scrollBottom","firstIndexVisible","lastIndexVisible","originalRatio","_ratio","ctrlKey","_hasScrolledAncestor","target","deltaX","deltaY","deltaMode","WheelEvent","DOM_DELTA_LINE","DOM_DELTA_PAGE","_deltaYAcc","_wheelAnimationFrame","preventDefault","momentum","_canScroll","scrollLeft","_hasResidualMomentum","_ignoreNewWheel","_debouncerIgnoreNewWheel","_previousMomentum","getRootNode","host","indexOf","parentElement","scrollHeight","scrollWidth","count","totalItemCount","_optPhysicalSize","missingItemCount","max","createElement","fontSize","display","body","removeChild","from","adjustedVirtualStart","visibleElements","elementWithFocus","contains","activeElement","targetElement","targetPhysicalIndex","i","insertBefore","scale","offset","oldOffset","threshold","maxShift","maxOffset","Object","setPrototypeOf","prototype"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@vaadin/component-base/src/virtualizer-iron-list-adapter.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2021 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n/* eslint-disable @typescript-eslint/member-ordering */\n// https://github.com/vaadin/eslint-config-vaadin/issues/33\nimport { animationFrame, timeOut } from './async.js';\nimport { isSafari } from './browser-utils.js';\nimport { Debouncer, flush } from './debounce.js';\nimport { ironList } from './iron-list-core.js';\n\n// Iron-list can by default handle sizes up to around 100000.\n// When the size is larger than MAX_VIRTUAL_COUNT _vidxOffset is used\nconst MAX_VIRTUAL_COUNT = 100000;\nconst OFFSET_ADJUST_MIN_THRESHOLD = 1000;\n\nexport class IronListAdapter {\n  constructor({ createElements, updateElement, scrollTarget, scrollContainer, elementsContainer, reorderElements }) {\n    this.isAttached = true;\n    this._vidxOffset = 0;\n    this.createElements = createElements;\n    this.updateElement = updateElement;\n    this.scrollTarget = scrollTarget;\n    this.scrollContainer = scrollContainer;\n    this.elementsContainer = elementsContainer || scrollContainer;\n    this.reorderElements = reorderElements;\n    // Iron-list uses this value to determine how many pages of elements to render\n    this._maxPages = 1.3;\n\n    // Placeholder height (used for sizing elements that have intrinsic 0 height after update)\n    this.__placeholderHeight = 200;\n    // A queue of 10 previous element heights\n    this.__elementHeightQueue = Array(10);\n\n    this.timeouts = {\n      SCROLL_REORDER: 500,\n      IGNORE_WHEEL: 500,\n      FIX_INVALID_ITEM_POSITIONING: 100,\n    };\n\n    this.__resizeObserver = new ResizeObserver(() => this._resizeHandler());\n\n    if (getComputedStyle(this.scrollTarget).overflow === 'visible') {\n      this.scrollTarget.style.overflow = 'auto';\n    }\n\n    if (getComputedStyle(this.scrollContainer).position === 'static') {\n      this.scrollContainer.style.position = 'relative';\n    }\n\n    this.__resizeObserver.observe(this.scrollTarget);\n    this.scrollTarget.addEventListener('scroll', () => this._scrollHandler());\n\n    this._scrollLineHeight = this._getScrollLineHeight();\n    this.scrollTarget.addEventListener('wheel', (e) => this.__onWheel(e));\n\n    if (this.reorderElements) {\n      // Reordering the physical elements cancels the user's grab of the scroll bar handle on Safari.\n      // Need to defer reordering until the user lets go of the scroll bar handle.\n      this.scrollTarget.addEventListener('mousedown', () => {\n        this.__mouseDown = true;\n      });\n      this.scrollTarget.addEventListener('mouseup', () => {\n        this.__mouseDown = false;\n        if (this.__pendingReorder) {\n          this.__reorderElements();\n        }\n      });\n    }\n  }\n\n  get scrollOffset() {\n    return 0;\n  }\n\n  get adjustedFirstVisibleIndex() {\n    return this.firstVisibleIndex + this._vidxOffset;\n  }\n\n  get adjustedLastVisibleIndex() {\n    return this.lastVisibleIndex + this._vidxOffset;\n  }\n\n  scrollToIndex(index) {\n    if (typeof index !== 'number' || isNaN(index) || this.size === 0 || !this.scrollTarget.offsetHeight) {\n      return;\n    }\n    index = this._clamp(index, 0, this.size - 1);\n\n    const visibleElementCount = this.__getVisibleElements().length;\n    let targetVirtualIndex = Math.floor((index / this.size) * this._virtualCount);\n    if (this._virtualCount - targetVirtualIndex < visibleElementCount) {\n      targetVirtualIndex = this._virtualCount - (this.size - index);\n      this._vidxOffset = this.size - this._virtualCount;\n    } else if (targetVirtualIndex < visibleElementCount) {\n      if (index < OFFSET_ADJUST_MIN_THRESHOLD) {\n        targetVirtualIndex = index;\n        this._vidxOffset = 0;\n      } else {\n        targetVirtualIndex = OFFSET_ADJUST_MIN_THRESHOLD;\n        this._vidxOffset = index - targetVirtualIndex;\n      }\n    } else {\n      this._vidxOffset = index - targetVirtualIndex;\n    }\n\n    this.__skipNextVirtualIndexAdjust = true;\n    super.scrollToIndex(targetVirtualIndex);\n\n    if (this.adjustedFirstVisibleIndex !== index && this._scrollTop < this._maxScrollTop && !this.grid) {\n      // Workaround an iron-list issue by manually adjusting the scroll position\n      this._scrollTop -= this.__getIndexScrollOffset(index) || 0;\n    }\n    this._scrollHandler();\n  }\n\n  flush() {\n    // The scroll target is hidden.\n    if (this.scrollTarget.offsetHeight === 0) {\n      return;\n    }\n\n    this._resizeHandler();\n    flush();\n    this._scrollHandler();\n    if (this.__fixInvalidItemPositioningDebouncer) {\n      this.__fixInvalidItemPositioningDebouncer.flush();\n    }\n    if (this.__scrollReorderDebouncer) {\n      this.__scrollReorderDebouncer.flush();\n    }\n    if (this.__debouncerWheelAnimationFrame) {\n      this.__debouncerWheelAnimationFrame.flush();\n    }\n  }\n\n  update(startIndex = 0, endIndex = this.size - 1) {\n    const updatedElements = [];\n    this.__getVisibleElements().forEach((el) => {\n      if (el.__virtualIndex >= startIndex && el.__virtualIndex <= endIndex) {\n        this.__updateElement(el, el.__virtualIndex, true);\n        updatedElements.push(el);\n      }\n    });\n\n    this.__afterElementsUpdated(updatedElements);\n  }\n\n  /**\n   * Updates the height for a given set of items.\n   *\n   * @param {!Array<number>=} itemSet\n   */\n  _updateMetrics(itemSet) {\n    // Make sure we distributed all the physical items\n    // so we can measure them.\n    flush();\n\n    let newPhysicalSize = 0;\n    let oldPhysicalSize = 0;\n    const prevAvgCount = this._physicalAverageCount;\n    const prevPhysicalAvg = this._physicalAverage;\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._iterateItems((pidx, vidx) => {\n      oldPhysicalSize += this._physicalSizes[pidx];\n      this._physicalSizes[pidx] = Math.ceil(this.__getBorderBoxHeight(this._physicalItems[pidx]));\n      newPhysicalSize += this._physicalSizes[pidx];\n      this._physicalAverageCount += this._physicalSizes[pidx] ? 1 : 0;\n    }, itemSet);\n\n    this._physicalSize = this._physicalSize + newPhysicalSize - oldPhysicalSize;\n\n    // Update the average if it measured something.\n    if (this._physicalAverageCount !== prevAvgCount) {\n      this._physicalAverage = Math.round(\n        (prevPhysicalAvg * prevAvgCount + newPhysicalSize) / this._physicalAverageCount,\n      );\n    }\n  }\n\n  __getBorderBoxHeight(el) {\n    const style = getComputedStyle(el);\n\n    const itemHeight = parseFloat(style.height) || 0;\n\n    if (style.boxSizing === 'border-box') {\n      return itemHeight;\n    }\n\n    const paddingBottom = parseFloat(style.paddingBottom) || 0;\n    const paddingTop = parseFloat(style.paddingTop) || 0;\n    const borderBottomWidth = parseFloat(style.borderBottomWidth) || 0;\n    const borderTopWidth = parseFloat(style.borderTopWidth) || 0;\n\n    return itemHeight + paddingBottom + paddingTop + borderBottomWidth + borderTopWidth;\n  }\n\n  __updateElement(el, index, forceSameIndexUpdates) {\n    // Clean up temporary placeholder sizing\n    if (el.style.paddingTop) {\n      el.style.paddingTop = '';\n    }\n\n    if (!this.__preventElementUpdates && (el.__lastUpdatedIndex !== index || forceSameIndexUpdates)) {\n      this.updateElement(el, index);\n      el.__lastUpdatedIndex = index;\n    }\n  }\n\n  /**\n   * Called synchronously right after elements have been updated.\n   * This is a good place to do any post-update work.\n   *\n   * @param {!Array<!HTMLElement>} updatedElements\n   */\n  __afterElementsUpdated(updatedElements) {\n    updatedElements.forEach((el) => {\n      const elementHeight = el.offsetHeight;\n      if (elementHeight === 0) {\n        // If the elements have 0 height after update (for example due to lazy rendering),\n        // it results in iron-list requesting to create an unlimited count of elements.\n        // Assign a temporary placeholder sizing to elements that would otherwise end up having\n        // no height.\n        el.style.paddingTop = `${this.__placeholderHeight}px`;\n\n        // Manually schedule the resize handler to make sure the placeholder padding is\n        // cleared in case the resize observer never triggers.\n        this.__placeholderClearDebouncer = Debouncer.debounce(this.__placeholderClearDebouncer, animationFrame, () =>\n          this._resizeHandler(),\n        );\n      } else {\n        // Add element height to the queue\n        this.__elementHeightQueue.push(elementHeight);\n        this.__elementHeightQueue.shift();\n\n        // Calculate new placeholder height based on the average of the defined values in the\n        // element height queue\n        const filteredHeights = this.__elementHeightQueue.filter((h) => h !== undefined);\n        this.__placeholderHeight = Math.round(filteredHeights.reduce((a, b) => a + b, 0) / filteredHeights.length);\n      }\n    });\n  }\n\n  __getIndexScrollOffset(index) {\n    const element = this.__getVisibleElements().find((el) => el.__virtualIndex === index);\n    return element ? this.scrollTarget.getBoundingClientRect().top - element.getBoundingClientRect().top : undefined;\n  }\n\n  get size() {\n    return this.__size;\n  }\n\n  set size(size) {\n    if (size === this.size) {\n      return;\n    }\n    // Cancel active debouncers\n    if (this.__fixInvalidItemPositioningDebouncer) {\n      this.__fixInvalidItemPositioningDebouncer.cancel();\n    }\n    if (this._debouncers && this._debouncers._increasePoolIfNeeded) {\n      // Avoid creating unnecessary elements on the following flush()\n      this._debouncers._increasePoolIfNeeded.cancel();\n    }\n\n    // Change the size\n    this.__size = size;\n\n    if (!this._physicalItems) {\n      // Not initialized yet\n      this._itemsChanged({\n        path: 'items',\n      });\n      this.__preventElementUpdates = true;\n      flush();\n      this.__preventElementUpdates = false;\n    } else {\n      // Already initialized, just update _virtualCount\n      this._virtualCount = this.items.length;\n    }\n\n    // When reducing size while invisible, iron-list does not update items, so\n    // their hidden state is not updated and their __lastUpdatedIndex is not\n    // reset. In that case force an update here.\n    if (!this._isVisible) {\n      this._assignModels();\n    }\n\n    if (!this.elementsContainer.children.length) {\n      requestAnimationFrame(() => this._resizeHandler());\n    }\n\n    // Schedule and flush a resize handler. This will cause a\n    // re-render for the elements.\n    this._resizeHandler();\n    flush();\n  }\n\n  /** @private */\n  get _scrollTop() {\n    return this.scrollTarget.scrollTop;\n  }\n\n  /** @private */\n  set _scrollTop(top) {\n    this.scrollTarget.scrollTop = top;\n  }\n\n  /** @private */\n  get items() {\n    return {\n      length: Math.min(this.size, MAX_VIRTUAL_COUNT),\n    };\n  }\n\n  /** @private */\n  get offsetHeight() {\n    return this.scrollTarget.offsetHeight;\n  }\n\n  /** @private */\n  get $() {\n    return {\n      items: this.scrollContainer,\n    };\n  }\n\n  /** @private */\n  updateViewportBoundaries() {\n    const styles = window.getComputedStyle(this.scrollTarget);\n    this._scrollerPaddingTop = this.scrollTarget === this ? 0 : parseInt(styles['padding-top'], 10);\n    this._isRTL = Boolean(styles.direction === 'rtl');\n    this._viewportWidth = this.elementsContainer.offsetWidth;\n    this._viewportHeight = this.scrollTarget.offsetHeight;\n    this._scrollPageHeight = this._viewportHeight - this._scrollLineHeight;\n    if (this.grid) {\n      this._updateGridMetrics();\n    }\n  }\n\n  /** @private */\n  setAttribute() {}\n\n  /** @private */\n  _createPool(size) {\n    const physicalItems = this.createElements(size);\n    const fragment = document.createDocumentFragment();\n    physicalItems.forEach((el) => {\n      el.style.position = 'absolute';\n      fragment.appendChild(el);\n      this.__resizeObserver.observe(el);\n    });\n    this.elementsContainer.appendChild(fragment);\n    return physicalItems;\n  }\n\n  /** @private */\n  _assignModels(itemSet) {\n    const updatedElements = [];\n    this._iterateItems((pidx, vidx) => {\n      const el = this._physicalItems[pidx];\n      el.hidden = vidx >= this.size;\n      if (!el.hidden) {\n        el.__virtualIndex = vidx + (this._vidxOffset || 0);\n        this.__updateElement(el, el.__virtualIndex);\n        updatedElements.push(el);\n      } else {\n        delete el.__lastUpdatedIndex;\n      }\n    }, itemSet);\n\n    this.__afterElementsUpdated(updatedElements);\n  }\n\n  /** @private */\n  _isClientFull() {\n    // Workaround an issue in iron-list that can cause it to freeze on fast scroll\n    setTimeout(() => {\n      this.__clientFull = true;\n    });\n    return this.__clientFull || super._isClientFull();\n  }\n\n  /** @private */\n  translate3d(_x, y, _z, el) {\n    el.style.transform = `translateY(${y})`;\n  }\n\n  /** @private */\n  toggleScrollListener() {}\n\n  _scrollHandler() {\n    // The scroll target is hidden.\n    if (this.scrollTarget.offsetHeight === 0) {\n      return;\n    }\n\n    this._adjustVirtualIndexOffset(this._scrollTop - (this.__previousScrollTop || 0));\n    const delta = this.scrollTarget.scrollTop - this._scrollPosition;\n\n    super._scrollHandler();\n\n    if (this._physicalCount !== 0) {\n      const isScrollingDown = delta >= 0;\n      const reusables = this._getReusables(!isScrollingDown);\n\n      if (reusables.indexes.length) {\n        // After running super._scrollHandler, fix internal properties to workaround an iron-list issue.\n        // See https://github.com/vaadin/web-components/issues/1691\n        this._physicalTop = reusables.physicalTop;\n\n        if (isScrollingDown) {\n          this._virtualStart -= reusables.indexes.length;\n          this._physicalStart -= reusables.indexes.length;\n        } else {\n          this._virtualStart += reusables.indexes.length;\n          this._physicalStart += reusables.indexes.length;\n        }\n        this._resizeHandler();\n      }\n    }\n\n    if (delta) {\n      // There was a change in scroll top. Schedule a check for invalid item positioning.\n      this.__fixInvalidItemPositioningDebouncer = Debouncer.debounce(\n        this.__fixInvalidItemPositioningDebouncer,\n        timeOut.after(this.timeouts.FIX_INVALID_ITEM_POSITIONING),\n        () => this.__fixInvalidItemPositioning(),\n      );\n    }\n\n    if (this.reorderElements) {\n      this.__scrollReorderDebouncer = Debouncer.debounce(\n        this.__scrollReorderDebouncer,\n        timeOut.after(this.timeouts.SCROLL_REORDER),\n        () => this.__reorderElements(),\n      );\n    }\n\n    this.__previousScrollTop = this._scrollTop;\n\n    // If the first visible index is not 0 when scrolled to the top,\n    // scroll to index 0 to fix the issue.\n    if (this._scrollTop === 0 && this.firstVisibleIndex !== 0 && Math.abs(delta) > 0) {\n      this.scrollToIndex(0);\n    }\n  }\n\n  /**\n   * Work around an iron-list issue with invalid item positioning.\n   * See https://github.com/vaadin/flow-components/issues/4306\n   * @private\n   */\n  __fixInvalidItemPositioning() {\n    if (!this.scrollTarget.isConnected) {\n      return;\n    }\n\n    // Check if the first physical item element is below the top of the viewport\n    const physicalTopBelowTop = this._physicalTop > this._scrollTop;\n    // Check if the last physical item element is above the bottom of the viewport\n    const physicalBottomAboveBottom = this._physicalBottom < this._scrollBottom;\n\n    // Check if the first index is visible\n    const firstIndexVisible = this.adjustedFirstVisibleIndex === 0;\n    // Check if the last index is visible\n    const lastIndexVisible = this.adjustedLastVisibleIndex === this.size - 1;\n\n    if ((physicalTopBelowTop && !firstIndexVisible) || (physicalBottomAboveBottom && !lastIndexVisible)) {\n      // Invalid state! Try to recover.\n\n      const isScrollingDown = physicalBottomAboveBottom;\n      // Set the \"_ratio\" property temporarily to 0 to make iron-list's _getReusables\n      // place all the free physical items on one side of the viewport.\n      const originalRatio = this._ratio;\n      this._ratio = 0;\n      // Fake a scroll change to make _scrollHandler place the physical items\n      // on the desired side.\n      this._scrollPosition = this._scrollTop + (isScrollingDown ? -1 : 1);\n      this._scrollHandler();\n      // Restore the original \"_ratio\" value.\n      this._ratio = originalRatio;\n    }\n  }\n\n  /** @private */\n  __onWheel(e) {\n    if (e.ctrlKey || this._hasScrolledAncestor(e.target, e.deltaX, e.deltaY)) {\n      return;\n    }\n\n    let deltaY = e.deltaY;\n    if (e.deltaMode === WheelEvent.DOM_DELTA_LINE) {\n      // Scrolling by \"lines of text\" instead of pixels\n      deltaY *= this._scrollLineHeight;\n    } else if (e.deltaMode === WheelEvent.DOM_DELTA_PAGE) {\n      // Scrolling by \"pages\" instead of pixels\n      deltaY *= this._scrollPageHeight;\n    }\n\n    if (!this._deltaYAcc) {\n      this._deltaYAcc = 0;\n    }\n\n    if (this._wheelAnimationFrame) {\n      // Accumulate wheel delta while a frame is being processed\n      this._deltaYAcc += deltaY;\n      e.preventDefault();\n      return;\n    }\n\n    deltaY += this._deltaYAcc;\n    this._deltaYAcc = 0;\n\n    this._wheelAnimationFrame = true;\n    this.__debouncerWheelAnimationFrame = Debouncer.debounce(\n      this.__debouncerWheelAnimationFrame,\n      animationFrame,\n      () => {\n        this._wheelAnimationFrame = false;\n      },\n    );\n\n    const momentum = Math.abs(e.deltaX) + Math.abs(deltaY);\n\n    if (this._canScroll(this.scrollTarget, e.deltaX, deltaY)) {\n      e.preventDefault();\n      this.scrollTarget.scrollTop += deltaY;\n      this.scrollTarget.scrollLeft += e.deltaX;\n\n      this._hasResidualMomentum = true;\n\n      this._ignoreNewWheel = true;\n      this._debouncerIgnoreNewWheel = Debouncer.debounce(\n        this._debouncerIgnoreNewWheel,\n        timeOut.after(this.timeouts.IGNORE_WHEEL),\n        () => {\n          this._ignoreNewWheel = false;\n        },\n      );\n    } else if ((this._hasResidualMomentum && momentum <= this._previousMomentum) || this._ignoreNewWheel) {\n      e.preventDefault();\n    } else if (momentum > this._previousMomentum) {\n      this._hasResidualMomentum = false;\n    }\n    this._previousMomentum = momentum;\n  }\n\n  /**\n   * Determines if the element has an ancestor that handles the scroll delta prior to this\n   *\n   * @private\n   */\n  _hasScrolledAncestor(el, deltaX, deltaY) {\n    if (el === this.scrollTarget || el === this.scrollTarget.getRootNode().host) {\n      return false;\n    } else if (\n      this._canScroll(el, deltaX, deltaY) &&\n      ['auto', 'scroll'].indexOf(getComputedStyle(el).overflow) !== -1\n    ) {\n      return true;\n    } else if (el !== this && el.parentElement) {\n      return this._hasScrolledAncestor(el.parentElement, deltaX, deltaY);\n    }\n  }\n\n  _canScroll(el, deltaX, deltaY) {\n    return (\n      (deltaY > 0 && el.scrollTop < el.scrollHeight - el.offsetHeight) ||\n      (deltaY < 0 && el.scrollTop > 0) ||\n      (deltaX > 0 && el.scrollLeft < el.scrollWidth - el.offsetWidth) ||\n      (deltaX < 0 && el.scrollLeft > 0)\n    );\n  }\n\n  /**\n   * Increases the pool size.\n   * @override\n   */\n  _increasePoolIfNeeded(count) {\n    if (this._physicalCount > 2 && count) {\n      // The iron-list logic has already created some physical items and\n      // has decided to create more. Since each item creation round is\n      // expensive, let's try to create the remaining items in one go.\n\n      // Calculate the total item count that would be needed to fill the viewport\n      // plus the buffer assuming rest of the items to be of the average size\n      // of the items already created.\n      const totalItemCount = Math.ceil(this._optPhysicalSize / this._physicalAverage);\n      const missingItemCount = totalItemCount - this._physicalCount;\n      // Create the remaining items in one go. Use a maximum of 100 items\n      // as a safety measure.\n      super._increasePoolIfNeeded(Math.max(count, Math.min(100, missingItemCount)));\n    } else {\n      super._increasePoolIfNeeded(count);\n    }\n  }\n\n  /**\n   * @returns {Number|undefined} - The browser's default font-size in pixels\n   * @private\n   */\n  _getScrollLineHeight() {\n    const el = document.createElement('div');\n    el.style.fontSize = 'initial';\n    el.style.display = 'none';\n    document.body.appendChild(el);\n    const fontSize = window.getComputedStyle(el).fontSize;\n    document.body.removeChild(el);\n    return fontSize ? window.parseInt(fontSize) : undefined;\n  }\n\n  __getVisibleElements() {\n    return Array.from(this.elementsContainer.children).filter((element) => !element.hidden);\n  }\n\n  /** @private */\n  __reorderElements() {\n    if (this.__mouseDown) {\n      this.__pendingReorder = true;\n      return;\n    }\n    this.__pendingReorder = false;\n\n    const adjustedVirtualStart = this._virtualStart + (this._vidxOffset || 0);\n\n    // Which row to use as a target?\n    const visibleElements = this.__getVisibleElements();\n\n    const elementWithFocus = visibleElements.find(\n      (element) =>\n        element.contains(this.elementsContainer.getRootNode().activeElement) ||\n        element.contains(this.scrollTarget.getRootNode().activeElement),\n    );\n    const targetElement = elementWithFocus || visibleElements[0];\n    if (!targetElement) {\n      // All elements are hidden, don't reorder\n      return;\n    }\n\n    // Where the target row should be?\n    const targetPhysicalIndex = targetElement.__virtualIndex - adjustedVirtualStart;\n\n    // Reodrer the DOM elements to keep the target row at the target physical index\n    const delta = visibleElements.indexOf(targetElement) - targetPhysicalIndex;\n    if (delta > 0) {\n      for (let i = 0; i < delta; i++) {\n        this.elementsContainer.appendChild(visibleElements[i]);\n      }\n    } else if (delta < 0) {\n      for (let i = visibleElements.length + delta; i < visibleElements.length; i++) {\n        this.elementsContainer.insertBefore(visibleElements[i], visibleElements[0]);\n      }\n    }\n\n    // Due to a rendering bug, reordering the rows can make parts of the scroll target disappear\n    // on Safari when using sticky positioning in case the scroll target is inside a flexbox.\n    // This issue manifests with grid (the header can disappear if grid is used inside a flexbox)\n    if (isSafari) {\n      const { transform } = this.scrollTarget.style;\n      this.scrollTarget.style.transform = 'translateZ(0)';\n      setTimeout(() => {\n        this.scrollTarget.style.transform = transform;\n      });\n    }\n  }\n\n  /** @private */\n  _adjustVirtualIndexOffset(delta) {\n    if (this._virtualCount >= this.size) {\n      this._vidxOffset = 0;\n    } else if (this.__skipNextVirtualIndexAdjust) {\n      this.__skipNextVirtualIndexAdjust = false;\n    } else if (Math.abs(delta) > 10000) {\n      // Process a large scroll position change\n      const scale = this._scrollTop / (this.scrollTarget.scrollHeight - this.scrollTarget.offsetHeight);\n      const offset = scale * this.size;\n      this._vidxOffset = Math.round(offset - scale * this._virtualCount);\n    } else {\n      // Make sure user can always swipe/wheel scroll to the start and end\n      const oldOffset = this._vidxOffset;\n      const threshold = OFFSET_ADJUST_MIN_THRESHOLD;\n      const maxShift = 100;\n\n      // Near start\n      if (this._scrollTop === 0) {\n        this._vidxOffset = 0;\n        if (oldOffset !== this._vidxOffset) {\n          super.scrollToIndex(0);\n        }\n      } else if (this.firstVisibleIndex < threshold && this._vidxOffset > 0) {\n        this._vidxOffset -= Math.min(this._vidxOffset, maxShift);\n        super.scrollToIndex(this.firstVisibleIndex + (oldOffset - this._vidxOffset));\n      }\n\n      // Near end\n      const maxOffset = this.size - this._virtualCount;\n      if (this._scrollTop >= this._maxScrollTop && this._maxScrollTop > 0) {\n        this._vidxOffset = maxOffset;\n        if (oldOffset !== this._vidxOffset) {\n          super.scrollToIndex(this._virtualCount - 1);\n        }\n      } else if (this.firstVisibleIndex > this._virtualCount - threshold && this._vidxOffset < maxOffset) {\n        this._vidxOffset += Math.min(maxOffset - this._vidxOffset, maxShift);\n        super.scrollToIndex(this.firstVisibleIndex - (this._vidxOffset - oldOffset));\n      }\n    }\n  }\n}\n\nObject.setPrototypeOf(IronListAdapter.prototype, ironList);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}