{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2016 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { isKeyboardActive } from '@vaadin/a11y-base/src/focus-utils.js';\nimport { addValueToAttribute, removeValueFromAttribute } from '@vaadin/component-base/src/dom-utils.js';\nimport { get } from '@vaadin/component-base/src/path-utils.js';\n\n/**\n * @polymerMixin\n */\nexport const KeyboardNavigationMixin = superClass => class KeyboardNavigationMixin extends superClass {\n  static get properties() {\n    return {\n      /** @private */\n      _headerFocusable: {\n        type: Object,\n        observer: '_focusableChanged'\n      },\n      /**\n       * @type {!HTMLElement | undefined}\n       * @protected\n       */\n      _itemsFocusable: {\n        type: Object,\n        observer: '_focusableChanged'\n      },\n      /** @private */\n      _footerFocusable: {\n        type: Object,\n        observer: '_focusableChanged'\n      },\n      /** @private */\n      _navigatingIsHidden: Boolean,\n      /**\n       * @type {number}\n       * @protected\n       */\n      _focusedItemIndex: {\n        type: Number,\n        value: 0\n      },\n      /** @private */\n      _focusedColumnOrder: Number,\n      /** @private */\n      _focusedCell: {\n        type: Object,\n        observer: '_focusedCellChanged'\n      },\n      /**\n       * Indicates whether the grid is currently in interaction mode.\n       * In interaction mode the user is currently interacting with a control,\n       * such as an input or a select, within a cell.\n       * In interaction mode keyboard navigation between cells is disabled.\n       * Interaction mode also prevents the focus target cell of that section of\n       * the grid from receiving focus, allowing the user to switch focus to\n       * controls in adjacent cells, rather than focussing the outer cell\n       * itself.\n       * @type {boolean}\n       * @private\n       */\n      interacting: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true,\n        readOnly: true,\n        observer: '_interactingChanged'\n      }\n    };\n  }\n\n  /** @private */\n  get __rowFocusMode() {\n    return this.__isRow(this._itemsFocusable) || this.__isRow(this._headerFocusable) || this.__isRow(this._footerFocusable);\n  }\n  set __rowFocusMode(value) {\n    ['_itemsFocusable', '_footerFocusable', '_headerFocusable'].forEach(prop => {\n      const focusable = this[prop];\n      if (value) {\n        const parent = focusable && focusable.parentElement;\n        if (this.__isCell(focusable)) {\n          // Cell itself focusable (default)\n          this[prop] = parent;\n        } else if (this.__isCell(parent)) {\n          // Focus button mode is enabled for the column,\n          // button element inside the cell is focusable.\n          this[prop] = parent.parentElement;\n        }\n      } else if (!value && this.__isRow(focusable)) {\n        const cell = focusable.firstElementChild;\n        this[prop] = cell._focusButton || cell;\n      }\n    });\n  }\n\n  /** @protected */\n  ready() {\n    super.ready();\n    if (this._ios || this._android) {\n      // Disable keyboard navigation on mobile devices\n      return;\n    }\n    this.addEventListener('keydown', this._onKeyDown);\n    this.addEventListener('keyup', this._onKeyUp);\n    this.addEventListener('focusin', this._onFocusIn);\n    this.addEventListener('focusout', this._onFocusOut);\n\n    // When focus goes from cell to another cell, focusin/focusout events do\n    // not escape the grid's shadowRoot, thus listening inside the shadowRoot.\n    this.$.table.addEventListener('focusin', this._onContentFocusIn.bind(this));\n    this.addEventListener('mousedown', () => {\n      this.toggleAttribute('navigating', false);\n      this._isMousedown = true;\n\n      // Reset stored order when moving focus with mouse.\n      this._focusedColumnOrder = undefined;\n    });\n    this.addEventListener('mouseup', () => {\n      this._isMousedown = false;\n    });\n  }\n\n  /** @private */\n  _focusableChanged(focusable, oldFocusable) {\n    if (oldFocusable) {\n      oldFocusable.setAttribute('tabindex', '-1');\n    }\n    if (focusable) {\n      this._updateGridSectionFocusTarget(focusable);\n    }\n  }\n\n  /** @private */\n  _focusedCellChanged(focusedCell, oldFocusedCell) {\n    if (oldFocusedCell) {\n      removeValueFromAttribute(oldFocusedCell, 'part', 'focused-cell');\n    }\n    if (focusedCell) {\n      addValueToAttribute(focusedCell, 'part', 'focused-cell');\n    }\n  }\n\n  /** @private */\n  _interactingChanged() {\n    // Update focus targets when entering / exiting interaction mode\n    this._updateGridSectionFocusTarget(this._headerFocusable);\n    this._updateGridSectionFocusTarget(this._itemsFocusable);\n    this._updateGridSectionFocusTarget(this._footerFocusable);\n  }\n\n  /**\n   * Since the focused cell/row state is stored as an element reference, the reference may get\n   * out of sync when the virtual indexes for elements update due to effective size change.\n   * This function updates the reference to the correct element after a possible index change.\n   * @private\n   */\n  __updateItemsFocusable() {\n    if (!this._itemsFocusable) {\n      return;\n    }\n    const wasFocused = this.shadowRoot.activeElement === this._itemsFocusable;\n    this._getRenderedRows().forEach(row => {\n      if (row.index === this._focusedItemIndex) {\n        if (this.__rowFocusMode) {\n          // Row focus mode\n          this._itemsFocusable = row;\n        } else {\n          // Cell focus mode\n          let parent = this._itemsFocusable.parentElement;\n          let cell = this._itemsFocusable;\n          if (parent) {\n            // Focus button mode is enabled for the column,\n            // button element inside the cell is focusable.\n            if (this.__isCell(parent)) {\n              cell = parent;\n              parent = parent.parentElement;\n            }\n            const cellIndex = [...parent.children].indexOf(cell);\n            this._itemsFocusable = this.__getFocusable(row, row.children[cellIndex]);\n          }\n        }\n      }\n    });\n    if (wasFocused) {\n      this._itemsFocusable.focus();\n    }\n  }\n\n  /**\n   * @param {!KeyboardEvent} e\n   * @protected\n   */\n  _onKeyDown(e) {\n    const key = e.key;\n    let keyGroup;\n    switch (key) {\n      case 'ArrowUp':\n      case 'ArrowDown':\n      case 'ArrowLeft':\n      case 'ArrowRight':\n      case 'PageUp':\n      case 'PageDown':\n      case 'Home':\n      case 'End':\n        keyGroup = 'Navigation';\n        break;\n      case 'Enter':\n      case 'Escape':\n      case 'F2':\n        keyGroup = 'Interaction';\n        break;\n      case 'Tab':\n        keyGroup = 'Tab';\n        break;\n      case ' ':\n        keyGroup = 'Space';\n        break;\n      default:\n        break;\n    }\n    this._detectInteracting(e);\n    if (this.interacting && keyGroup !== 'Interaction') {\n      // When in the interacting mode, only the \"Interaction\" keys are handled.\n      keyGroup = undefined;\n    }\n    if (keyGroup) {\n      this[`_on${keyGroup}KeyDown`](e, key);\n    }\n  }\n\n  /** @private */\n  _ensureScrolledToIndex(index) {\n    const targetRowInDom = [...this.$.items.children].find(child => child.index === index);\n    if (!targetRowInDom) {\n      this.scrollToIndex(index);\n    } else {\n      this.__scrollIntoViewport(index);\n    }\n  }\n\n  /** @private */\n  __isRowExpandable(row) {\n    if (this.itemHasChildrenPath) {\n      const item = row._item;\n      return item && get(this.itemHasChildrenPath, item) && !this._isExpanded(item);\n    }\n  }\n\n  /** @private */\n  __isRowCollapsible(row) {\n    return this._isExpanded(row._item);\n  }\n\n  /** @private */\n  __isDetailsCell(element) {\n    return element.matches('[part~=\"details-cell\"]');\n  }\n\n  /** @private */\n  __isCell(element) {\n    return element instanceof HTMLTableCellElement;\n  }\n\n  /** @private */\n  __isRow(element) {\n    return element instanceof HTMLTableRowElement;\n  }\n\n  /** @private */\n  __getIndexOfChildElement(el) {\n    return Array.prototype.indexOf.call(el.parentNode.children, el);\n  }\n\n  /** @private */\n  _onNavigationKeyDown(e, key) {\n    e.preventDefault();\n    const visibleItemsCount = this._lastVisibleIndex - this._firstVisibleIndex - 1;\n    const isRTL = this.__isRTL;\n\n    // Handle keyboard interaction as defined in:\n    // https://w3c.github.io/aria-practices/#keyboard-interaction-24\n\n    let dx = 0,\n      dy = 0;\n    switch (key) {\n      case 'ArrowRight':\n        dx = isRTL ? -1 : 1;\n        break;\n      case 'ArrowLeft':\n        dx = isRTL ? 1 : -1;\n        break;\n      case 'Home':\n        if (this.__rowFocusMode) {\n          // \"If focus is on a row, moves focus to the first row. If focus is in the first row, focus does not move.\"\n          dy = -Infinity;\n        } else if (e.ctrlKey) {\n          // \"If focus is on a cell, moves focus to the first cell in the column. If focus is in the first row, focus does not move.\"\n          dy = -Infinity;\n        } else {\n          // \"If focus is on a cell, moves focus to the first cell in the row. If focus is in the first cell of the row, focus does not move.\"\n          dx = -Infinity;\n        }\n        break;\n      case 'End':\n        if (this.__rowFocusMode) {\n          // \"If focus is on a row, moves focus to the last row. If focus is in the last row, focus does not move.\"\n          dy = Infinity;\n        } else if (e.ctrlKey) {\n          // \"If focus is on a cell, moves focus to the last cell in the column. If focus is in the last row, focus does not move.\"\n          dy = Infinity;\n        } else {\n          // \"If focus is on a cell, moves focus to the last cell in the row. If focus is in the last cell of the row, focus does not move.\"\n          dx = Infinity;\n        }\n        break;\n      case 'ArrowDown':\n        dy = 1;\n        break;\n      case 'ArrowUp':\n        dy = -1;\n        break;\n      case 'PageDown':\n        dy = visibleItemsCount;\n        break;\n      case 'PageUp':\n        dy = -visibleItemsCount;\n        break;\n      default:\n        break;\n    }\n    const activeRow = e.composedPath().find(el => this.__isRow(el));\n    const activeCell = e.composedPath().find(el => this.__isCell(el));\n    if (this.__rowFocusMode && !activeRow || !this.__rowFocusMode && !activeCell) {\n      // When using a screen reader, it's possible that neither a cell nor a row is focused.\n      return;\n    }\n    const forwardsKey = isRTL ? 'ArrowLeft' : 'ArrowRight';\n    const backwardsKey = isRTL ? 'ArrowRight' : 'ArrowLeft';\n    if (key === forwardsKey) {\n      // \"Right Arrow:\"\n      if (this.__rowFocusMode) {\n        // In row focus mode\n        if (this.__isRowExpandable(activeRow)) {\n          // \"If focus is on a collapsed row, expands the row.\"\n          this.expandItem(activeRow._item);\n          return;\n        }\n        // \"If focus is on an expanded row or is on a row that does not have child rows,\n        // moves focus to the first cell in the row.\"\n        this.__rowFocusMode = false;\n        this._onCellNavigation(activeRow.firstElementChild, 0, 0);\n        return;\n      }\n    } else if (key === backwardsKey) {\n      // \"Left Arrow:\"\n      if (this.__rowFocusMode) {\n        // In row focus mode\n        if (this.__isRowCollapsible(activeRow)) {\n          // \"If focus is on an expanded row, collapses the row.\"\n          this.collapseItem(activeRow._item);\n          return;\n        }\n      } else {\n        // In cell focus mode\n        const activeRowCells = [...activeRow.children].sort((a, b) => a._order - b._order);\n        if (activeCell === activeRowCells[0] || this.__isDetailsCell(activeCell)) {\n          // \"If focus is on the first cell in a row and row focus is supported, moves focus to the row.\"\n          this.__rowFocusMode = true;\n          this._onRowNavigation(activeRow, 0);\n          return;\n        }\n      }\n    }\n\n    // Navigate\n    if (this.__rowFocusMode) {\n      // Navigate the rows\n      this._onRowNavigation(activeRow, dy);\n    } else {\n      // Navigate the cells\n      this._onCellNavigation(activeCell, dx, dy);\n    }\n  }\n\n  /**\n   * Focuses the target row after navigating by the given dy offset.\n   * If the row is not in the viewport, it is first scrolled to.\n   * @private\n   */\n  _onRowNavigation(activeRow, dy) {\n    const {\n      dstRow\n    } = this.__navigateRows(dy, activeRow);\n    if (dstRow) {\n      dstRow.focus();\n    }\n  }\n\n  /** @private */\n  __getIndexInGroup(row, bodyFallbackIndex) {\n    const rowGroup = row.parentNode;\n    // Body rows have index property, otherwise DOM child index of the row is used.\n    if (rowGroup === this.$.items) {\n      return bodyFallbackIndex !== undefined ? bodyFallbackIndex : row.index;\n    }\n    return this.__getIndexOfChildElement(row);\n  }\n\n  /**\n   * Returns the target row after navigating by the given dy offset.\n   * Also returns information whether the details cell should be the target on the target row.\n   * If the row is not in the viewport, it is first scrolled to.\n   * @private\n   */\n  __navigateRows(dy, activeRow, activeCell) {\n    const currentRowIndex = this.__getIndexInGroup(activeRow, this._focusedItemIndex);\n    const activeRowGroup = activeRow.parentNode;\n    const maxRowIndex = (activeRowGroup === this.$.items ? this._effectiveSize : activeRowGroup.children.length) - 1;\n\n    // Index of the destination row\n    let dstRowIndex = Math.max(0, Math.min(currentRowIndex + dy, maxRowIndex));\n    if (activeRowGroup !== this.$.items) {\n      // Navigating header/footer rows\n\n      // Header and footer could have hidden rows, e. g., if none of the columns\n      // or groups on the given column tree level define template. Skip them\n      // in vertical keyboard navigation.\n      if (dstRowIndex > currentRowIndex) {\n        while (dstRowIndex < maxRowIndex && activeRowGroup.children[dstRowIndex].hidden) {\n          dstRowIndex += 1;\n        }\n      } else if (dstRowIndex < currentRowIndex) {\n        while (dstRowIndex > 0 && activeRowGroup.children[dstRowIndex].hidden) {\n          dstRowIndex -= 1;\n        }\n      }\n      this.toggleAttribute('navigating', true);\n      return {\n        dstRow: activeRowGroup.children[dstRowIndex]\n      };\n    }\n    // Navigating body rows\n\n    let dstIsRowDetails = false;\n    if (activeCell) {\n      const isRowDetails = this.__isDetailsCell(activeCell);\n      // Row details navigation logic\n      if (activeRowGroup === this.$.items) {\n        const item = activeRow._item;\n        const dstItem = this._cache.getItemForIndex(dstRowIndex);\n        // Should we navigate to row details?\n        if (isRowDetails) {\n          dstIsRowDetails = dy === 0;\n        } else {\n          dstIsRowDetails = dy === 1 && this._isDetailsOpened(item) || dy === -1 && dstRowIndex !== currentRowIndex && this._isDetailsOpened(dstItem);\n        }\n        // Should we navigate between details and regular cells of the same row?\n        if (dstIsRowDetails !== isRowDetails && (dy === 1 && dstIsRowDetails || dy === -1 && !dstIsRowDetails)) {\n          dstRowIndex = currentRowIndex;\n        }\n      }\n    }\n\n    // Ensure correct vertical scroll position, destination row is visible\n    this._ensureScrolledToIndex(dstRowIndex);\n\n    // When scrolling with repeated keydown, sometimes FocusEvent listeners\n    // are too late to update _focusedItemIndex. Ensure next keydown\n    // listener invocation gets updated _focusedItemIndex value.\n    this._focusedItemIndex = dstRowIndex;\n\n    // This has to be set after scrolling, otherwise it can be removed by\n    // `_preventScrollerRotatingCellFocus(row, index)` during scrolling.\n    this.toggleAttribute('navigating', true);\n    return {\n      dstRow: [...activeRowGroup.children].find(el => !el.hidden && el.index === dstRowIndex),\n      dstIsRowDetails\n    };\n  }\n\n  /**\n   * Focuses the target cell after navigating by the given dx and dy offset.\n   * If the cell is not in the viewport, it is first scrolled to.\n   * @private\n   */\n  _onCellNavigation(activeCell, dx, dy) {\n    const activeRow = activeCell.parentNode;\n    const {\n      dstRow,\n      dstIsRowDetails\n    } = this.__navigateRows(dy, activeRow, activeCell);\n    if (!dstRow) {\n      return;\n    }\n    let columnIndex = this.__getIndexOfChildElement(activeCell);\n    if (this.$.items.contains(activeCell)) {\n      // lazy column rendering may be enabled, so we need use the always visible sizer cells to find the column index\n      columnIndex = [...this.$.sizer.children].findIndex(sizerCell => sizerCell._column === activeCell._column);\n    }\n    const isCurrentCellRowDetails = this.__isDetailsCell(activeCell);\n    const activeRowGroup = activeRow.parentNode;\n    const currentRowIndex = this.__getIndexInGroup(activeRow, this._focusedItemIndex);\n\n    // _focusedColumnOrder is memoized - this is to ensure predictable\n    // navigation when entering and leaving detail and column group cells.\n    if (this._focusedColumnOrder === undefined) {\n      if (isCurrentCellRowDetails) {\n        this._focusedColumnOrder = 0;\n      } else {\n        this._focusedColumnOrder = this._getColumns(activeRowGroup, currentRowIndex).filter(c => !c.hidden)[columnIndex]._order;\n      }\n    }\n    if (dstIsRowDetails) {\n      // Focusing a row details cell on the destination row\n      const dstCell = [...dstRow.children].find(el => this.__isDetailsCell(el));\n      dstCell.focus();\n    } else {\n      // Focusing a regular cell on the destination row\n\n      // Find orderedColumnIndex - the index of order closest matching the\n      // original _focusedColumnOrder in the sorted array of orders\n      // of the visible columns on the destination row.\n      const dstRowIndex = this.__getIndexInGroup(dstRow, this._focusedItemIndex);\n      const dstColumns = this._getColumns(activeRowGroup, dstRowIndex).filter(c => !c.hidden);\n      const dstSortedColumnOrders = dstColumns.map(c => c._order).sort((b, a) => b - a);\n      const maxOrderedColumnIndex = dstSortedColumnOrders.length - 1;\n      const orderedColumnIndex = dstSortedColumnOrders.indexOf(dstSortedColumnOrders.slice(0).sort((b, a) => Math.abs(b - this._focusedColumnOrder) - Math.abs(a - this._focusedColumnOrder))[0]);\n\n      // Index of the destination column order\n      const dstOrderedColumnIndex = dy === 0 && isCurrentCellRowDetails ? orderedColumnIndex : Math.max(0, Math.min(orderedColumnIndex + dx, maxOrderedColumnIndex));\n      if (dstOrderedColumnIndex !== orderedColumnIndex) {\n        // Horizontal movement invalidates stored _focusedColumnOrder\n        this._focusedColumnOrder = undefined;\n      }\n      const columnIndexByOrder = dstColumns.reduce((acc, col, i) => {\n        acc[col._order] = i;\n        return acc;\n      }, {});\n      const dstColumnIndex = columnIndexByOrder[dstSortedColumnOrders[dstOrderedColumnIndex]];\n      let dstCell;\n      if (this.$.items.contains(activeCell)) {\n        const dstSizerCell = this.$.sizer.children[dstColumnIndex];\n        if (this._lazyColumns) {\n          // If the column is not in the viewport, scroll it into view.\n          if (!this.__isColumnInViewport(dstSizerCell._column)) {\n            dstSizerCell.scrollIntoView();\n          }\n          this.__updateColumnsBodyContentHidden();\n          this.__updateHorizontalScrollPosition();\n        }\n        dstCell = [...dstRow.children].find(cell => cell._column === dstSizerCell._column);\n        // Ensure correct horizontal scroll position once the destination cell is available.\n        this._scrollHorizontallyToCell(dstCell);\n      } else {\n        dstCell = dstRow.children[dstColumnIndex];\n        this._scrollHorizontallyToCell(dstCell);\n      }\n      dstCell.focus();\n    }\n  }\n\n  /** @private */\n  _onInteractionKeyDown(e, key) {\n    const localTarget = e.composedPath()[0];\n    const localTargetIsTextInput = localTarget.localName === 'input' && !/^(button|checkbox|color|file|image|radio|range|reset|submit)$/iu.test(localTarget.type);\n    let wantInteracting;\n    switch (key) {\n      case 'Enter':\n        wantInteracting = this.interacting ? !localTargetIsTextInput : true;\n        break;\n      case 'Escape':\n        wantInteracting = false;\n        break;\n      case 'F2':\n        wantInteracting = !this.interacting;\n        break;\n      default:\n        break;\n    }\n    const {\n      cell\n    } = this._getGridEventLocation(e);\n    if (this.interacting !== wantInteracting && cell !== null) {\n      if (wantInteracting) {\n        const focusTarget = cell._content.querySelector('[focus-target]') ||\n        // If a child element hasn't been explicitly marked as a focus target,\n        // fall back to any focusable element inside the cell.\n        [...cell._content.querySelectorAll('*')].find(node => this._isFocusable(node));\n        if (focusTarget) {\n          e.preventDefault();\n          focusTarget.focus();\n          this._setInteracting(true);\n          this.toggleAttribute('navigating', false);\n        }\n      } else {\n        e.preventDefault();\n        this._focusedColumnOrder = undefined;\n        cell.focus();\n        this._setInteracting(false);\n        this.toggleAttribute('navigating', true);\n      }\n    }\n    if (key === 'Escape') {\n      this._hideTooltip(true);\n    }\n  }\n\n  /** @private */\n  _predictFocusStepTarget(srcElement, step) {\n    const tabOrder = [this.$.table, this._headerFocusable, this._itemsFocusable, this._footerFocusable, this.$.focusexit];\n    let index = tabOrder.indexOf(srcElement);\n    index += step;\n    while (index >= 0 && index <= tabOrder.length - 1) {\n      let rowElement = tabOrder[index];\n      if (rowElement && !this.__rowFocusMode) {\n        rowElement = tabOrder[index].parentNode;\n      }\n      if (!rowElement || rowElement.hidden) {\n        index += step;\n      } else {\n        break;\n      }\n    }\n    let focusStepTarget = tabOrder[index];\n\n    // If the target focusable is tied to a column that is not visible,\n    // find the first visible column and update the target in order to\n    // prevent scrolling to the start of the row.\n    if (focusStepTarget && !this.__isHorizontallyInViewport(focusStepTarget)) {\n      const firstVisibleColumn = this._getColumnsInOrder().find(column => this.__isColumnInViewport(column));\n      if (firstVisibleColumn) {\n        if (focusStepTarget === this._headerFocusable) {\n          focusStepTarget = firstVisibleColumn._headerCell;\n        } else if (focusStepTarget === this._itemsFocusable) {\n          const rowIndex = focusStepTarget._column._cells.indexOf(focusStepTarget);\n          focusStepTarget = firstVisibleColumn._cells[rowIndex];\n        } else if (focusStepTarget === this._footerFocusable) {\n          focusStepTarget = firstVisibleColumn._footerCell;\n        }\n      }\n    }\n    return focusStepTarget;\n  }\n\n  /** @private */\n  _onTabKeyDown(e) {\n    const focusTarget = this._predictFocusStepTarget(e.composedPath()[0], e.shiftKey ? -1 : 1);\n\n    // Can be undefined if grid has tabindex\n    if (!focusTarget) {\n      return;\n    }\n\n    // Prevent focus-trap logic from intercepting the event.\n    e.stopPropagation();\n    if (focusTarget === this.$.table) {\n      // The focus is about to exit the grid to the top.\n      this.$.table.focus();\n    } else if (focusTarget === this.$.focusexit) {\n      // The focus is about to exit the grid to the bottom.\n      this.$.focusexit.focus();\n    } else if (focusTarget === this._itemsFocusable) {\n      let itemsFocusTarget = focusTarget;\n      const targetRow = this.__isRow(focusTarget) ? focusTarget : focusTarget.parentNode;\n      this._ensureScrolledToIndex(this._focusedItemIndex);\n      if (targetRow.index !== this._focusedItemIndex && this.__isCell(focusTarget)) {\n        // The target row, which is about to be focused next, has been\n        // assigned with a new index since last focus, probably because of\n        // scrolling. Focus the row for the stored focused item index instead.\n        const columnIndex = Array.from(targetRow.children).indexOf(this._itemsFocusable);\n        const focusedItemRow = Array.from(this.$.items.children).find(row => !row.hidden && row.index === this._focusedItemIndex);\n        if (focusedItemRow) {\n          itemsFocusTarget = focusedItemRow.children[columnIndex];\n        }\n      }\n      e.preventDefault();\n      itemsFocusTarget.focus();\n    } else {\n      e.preventDefault();\n      focusTarget.focus();\n    }\n    this.toggleAttribute('navigating', true);\n  }\n\n  /** @private */\n  _onSpaceKeyDown(e) {\n    e.preventDefault();\n    const element = e.composedPath()[0];\n    const isRow = this.__isRow(element);\n    if (isRow || !element._content || !element._content.firstElementChild) {\n      this.dispatchEvent(new CustomEvent(isRow ? 'row-activate' : 'cell-activate', {\n        detail: {\n          model: this.__getRowModel(isRow ? element : element.parentElement)\n        }\n      }));\n    }\n  }\n\n  /** @private */\n  _onKeyUp(e) {\n    if (!/^( |SpaceBar)$/u.test(e.key) || this.interacting) {\n      return;\n    }\n    e.preventDefault();\n    const cell = e.composedPath()[0];\n    if (cell._content && cell._content.firstElementChild) {\n      const wasNavigating = this.hasAttribute('navigating');\n      cell._content.firstElementChild.dispatchEvent(new MouseEvent('click', {\n        shiftKey: e.shiftKey,\n        bubbles: true,\n        composed: true,\n        cancelable: true\n      }));\n      this.toggleAttribute('navigating', wasNavigating);\n    }\n  }\n\n  /**\n   * @param {!FocusEvent} e\n   * @protected\n   */\n  _onFocusIn(e) {\n    if (!this._isMousedown) {\n      this.toggleAttribute('navigating', true);\n    }\n    const rootTarget = e.composedPath()[0];\n    if (rootTarget === this.$.table || rootTarget === this.$.focusexit) {\n      // The focus enters the top (bottom) of the grid, meaning that user has\n      // tabbed (shift-tabbed) into the grid. Move the focus to\n      // the first (the last) focusable.\n      this._predictFocusStepTarget(rootTarget, rootTarget === this.$.table ? 1 : -1).focus();\n      this._setInteracting(false);\n    } else {\n      this._detectInteracting(e);\n    }\n  }\n\n  /**\n   * @param {!FocusEvent} e\n   * @protected\n   */\n  _onFocusOut(e) {\n    this.toggleAttribute('navigating', false);\n    this._detectInteracting(e);\n    this._hideTooltip();\n    this._focusedCell = null;\n  }\n\n  /** @private */\n  _onContentFocusIn(e) {\n    const {\n      section,\n      cell,\n      row\n    } = this._getGridEventLocation(e);\n    if (!cell && !this.__rowFocusMode) {\n      return;\n    }\n    this._detectInteracting(e);\n    if (section && (cell || row)) {\n      this._activeRowGroup = section;\n      if (this.$.header === section) {\n        this._headerFocusable = this.__getFocusable(row, cell);\n      } else if (this.$.items === section) {\n        this._itemsFocusable = this.__getFocusable(row, cell);\n      } else if (this.$.footer === section) {\n        this._footerFocusable = this.__getFocusable(row, cell);\n      }\n      if (cell) {\n        const context = this.getEventContext(e);\n        this.__pendingBodyCellFocus = this.loading && context.section === 'body';\n        if (!this.__pendingBodyCellFocus) {\n          // Fire a cell-focus event for the cell\n          cell.dispatchEvent(new CustomEvent('cell-focus', {\n            bubbles: true,\n            composed: true,\n            detail: {\n              context\n            }\n          }));\n        }\n        this._focusedCell = cell._focusButton || cell;\n        if (isKeyboardActive() && e.target === cell) {\n          this._showTooltip(e);\n        }\n      } else {\n        this._focusedCell = null;\n      }\n    }\n    this._detectFocusedItemIndex(e);\n  }\n\n  /**\n   * @private\n   */\n  __dispatchPendingBodyCellFocus() {\n    // If the body cell focus was pending, dispatch the event once loading is done\n    if (this.__pendingBodyCellFocus && this.shadowRoot.activeElement === this._itemsFocusable) {\n      this._itemsFocusable.dispatchEvent(new Event('focusin', {\n        bubbles: true,\n        composed: true\n      }));\n    }\n  }\n\n  /**\n   * Get the focusable element depending on the current focus mode.\n   * It can be a row, a cell, or a focusable div inside a cell.\n   *\n   * @param {HTMLElement} row\n   * @param {HTMLElement} cell\n   * @return {HTMLElement}\n   * @private\n   */\n  __getFocusable(row, cell) {\n    return this.__rowFocusMode ? row : cell._focusButton || cell;\n  }\n\n  /**\n   * Enables interaction mode if a cells descendant receives focus or keyboard\n   * input. Disables it if the event is not related to cell content.\n   * @param {!KeyboardEvent|!FocusEvent} e\n   * @private\n   */\n  _detectInteracting(e) {\n    const isInteracting = e.composedPath().some(el => el.localName === 'vaadin-grid-cell-content');\n    this._setInteracting(isInteracting);\n    this.__updateHorizontalScrollPosition();\n  }\n\n  /** @private */\n  _detectFocusedItemIndex(e) {\n    const {\n      section,\n      row\n    } = this._getGridEventLocation(e);\n    if (section === this.$.items) {\n      this._focusedItemIndex = row.index;\n    }\n  }\n\n  /**\n   * Enables or disables the focus target of the containing section of the\n   * grid from receiving focus, based on whether the user is interacting with\n   * that section of the grid.\n   * @param {HTMLElement} focusTarget\n   * @private\n   */\n  _updateGridSectionFocusTarget(focusTarget) {\n    if (!focusTarget) {\n      return;\n    }\n    const section = this._getGridSectionFromFocusTarget(focusTarget);\n    const isInteractingWithinActiveSection = this.interacting && section === this._activeRowGroup;\n    focusTarget.tabIndex = isInteractingWithinActiveSection ? -1 : 0;\n  }\n\n  /**\n   * @param {!HTMLTableRowElement} row\n   * @param {number} index\n   * @protected\n   */\n  _preventScrollerRotatingCellFocus(row, index) {\n    if (row.index === this._focusedItemIndex && this.hasAttribute('navigating') && this._activeRowGroup === this.$.items) {\n      // Focused item has went, hide navigation mode\n      this._navigatingIsHidden = true;\n      this.toggleAttribute('navigating', false);\n    }\n    if (index === this._focusedItemIndex && this._navigatingIsHidden) {\n      // Focused item is back, restore navigation mode\n      this._navigatingIsHidden = false;\n      this.toggleAttribute('navigating', true);\n    }\n  }\n\n  /**\n   * @param {HTMLTableSectionElement=} rowGroup\n   * @param {number=} rowIndex\n   * @return {!Array<!GridColumn>}\n   * @protected\n   */\n  _getColumns(rowGroup, rowIndex) {\n    let columnTreeLevel = this._columnTree.length - 1;\n    if (rowGroup === this.$.header) {\n      columnTreeLevel = rowIndex;\n    } else if (rowGroup === this.$.footer) {\n      columnTreeLevel = this._columnTree.length - 1 - rowIndex;\n    }\n    return this._columnTree[columnTreeLevel];\n  }\n\n  /** @private */\n  __isValidFocusable(element) {\n    return this.$.table.contains(element) && element.offsetHeight;\n  }\n\n  /** @protected */\n  _resetKeyboardNavigation() {\n    // Header / footer\n    ['header', 'footer'].forEach(section => {\n      if (!this.__isValidFocusable(this[`_${section}Focusable`])) {\n        const firstVisibleRow = [...this.$[section].children].find(row => row.offsetHeight);\n        const firstVisibleCell = firstVisibleRow ? [...firstVisibleRow.children].find(cell => !cell.hidden) : null;\n        if (firstVisibleRow && firstVisibleCell) {\n          this[`_${section}Focusable`] = this.__getFocusable(firstVisibleRow, firstVisibleCell);\n        }\n      }\n    });\n\n    // Body\n    if (!this.__isValidFocusable(this._itemsFocusable) && this.$.items.firstElementChild) {\n      const firstVisibleRow = this.__getFirstVisibleItem();\n      const firstVisibleCell = firstVisibleRow ? [...firstVisibleRow.children].find(cell => !cell.hidden) : null;\n      if (firstVisibleCell && firstVisibleRow) {\n        // Reset memoized column\n        delete this._focusedColumnOrder;\n        this._itemsFocusable = this.__getFocusable(firstVisibleRow, firstVisibleCell);\n      }\n    } else {\n      this.__updateItemsFocusable();\n    }\n  }\n\n  /**\n   * @param {!HTMLElement} dstCell\n   * @protected\n   */\n  _scrollHorizontallyToCell(dstCell) {\n    if (dstCell.hasAttribute('frozen') || dstCell.hasAttribute('frozen-to-end') || this.__isDetailsCell(dstCell)) {\n      // These cells are, by design, always visible, no need to scroll.\n      return;\n    }\n    const dstCellRect = dstCell.getBoundingClientRect();\n    const dstRow = dstCell.parentNode;\n    const dstCellIndex = Array.from(dstRow.children).indexOf(dstCell);\n    const tableRect = this.$.table.getBoundingClientRect();\n    let leftBoundary = tableRect.left,\n      rightBoundary = tableRect.right;\n    for (let i = dstCellIndex - 1; i >= 0; i--) {\n      const cell = dstRow.children[i];\n      if (cell.hasAttribute('hidden') || this.__isDetailsCell(cell)) {\n        continue;\n      }\n      if (cell.hasAttribute('frozen') || cell.hasAttribute('frozen-to-end')) {\n        leftBoundary = cell.getBoundingClientRect().right;\n        break;\n      }\n    }\n    for (let i = dstCellIndex + 1; i < dstRow.children.length; i++) {\n      const cell = dstRow.children[i];\n      if (cell.hasAttribute('hidden') || this.__isDetailsCell(cell)) {\n        continue;\n      }\n      if (cell.hasAttribute('frozen') || cell.hasAttribute('frozen-to-end')) {\n        rightBoundary = cell.getBoundingClientRect().left;\n        break;\n      }\n    }\n    if (dstCellRect.left < leftBoundary) {\n      this.$.table.scrollLeft += Math.round(dstCellRect.left - leftBoundary);\n    }\n    if (dstCellRect.right > rightBoundary) {\n      this.$.table.scrollLeft += Math.round(dstCellRect.right - rightBoundary);\n    }\n  }\n\n  /**\n   * @typedef {Object} GridEventLocation\n   * @property {HTMLTableSectionElement | null} section - The table section element that the event occurred in (header, body, or footer), or null if the event did not occur in a section\n   * @property {HTMLTableRowElement | null} row - The row element that the event occurred in, or null if the event did not occur in a row\n   * @property {HTMLTableCellElement | null} cell - The cell element that the event occurred in, or null if the event did not occur in a cell\n   * @private\n   */\n  /**\n   * Takes an event and returns a location object describing in which part of the grid the event occurred.\n   * The event may either target table section, a row, a cell or contents of a cell.\n   * @param {Event} e\n   * @returns {GridEventLocation}\n   * @private\n   */\n  _getGridEventLocation(e) {\n    const path = e.composedPath();\n    const tableIndex = path.indexOf(this.$.table);\n    // Assuming ascending path to table is: [...,] th|td, tr, thead|tbody, table [,...]\n    const section = tableIndex >= 1 ? path[tableIndex - 1] : null;\n    const row = tableIndex >= 2 ? path[tableIndex - 2] : null;\n    const cell = tableIndex >= 3 ? path[tableIndex - 3] : null;\n    return {\n      section,\n      row,\n      cell\n    };\n  }\n\n  /**\n   * Helper method that maps a focus target cell to the containing grid section\n   * @param {HTMLElement} focusTarget\n   * @returns {HTMLTableSectionElement | null}\n   * @private\n   */\n  _getGridSectionFromFocusTarget(focusTarget) {\n    if (focusTarget === this._headerFocusable) {\n      return this.$.header;\n    }\n    if (focusTarget === this._itemsFocusable) {\n      return this.$.items;\n    }\n    if (focusTarget === this._footerFocusable) {\n      return this.$.footer;\n    }\n    return null;\n  }\n\n  /**\n   * Fired when a cell is focused with click or keyboard navigation.\n   *\n   * Use context property of @see {@link GridCellFocusEvent} to get detail information about the event.\n   *\n   * @event cell-focus\n   */\n};","map":{"version":3,"names":["isKeyboardActive","addValueToAttribute","removeValueFromAttribute","get","KeyboardNavigationMixin","superClass","properties","_headerFocusable","type","Object","observer","_itemsFocusable","_footerFocusable","_navigatingIsHidden","Boolean","_focusedItemIndex","Number","value","_focusedColumnOrder","_focusedCell","interacting","reflectToAttribute","readOnly","__rowFocusMode","__isRow","forEach","prop","focusable","parent","parentElement","__isCell","cell","firstElementChild","_focusButton","ready","_ios","_android","addEventListener","_onKeyDown","_onKeyUp","_onFocusIn","_onFocusOut","$","table","_onContentFocusIn","bind","toggleAttribute","_isMousedown","undefined","_focusableChanged","oldFocusable","setAttribute","_updateGridSectionFocusTarget","_focusedCellChanged","focusedCell","oldFocusedCell","_interactingChanged","__updateItemsFocusable","wasFocused","shadowRoot","activeElement","_getRenderedRows","row","index","cellIndex","children","indexOf","__getFocusable","focus","e","key","keyGroup","_detectInteracting","_ensureScrolledToIndex","targetRowInDom","items","find","child","scrollToIndex","__scrollIntoViewport","__isRowExpandable","itemHasChildrenPath","item","_item","_isExpanded","__isRowCollapsible","__isDetailsCell","element","matches","HTMLTableCellElement","HTMLTableRowElement","__getIndexOfChildElement","el","Array","prototype","call","parentNode","_onNavigationKeyDown","preventDefault","visibleItemsCount","_lastVisibleIndex","_firstVisibleIndex","isRTL","__isRTL","dx","dy","Infinity","ctrlKey","activeRow","composedPath","activeCell","forwardsKey","backwardsKey","expandItem","_onCellNavigation","collapseItem","activeRowCells","sort","a","b","_order","_onRowNavigation","dstRow","__navigateRows","__getIndexInGroup","bodyFallbackIndex","rowGroup","currentRowIndex","activeRowGroup","maxRowIndex","_effectiveSize","length","dstRowIndex","Math","max","min","hidden","dstIsRowDetails","isRowDetails","dstItem","_cache","getItemForIndex","_isDetailsOpened","columnIndex","contains","sizer","findIndex","sizerCell","_column","isCurrentCellRowDetails","_getColumns","filter","c","dstCell","dstColumns","dstSortedColumnOrders","map","maxOrderedColumnIndex","orderedColumnIndex","slice","abs","dstOrderedColumnIndex","columnIndexByOrder","reduce","acc","col","i","dstColumnIndex","dstSizerCell","_lazyColumns","__isColumnInViewport","scrollIntoView","__updateColumnsBodyContentHidden","__updateHorizontalScrollPosition","_scrollHorizontallyToCell","_onInteractionKeyDown","localTarget","localTargetIsTextInput","localName","test","wantInteracting","_getGridEventLocation","focusTarget","_content","querySelector","querySelectorAll","node","_isFocusable","_setInteracting","_hideTooltip","_predictFocusStepTarget","srcElement","step","tabOrder","focusexit","rowElement","focusStepTarget","__isHorizontallyInViewport","firstVisibleColumn","_getColumnsInOrder","column","_headerCell","rowIndex","_cells","_footerCell","_onTabKeyDown","shiftKey","stopPropagation","itemsFocusTarget","targetRow","from","focusedItemRow","_onSpaceKeyDown","isRow","dispatchEvent","CustomEvent","detail","model","__getRowModel","wasNavigating","hasAttribute","MouseEvent","bubbles","composed","cancelable","rootTarget","section","_activeRowGroup","header","footer","context","getEventContext","__pendingBodyCellFocus","loading","target","_showTooltip","_detectFocusedItemIndex","__dispatchPendingBodyCellFocus","Event","isInteracting","some","_getGridSectionFromFocusTarget","isInteractingWithinActiveSection","tabIndex","_preventScrollerRotatingCellFocus","columnTreeLevel","_columnTree","__isValidFocusable","offsetHeight","_resetKeyboardNavigation","firstVisibleRow","firstVisibleCell","__getFirstVisibleItem","dstCellRect","getBoundingClientRect","dstCellIndex","tableRect","leftBoundary","left","rightBoundary","right","scrollLeft","round","path","tableIndex"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@vaadin/grid/src/vaadin-grid-keyboard-navigation-mixin.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2016 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { isKeyboardActive } from '@vaadin/a11y-base/src/focus-utils.js';\nimport { addValueToAttribute, removeValueFromAttribute } from '@vaadin/component-base/src/dom-utils.js';\nimport { get } from '@vaadin/component-base/src/path-utils.js';\n\n/**\n * @polymerMixin\n */\nexport const KeyboardNavigationMixin = (superClass) =>\n  class KeyboardNavigationMixin extends superClass {\n    static get properties() {\n      return {\n        /** @private */\n        _headerFocusable: {\n          type: Object,\n          observer: '_focusableChanged',\n        },\n\n        /**\n         * @type {!HTMLElement | undefined}\n         * @protected\n         */\n        _itemsFocusable: {\n          type: Object,\n          observer: '_focusableChanged',\n        },\n\n        /** @private */\n        _footerFocusable: {\n          type: Object,\n          observer: '_focusableChanged',\n        },\n\n        /** @private */\n        _navigatingIsHidden: Boolean,\n\n        /**\n         * @type {number}\n         * @protected\n         */\n        _focusedItemIndex: {\n          type: Number,\n          value: 0,\n        },\n\n        /** @private */\n        _focusedColumnOrder: Number,\n\n        /** @private */\n        _focusedCell: {\n          type: Object,\n          observer: '_focusedCellChanged',\n        },\n\n        /**\n         * Indicates whether the grid is currently in interaction mode.\n         * In interaction mode the user is currently interacting with a control,\n         * such as an input or a select, within a cell.\n         * In interaction mode keyboard navigation between cells is disabled.\n         * Interaction mode also prevents the focus target cell of that section of\n         * the grid from receiving focus, allowing the user to switch focus to\n         * controls in adjacent cells, rather than focussing the outer cell\n         * itself.\n         * @type {boolean}\n         * @private\n         */\n        interacting: {\n          type: Boolean,\n          value: false,\n          reflectToAttribute: true,\n          readOnly: true,\n          observer: '_interactingChanged',\n        },\n      };\n    }\n\n    /** @private */\n    get __rowFocusMode() {\n      return (\n        this.__isRow(this._itemsFocusable) || this.__isRow(this._headerFocusable) || this.__isRow(this._footerFocusable)\n      );\n    }\n\n    set __rowFocusMode(value) {\n      ['_itemsFocusable', '_footerFocusable', '_headerFocusable'].forEach((prop) => {\n        const focusable = this[prop];\n        if (value) {\n          const parent = focusable && focusable.parentElement;\n          if (this.__isCell(focusable)) {\n            // Cell itself focusable (default)\n            this[prop] = parent;\n          } else if (this.__isCell(parent)) {\n            // Focus button mode is enabled for the column,\n            // button element inside the cell is focusable.\n            this[prop] = parent.parentElement;\n          }\n        } else if (!value && this.__isRow(focusable)) {\n          const cell = focusable.firstElementChild;\n          this[prop] = cell._focusButton || cell;\n        }\n      });\n    }\n\n    /** @protected */\n    ready() {\n      super.ready();\n\n      if (this._ios || this._android) {\n        // Disable keyboard navigation on mobile devices\n        return;\n      }\n\n      this.addEventListener('keydown', this._onKeyDown);\n      this.addEventListener('keyup', this._onKeyUp);\n\n      this.addEventListener('focusin', this._onFocusIn);\n      this.addEventListener('focusout', this._onFocusOut);\n\n      // When focus goes from cell to another cell, focusin/focusout events do\n      // not escape the grid's shadowRoot, thus listening inside the shadowRoot.\n      this.$.table.addEventListener('focusin', this._onContentFocusIn.bind(this));\n\n      this.addEventListener('mousedown', () => {\n        this.toggleAttribute('navigating', false);\n        this._isMousedown = true;\n\n        // Reset stored order when moving focus with mouse.\n        this._focusedColumnOrder = undefined;\n      });\n      this.addEventListener('mouseup', () => {\n        this._isMousedown = false;\n      });\n    }\n\n    /** @private */\n    _focusableChanged(focusable, oldFocusable) {\n      if (oldFocusable) {\n        oldFocusable.setAttribute('tabindex', '-1');\n      }\n      if (focusable) {\n        this._updateGridSectionFocusTarget(focusable);\n      }\n    }\n\n    /** @private */\n    _focusedCellChanged(focusedCell, oldFocusedCell) {\n      if (oldFocusedCell) {\n        removeValueFromAttribute(oldFocusedCell, 'part', 'focused-cell');\n      }\n\n      if (focusedCell) {\n        addValueToAttribute(focusedCell, 'part', 'focused-cell');\n      }\n    }\n\n    /** @private */\n    _interactingChanged() {\n      // Update focus targets when entering / exiting interaction mode\n      this._updateGridSectionFocusTarget(this._headerFocusable);\n      this._updateGridSectionFocusTarget(this._itemsFocusable);\n      this._updateGridSectionFocusTarget(this._footerFocusable);\n    }\n\n    /**\n     * Since the focused cell/row state is stored as an element reference, the reference may get\n     * out of sync when the virtual indexes for elements update due to effective size change.\n     * This function updates the reference to the correct element after a possible index change.\n     * @private\n     */\n    __updateItemsFocusable() {\n      if (!this._itemsFocusable) {\n        return;\n      }\n\n      const wasFocused = this.shadowRoot.activeElement === this._itemsFocusable;\n\n      this._getRenderedRows().forEach((row) => {\n        if (row.index === this._focusedItemIndex) {\n          if (this.__rowFocusMode) {\n            // Row focus mode\n            this._itemsFocusable = row;\n          } else {\n            // Cell focus mode\n            let parent = this._itemsFocusable.parentElement;\n            let cell = this._itemsFocusable;\n\n            if (parent) {\n              // Focus button mode is enabled for the column,\n              // button element inside the cell is focusable.\n              if (this.__isCell(parent)) {\n                cell = parent;\n                parent = parent.parentElement;\n              }\n\n              const cellIndex = [...parent.children].indexOf(cell);\n              this._itemsFocusable = this.__getFocusable(row, row.children[cellIndex]);\n            }\n          }\n        }\n      });\n\n      if (wasFocused) {\n        this._itemsFocusable.focus();\n      }\n    }\n\n    /**\n     * @param {!KeyboardEvent} e\n     * @protected\n     */\n    _onKeyDown(e) {\n      const key = e.key;\n\n      let keyGroup;\n      switch (key) {\n        case 'ArrowUp':\n        case 'ArrowDown':\n        case 'ArrowLeft':\n        case 'ArrowRight':\n        case 'PageUp':\n        case 'PageDown':\n        case 'Home':\n        case 'End':\n          keyGroup = 'Navigation';\n          break;\n        case 'Enter':\n        case 'Escape':\n        case 'F2':\n          keyGroup = 'Interaction';\n          break;\n        case 'Tab':\n          keyGroup = 'Tab';\n          break;\n        case ' ':\n          keyGroup = 'Space';\n          break;\n        default:\n          break;\n      }\n\n      this._detectInteracting(e);\n      if (this.interacting && keyGroup !== 'Interaction') {\n        // When in the interacting mode, only the \"Interaction\" keys are handled.\n        keyGroup = undefined;\n      }\n\n      if (keyGroup) {\n        this[`_on${keyGroup}KeyDown`](e, key);\n      }\n    }\n\n    /** @private */\n    _ensureScrolledToIndex(index) {\n      const targetRowInDom = [...this.$.items.children].find((child) => child.index === index);\n      if (!targetRowInDom) {\n        this.scrollToIndex(index);\n      } else {\n        this.__scrollIntoViewport(index);\n      }\n    }\n\n    /** @private */\n    __isRowExpandable(row) {\n      if (this.itemHasChildrenPath) {\n        const item = row._item;\n        return item && get(this.itemHasChildrenPath, item) && !this._isExpanded(item);\n      }\n    }\n\n    /** @private */\n    __isRowCollapsible(row) {\n      return this._isExpanded(row._item);\n    }\n\n    /** @private */\n    __isDetailsCell(element) {\n      return element.matches('[part~=\"details-cell\"]');\n    }\n\n    /** @private */\n    __isCell(element) {\n      return element instanceof HTMLTableCellElement;\n    }\n\n    /** @private */\n    __isRow(element) {\n      return element instanceof HTMLTableRowElement;\n    }\n\n    /** @private */\n    __getIndexOfChildElement(el) {\n      return Array.prototype.indexOf.call(el.parentNode.children, el);\n    }\n\n    /** @private */\n    _onNavigationKeyDown(e, key) {\n      e.preventDefault();\n\n      const visibleItemsCount = this._lastVisibleIndex - this._firstVisibleIndex - 1;\n      const isRTL = this.__isRTL;\n\n      // Handle keyboard interaction as defined in:\n      // https://w3c.github.io/aria-practices/#keyboard-interaction-24\n\n      let dx = 0,\n        dy = 0;\n      switch (key) {\n        case 'ArrowRight':\n          dx = isRTL ? -1 : 1;\n          break;\n        case 'ArrowLeft':\n          dx = isRTL ? 1 : -1;\n          break;\n        case 'Home':\n          if (this.__rowFocusMode) {\n            // \"If focus is on a row, moves focus to the first row. If focus is in the first row, focus does not move.\"\n            dy = -Infinity;\n          } else if (e.ctrlKey) {\n            // \"If focus is on a cell, moves focus to the first cell in the column. If focus is in the first row, focus does not move.\"\n            dy = -Infinity;\n          } else {\n            // \"If focus is on a cell, moves focus to the first cell in the row. If focus is in the first cell of the row, focus does not move.\"\n            dx = -Infinity;\n          }\n          break;\n        case 'End':\n          if (this.__rowFocusMode) {\n            // \"If focus is on a row, moves focus to the last row. If focus is in the last row, focus does not move.\"\n            dy = Infinity;\n          } else if (e.ctrlKey) {\n            // \"If focus is on a cell, moves focus to the last cell in the column. If focus is in the last row, focus does not move.\"\n            dy = Infinity;\n          } else {\n            // \"If focus is on a cell, moves focus to the last cell in the row. If focus is in the last cell of the row, focus does not move.\"\n            dx = Infinity;\n          }\n          break;\n        case 'ArrowDown':\n          dy = 1;\n          break;\n        case 'ArrowUp':\n          dy = -1;\n          break;\n        case 'PageDown':\n          dy = visibleItemsCount;\n          break;\n        case 'PageUp':\n          dy = -visibleItemsCount;\n          break;\n        default:\n          break;\n      }\n\n      const activeRow = e.composedPath().find((el) => this.__isRow(el));\n      const activeCell = e.composedPath().find((el) => this.__isCell(el));\n\n      if ((this.__rowFocusMode && !activeRow) || (!this.__rowFocusMode && !activeCell)) {\n        // When using a screen reader, it's possible that neither a cell nor a row is focused.\n        return;\n      }\n\n      const forwardsKey = isRTL ? 'ArrowLeft' : 'ArrowRight';\n      const backwardsKey = isRTL ? 'ArrowRight' : 'ArrowLeft';\n      if (key === forwardsKey) {\n        // \"Right Arrow:\"\n        if (this.__rowFocusMode) {\n          // In row focus mode\n          if (this.__isRowExpandable(activeRow)) {\n            // \"If focus is on a collapsed row, expands the row.\"\n            this.expandItem(activeRow._item);\n            return;\n          }\n          // \"If focus is on an expanded row or is on a row that does not have child rows,\n          // moves focus to the first cell in the row.\"\n          this.__rowFocusMode = false;\n          this._onCellNavigation(activeRow.firstElementChild, 0, 0);\n          return;\n        }\n      } else if (key === backwardsKey) {\n        // \"Left Arrow:\"\n        if (this.__rowFocusMode) {\n          // In row focus mode\n          if (this.__isRowCollapsible(activeRow)) {\n            // \"If focus is on an expanded row, collapses the row.\"\n            this.collapseItem(activeRow._item);\n            return;\n          }\n        } else {\n          // In cell focus mode\n          const activeRowCells = [...activeRow.children].sort((a, b) => a._order - b._order);\n          if (activeCell === activeRowCells[0] || this.__isDetailsCell(activeCell)) {\n            // \"If focus is on the first cell in a row and row focus is supported, moves focus to the row.\"\n            this.__rowFocusMode = true;\n            this._onRowNavigation(activeRow, 0);\n            return;\n          }\n        }\n      }\n\n      // Navigate\n      if (this.__rowFocusMode) {\n        // Navigate the rows\n        this._onRowNavigation(activeRow, dy);\n      } else {\n        // Navigate the cells\n        this._onCellNavigation(activeCell, dx, dy);\n      }\n    }\n\n    /**\n     * Focuses the target row after navigating by the given dy offset.\n     * If the row is not in the viewport, it is first scrolled to.\n     * @private\n     */\n    _onRowNavigation(activeRow, dy) {\n      const { dstRow } = this.__navigateRows(dy, activeRow);\n\n      if (dstRow) {\n        dstRow.focus();\n      }\n    }\n\n    /** @private */\n    __getIndexInGroup(row, bodyFallbackIndex) {\n      const rowGroup = row.parentNode;\n      // Body rows have index property, otherwise DOM child index of the row is used.\n      if (rowGroup === this.$.items) {\n        return bodyFallbackIndex !== undefined ? bodyFallbackIndex : row.index;\n      }\n      return this.__getIndexOfChildElement(row);\n    }\n\n    /**\n     * Returns the target row after navigating by the given dy offset.\n     * Also returns information whether the details cell should be the target on the target row.\n     * If the row is not in the viewport, it is first scrolled to.\n     * @private\n     */\n    __navigateRows(dy, activeRow, activeCell) {\n      const currentRowIndex = this.__getIndexInGroup(activeRow, this._focusedItemIndex);\n      const activeRowGroup = activeRow.parentNode;\n      const maxRowIndex = (activeRowGroup === this.$.items ? this._effectiveSize : activeRowGroup.children.length) - 1;\n\n      // Index of the destination row\n      let dstRowIndex = Math.max(0, Math.min(currentRowIndex + dy, maxRowIndex));\n\n      if (activeRowGroup !== this.$.items) {\n        // Navigating header/footer rows\n\n        // Header and footer could have hidden rows, e. g., if none of the columns\n        // or groups on the given column tree level define template. Skip them\n        // in vertical keyboard navigation.\n        if (dstRowIndex > currentRowIndex) {\n          while (dstRowIndex < maxRowIndex && activeRowGroup.children[dstRowIndex].hidden) {\n            dstRowIndex += 1;\n          }\n        } else if (dstRowIndex < currentRowIndex) {\n          while (dstRowIndex > 0 && activeRowGroup.children[dstRowIndex].hidden) {\n            dstRowIndex -= 1;\n          }\n        }\n\n        this.toggleAttribute('navigating', true);\n\n        return { dstRow: activeRowGroup.children[dstRowIndex] };\n      }\n      // Navigating body rows\n\n      let dstIsRowDetails = false;\n      if (activeCell) {\n        const isRowDetails = this.__isDetailsCell(activeCell);\n        // Row details navigation logic\n        if (activeRowGroup === this.$.items) {\n          const item = activeRow._item;\n          const dstItem = this._cache.getItemForIndex(dstRowIndex);\n          // Should we navigate to row details?\n          if (isRowDetails) {\n            dstIsRowDetails = dy === 0;\n          } else {\n            dstIsRowDetails =\n              (dy === 1 && this._isDetailsOpened(item)) ||\n              (dy === -1 && dstRowIndex !== currentRowIndex && this._isDetailsOpened(dstItem));\n          }\n          // Should we navigate between details and regular cells of the same row?\n          if (dstIsRowDetails !== isRowDetails && ((dy === 1 && dstIsRowDetails) || (dy === -1 && !dstIsRowDetails))) {\n            dstRowIndex = currentRowIndex;\n          }\n        }\n      }\n\n      // Ensure correct vertical scroll position, destination row is visible\n      this._ensureScrolledToIndex(dstRowIndex);\n\n      // When scrolling with repeated keydown, sometimes FocusEvent listeners\n      // are too late to update _focusedItemIndex. Ensure next keydown\n      // listener invocation gets updated _focusedItemIndex value.\n      this._focusedItemIndex = dstRowIndex;\n\n      // This has to be set after scrolling, otherwise it can be removed by\n      // `_preventScrollerRotatingCellFocus(row, index)` during scrolling.\n      this.toggleAttribute('navigating', true);\n\n      return {\n        dstRow: [...activeRowGroup.children].find((el) => !el.hidden && el.index === dstRowIndex),\n        dstIsRowDetails,\n      };\n    }\n\n    /**\n     * Focuses the target cell after navigating by the given dx and dy offset.\n     * If the cell is not in the viewport, it is first scrolled to.\n     * @private\n     */\n    _onCellNavigation(activeCell, dx, dy) {\n      const activeRow = activeCell.parentNode;\n      const { dstRow, dstIsRowDetails } = this.__navigateRows(dy, activeRow, activeCell);\n      if (!dstRow) {\n        return;\n      }\n\n      let columnIndex = this.__getIndexOfChildElement(activeCell);\n      if (this.$.items.contains(activeCell)) {\n        // lazy column rendering may be enabled, so we need use the always visible sizer cells to find the column index\n        columnIndex = [...this.$.sizer.children].findIndex((sizerCell) => sizerCell._column === activeCell._column);\n      }\n\n      const isCurrentCellRowDetails = this.__isDetailsCell(activeCell);\n      const activeRowGroup = activeRow.parentNode;\n      const currentRowIndex = this.__getIndexInGroup(activeRow, this._focusedItemIndex);\n\n      // _focusedColumnOrder is memoized - this is to ensure predictable\n      // navigation when entering and leaving detail and column group cells.\n      if (this._focusedColumnOrder === undefined) {\n        if (isCurrentCellRowDetails) {\n          this._focusedColumnOrder = 0;\n        } else {\n          this._focusedColumnOrder = this._getColumns(activeRowGroup, currentRowIndex).filter((c) => !c.hidden)[\n            columnIndex\n          ]._order;\n        }\n      }\n\n      if (dstIsRowDetails) {\n        // Focusing a row details cell on the destination row\n        const dstCell = [...dstRow.children].find((el) => this.__isDetailsCell(el));\n        dstCell.focus();\n      } else {\n        // Focusing a regular cell on the destination row\n\n        // Find orderedColumnIndex - the index of order closest matching the\n        // original _focusedColumnOrder in the sorted array of orders\n        // of the visible columns on the destination row.\n        const dstRowIndex = this.__getIndexInGroup(dstRow, this._focusedItemIndex);\n        const dstColumns = this._getColumns(activeRowGroup, dstRowIndex).filter((c) => !c.hidden);\n        const dstSortedColumnOrders = dstColumns.map((c) => c._order).sort((b, a) => b - a);\n        const maxOrderedColumnIndex = dstSortedColumnOrders.length - 1;\n        const orderedColumnIndex = dstSortedColumnOrders.indexOf(\n          dstSortedColumnOrders\n            .slice(0)\n            .sort((b, a) => Math.abs(b - this._focusedColumnOrder) - Math.abs(a - this._focusedColumnOrder))[0],\n        );\n\n        // Index of the destination column order\n        const dstOrderedColumnIndex =\n          dy === 0 && isCurrentCellRowDetails\n            ? orderedColumnIndex\n            : Math.max(0, Math.min(orderedColumnIndex + dx, maxOrderedColumnIndex));\n\n        if (dstOrderedColumnIndex !== orderedColumnIndex) {\n          // Horizontal movement invalidates stored _focusedColumnOrder\n          this._focusedColumnOrder = undefined;\n        }\n\n        const columnIndexByOrder = dstColumns.reduce((acc, col, i) => {\n          acc[col._order] = i;\n          return acc;\n        }, {});\n        const dstColumnIndex = columnIndexByOrder[dstSortedColumnOrders[dstOrderedColumnIndex]];\n\n        let dstCell;\n        if (this.$.items.contains(activeCell)) {\n          const dstSizerCell = this.$.sizer.children[dstColumnIndex];\n          if (this._lazyColumns) {\n            // If the column is not in the viewport, scroll it into view.\n            if (!this.__isColumnInViewport(dstSizerCell._column)) {\n              dstSizerCell.scrollIntoView();\n            }\n            this.__updateColumnsBodyContentHidden();\n            this.__updateHorizontalScrollPosition();\n          }\n\n          dstCell = [...dstRow.children].find((cell) => cell._column === dstSizerCell._column);\n          // Ensure correct horizontal scroll position once the destination cell is available.\n          this._scrollHorizontallyToCell(dstCell);\n        } else {\n          dstCell = dstRow.children[dstColumnIndex];\n          this._scrollHorizontallyToCell(dstCell);\n        }\n\n        dstCell.focus();\n      }\n    }\n\n    /** @private */\n    _onInteractionKeyDown(e, key) {\n      const localTarget = e.composedPath()[0];\n      const localTargetIsTextInput =\n        localTarget.localName === 'input' &&\n        !/^(button|checkbox|color|file|image|radio|range|reset|submit)$/iu.test(localTarget.type);\n\n      let wantInteracting;\n      switch (key) {\n        case 'Enter':\n          wantInteracting = this.interacting ? !localTargetIsTextInput : true;\n          break;\n        case 'Escape':\n          wantInteracting = false;\n          break;\n        case 'F2':\n          wantInteracting = !this.interacting;\n          break;\n        default:\n          break;\n      }\n\n      const { cell } = this._getGridEventLocation(e);\n\n      if (this.interacting !== wantInteracting && cell !== null) {\n        if (wantInteracting) {\n          const focusTarget =\n            cell._content.querySelector('[focus-target]') ||\n            // If a child element hasn't been explicitly marked as a focus target,\n            // fall back to any focusable element inside the cell.\n            [...cell._content.querySelectorAll('*')].find((node) => this._isFocusable(node));\n          if (focusTarget) {\n            e.preventDefault();\n            focusTarget.focus();\n            this._setInteracting(true);\n            this.toggleAttribute('navigating', false);\n          }\n        } else {\n          e.preventDefault();\n          this._focusedColumnOrder = undefined;\n          cell.focus();\n          this._setInteracting(false);\n          this.toggleAttribute('navigating', true);\n        }\n      }\n\n      if (key === 'Escape') {\n        this._hideTooltip(true);\n      }\n    }\n\n    /** @private */\n    _predictFocusStepTarget(srcElement, step) {\n      const tabOrder = [\n        this.$.table,\n        this._headerFocusable,\n        this._itemsFocusable,\n        this._footerFocusable,\n        this.$.focusexit,\n      ];\n\n      let index = tabOrder.indexOf(srcElement);\n\n      index += step;\n      while (index >= 0 && index <= tabOrder.length - 1) {\n        let rowElement = tabOrder[index];\n        if (rowElement && !this.__rowFocusMode) {\n          rowElement = tabOrder[index].parentNode;\n        }\n\n        if (!rowElement || rowElement.hidden) {\n          index += step;\n        } else {\n          break;\n        }\n      }\n\n      let focusStepTarget = tabOrder[index];\n\n      // If the target focusable is tied to a column that is not visible,\n      // find the first visible column and update the target in order to\n      // prevent scrolling to the start of the row.\n      if (focusStepTarget && !this.__isHorizontallyInViewport(focusStepTarget)) {\n        const firstVisibleColumn = this._getColumnsInOrder().find((column) => this.__isColumnInViewport(column));\n        if (firstVisibleColumn) {\n          if (focusStepTarget === this._headerFocusable) {\n            focusStepTarget = firstVisibleColumn._headerCell;\n          } else if (focusStepTarget === this._itemsFocusable) {\n            const rowIndex = focusStepTarget._column._cells.indexOf(focusStepTarget);\n            focusStepTarget = firstVisibleColumn._cells[rowIndex];\n          } else if (focusStepTarget === this._footerFocusable) {\n            focusStepTarget = firstVisibleColumn._footerCell;\n          }\n        }\n      }\n\n      return focusStepTarget;\n    }\n\n    /** @private */\n    _onTabKeyDown(e) {\n      const focusTarget = this._predictFocusStepTarget(e.composedPath()[0], e.shiftKey ? -1 : 1);\n\n      // Can be undefined if grid has tabindex\n      if (!focusTarget) {\n        return;\n      }\n\n      // Prevent focus-trap logic from intercepting the event.\n      e.stopPropagation();\n\n      if (focusTarget === this.$.table) {\n        // The focus is about to exit the grid to the top.\n        this.$.table.focus();\n      } else if (focusTarget === this.$.focusexit) {\n        // The focus is about to exit the grid to the bottom.\n        this.$.focusexit.focus();\n      } else if (focusTarget === this._itemsFocusable) {\n        let itemsFocusTarget = focusTarget;\n        const targetRow = this.__isRow(focusTarget) ? focusTarget : focusTarget.parentNode;\n        this._ensureScrolledToIndex(this._focusedItemIndex);\n        if (targetRow.index !== this._focusedItemIndex && this.__isCell(focusTarget)) {\n          // The target row, which is about to be focused next, has been\n          // assigned with a new index since last focus, probably because of\n          // scrolling. Focus the row for the stored focused item index instead.\n          const columnIndex = Array.from(targetRow.children).indexOf(this._itemsFocusable);\n          const focusedItemRow = Array.from(this.$.items.children).find(\n            (row) => !row.hidden && row.index === this._focusedItemIndex,\n          );\n          if (focusedItemRow) {\n            itemsFocusTarget = focusedItemRow.children[columnIndex];\n          }\n        }\n        e.preventDefault();\n        itemsFocusTarget.focus();\n      } else {\n        e.preventDefault();\n        focusTarget.focus();\n      }\n\n      this.toggleAttribute('navigating', true);\n    }\n\n    /** @private */\n    _onSpaceKeyDown(e) {\n      e.preventDefault();\n\n      const element = e.composedPath()[0];\n      const isRow = this.__isRow(element);\n      if (isRow || !element._content || !element._content.firstElementChild) {\n        this.dispatchEvent(\n          new CustomEvent(isRow ? 'row-activate' : 'cell-activate', {\n            detail: {\n              model: this.__getRowModel(isRow ? element : element.parentElement),\n            },\n          }),\n        );\n      }\n    }\n\n    /** @private */\n    _onKeyUp(e) {\n      if (!/^( |SpaceBar)$/u.test(e.key) || this.interacting) {\n        return;\n      }\n\n      e.preventDefault();\n\n      const cell = e.composedPath()[0];\n      if (cell._content && cell._content.firstElementChild) {\n        const wasNavigating = this.hasAttribute('navigating');\n        cell._content.firstElementChild.dispatchEvent(\n          new MouseEvent('click', {\n            shiftKey: e.shiftKey,\n            bubbles: true,\n            composed: true,\n            cancelable: true,\n          }),\n        );\n        this.toggleAttribute('navigating', wasNavigating);\n      }\n    }\n\n    /**\n     * @param {!FocusEvent} e\n     * @protected\n     */\n    _onFocusIn(e) {\n      if (!this._isMousedown) {\n        this.toggleAttribute('navigating', true);\n      }\n\n      const rootTarget = e.composedPath()[0];\n\n      if (rootTarget === this.$.table || rootTarget === this.$.focusexit) {\n        // The focus enters the top (bottom) of the grid, meaning that user has\n        // tabbed (shift-tabbed) into the grid. Move the focus to\n        // the first (the last) focusable.\n        this._predictFocusStepTarget(rootTarget, rootTarget === this.$.table ? 1 : -1).focus();\n        this._setInteracting(false);\n      } else {\n        this._detectInteracting(e);\n      }\n    }\n\n    /**\n     * @param {!FocusEvent} e\n     * @protected\n     */\n    _onFocusOut(e) {\n      this.toggleAttribute('navigating', false);\n      this._detectInteracting(e);\n      this._hideTooltip();\n      this._focusedCell = null;\n    }\n\n    /** @private */\n    _onContentFocusIn(e) {\n      const { section, cell, row } = this._getGridEventLocation(e);\n\n      if (!cell && !this.__rowFocusMode) {\n        return;\n      }\n\n      this._detectInteracting(e);\n\n      if (section && (cell || row)) {\n        this._activeRowGroup = section;\n        if (this.$.header === section) {\n          this._headerFocusable = this.__getFocusable(row, cell);\n        } else if (this.$.items === section) {\n          this._itemsFocusable = this.__getFocusable(row, cell);\n        } else if (this.$.footer === section) {\n          this._footerFocusable = this.__getFocusable(row, cell);\n        }\n\n        if (cell) {\n          const context = this.getEventContext(e);\n          this.__pendingBodyCellFocus = this.loading && context.section === 'body';\n          if (!this.__pendingBodyCellFocus) {\n            // Fire a cell-focus event for the cell\n            cell.dispatchEvent(new CustomEvent('cell-focus', { bubbles: true, composed: true, detail: { context } }));\n          }\n          this._focusedCell = cell._focusButton || cell;\n\n          if (isKeyboardActive() && e.target === cell) {\n            this._showTooltip(e);\n          }\n        } else {\n          this._focusedCell = null;\n        }\n      }\n\n      this._detectFocusedItemIndex(e);\n    }\n\n    /**\n     * @private\n     */\n    __dispatchPendingBodyCellFocus() {\n      // If the body cell focus was pending, dispatch the event once loading is done\n      if (this.__pendingBodyCellFocus && this.shadowRoot.activeElement === this._itemsFocusable) {\n        this._itemsFocusable.dispatchEvent(new Event('focusin', { bubbles: true, composed: true }));\n      }\n    }\n\n    /**\n     * Get the focusable element depending on the current focus mode.\n     * It can be a row, a cell, or a focusable div inside a cell.\n     *\n     * @param {HTMLElement} row\n     * @param {HTMLElement} cell\n     * @return {HTMLElement}\n     * @private\n     */\n    __getFocusable(row, cell) {\n      return this.__rowFocusMode ? row : cell._focusButton || cell;\n    }\n\n    /**\n     * Enables interaction mode if a cells descendant receives focus or keyboard\n     * input. Disables it if the event is not related to cell content.\n     * @param {!KeyboardEvent|!FocusEvent} e\n     * @private\n     */\n    _detectInteracting(e) {\n      const isInteracting = e.composedPath().some((el) => el.localName === 'vaadin-grid-cell-content');\n      this._setInteracting(isInteracting);\n      this.__updateHorizontalScrollPosition();\n    }\n\n    /** @private */\n    _detectFocusedItemIndex(e) {\n      const { section, row } = this._getGridEventLocation(e);\n      if (section === this.$.items) {\n        this._focusedItemIndex = row.index;\n      }\n    }\n\n    /**\n     * Enables or disables the focus target of the containing section of the\n     * grid from receiving focus, based on whether the user is interacting with\n     * that section of the grid.\n     * @param {HTMLElement} focusTarget\n     * @private\n     */\n    _updateGridSectionFocusTarget(focusTarget) {\n      if (!focusTarget) {\n        return;\n      }\n\n      const section = this._getGridSectionFromFocusTarget(focusTarget);\n      const isInteractingWithinActiveSection = this.interacting && section === this._activeRowGroup;\n\n      focusTarget.tabIndex = isInteractingWithinActiveSection ? -1 : 0;\n    }\n\n    /**\n     * @param {!HTMLTableRowElement} row\n     * @param {number} index\n     * @protected\n     */\n    _preventScrollerRotatingCellFocus(row, index) {\n      if (\n        row.index === this._focusedItemIndex &&\n        this.hasAttribute('navigating') &&\n        this._activeRowGroup === this.$.items\n      ) {\n        // Focused item has went, hide navigation mode\n        this._navigatingIsHidden = true;\n        this.toggleAttribute('navigating', false);\n      }\n      if (index === this._focusedItemIndex && this._navigatingIsHidden) {\n        // Focused item is back, restore navigation mode\n        this._navigatingIsHidden = false;\n        this.toggleAttribute('navigating', true);\n      }\n    }\n\n    /**\n     * @param {HTMLTableSectionElement=} rowGroup\n     * @param {number=} rowIndex\n     * @return {!Array<!GridColumn>}\n     * @protected\n     */\n    _getColumns(rowGroup, rowIndex) {\n      let columnTreeLevel = this._columnTree.length - 1;\n      if (rowGroup === this.$.header) {\n        columnTreeLevel = rowIndex;\n      } else if (rowGroup === this.$.footer) {\n        columnTreeLevel = this._columnTree.length - 1 - rowIndex;\n      }\n      return this._columnTree[columnTreeLevel];\n    }\n\n    /** @private */\n    __isValidFocusable(element) {\n      return this.$.table.contains(element) && element.offsetHeight;\n    }\n\n    /** @protected */\n    _resetKeyboardNavigation() {\n      // Header / footer\n      ['header', 'footer'].forEach((section) => {\n        if (!this.__isValidFocusable(this[`_${section}Focusable`])) {\n          const firstVisibleRow = [...this.$[section].children].find((row) => row.offsetHeight);\n          const firstVisibleCell = firstVisibleRow ? [...firstVisibleRow.children].find((cell) => !cell.hidden) : null;\n          if (firstVisibleRow && firstVisibleCell) {\n            this[`_${section}Focusable`] = this.__getFocusable(firstVisibleRow, firstVisibleCell);\n          }\n        }\n      });\n\n      // Body\n      if (!this.__isValidFocusable(this._itemsFocusable) && this.$.items.firstElementChild) {\n        const firstVisibleRow = this.__getFirstVisibleItem();\n        const firstVisibleCell = firstVisibleRow ? [...firstVisibleRow.children].find((cell) => !cell.hidden) : null;\n\n        if (firstVisibleCell && firstVisibleRow) {\n          // Reset memoized column\n          delete this._focusedColumnOrder;\n          this._itemsFocusable = this.__getFocusable(firstVisibleRow, firstVisibleCell);\n        }\n      } else {\n        this.__updateItemsFocusable();\n      }\n    }\n\n    /**\n     * @param {!HTMLElement} dstCell\n     * @protected\n     */\n    _scrollHorizontallyToCell(dstCell) {\n      if (dstCell.hasAttribute('frozen') || dstCell.hasAttribute('frozen-to-end') || this.__isDetailsCell(dstCell)) {\n        // These cells are, by design, always visible, no need to scroll.\n        return;\n      }\n\n      const dstCellRect = dstCell.getBoundingClientRect();\n      const dstRow = dstCell.parentNode;\n      const dstCellIndex = Array.from(dstRow.children).indexOf(dstCell);\n      const tableRect = this.$.table.getBoundingClientRect();\n      let leftBoundary = tableRect.left,\n        rightBoundary = tableRect.right;\n      for (let i = dstCellIndex - 1; i >= 0; i--) {\n        const cell = dstRow.children[i];\n        if (cell.hasAttribute('hidden') || this.__isDetailsCell(cell)) {\n          continue;\n        }\n        if (cell.hasAttribute('frozen') || cell.hasAttribute('frozen-to-end')) {\n          leftBoundary = cell.getBoundingClientRect().right;\n          break;\n        }\n      }\n      for (let i = dstCellIndex + 1; i < dstRow.children.length; i++) {\n        const cell = dstRow.children[i];\n        if (cell.hasAttribute('hidden') || this.__isDetailsCell(cell)) {\n          continue;\n        }\n        if (cell.hasAttribute('frozen') || cell.hasAttribute('frozen-to-end')) {\n          rightBoundary = cell.getBoundingClientRect().left;\n          break;\n        }\n      }\n\n      if (dstCellRect.left < leftBoundary) {\n        this.$.table.scrollLeft += Math.round(dstCellRect.left - leftBoundary);\n      }\n      if (dstCellRect.right > rightBoundary) {\n        this.$.table.scrollLeft += Math.round(dstCellRect.right - rightBoundary);\n      }\n    }\n\n    /**\n     * @typedef {Object} GridEventLocation\n     * @property {HTMLTableSectionElement | null} section - The table section element that the event occurred in (header, body, or footer), or null if the event did not occur in a section\n     * @property {HTMLTableRowElement | null} row - The row element that the event occurred in, or null if the event did not occur in a row\n     * @property {HTMLTableCellElement | null} cell - The cell element that the event occurred in, or null if the event did not occur in a cell\n     * @private\n     */\n    /**\n     * Takes an event and returns a location object describing in which part of the grid the event occurred.\n     * The event may either target table section, a row, a cell or contents of a cell.\n     * @param {Event} e\n     * @returns {GridEventLocation}\n     * @private\n     */\n    _getGridEventLocation(e) {\n      const path = e.composedPath();\n      const tableIndex = path.indexOf(this.$.table);\n      // Assuming ascending path to table is: [...,] th|td, tr, thead|tbody, table [,...]\n      const section = tableIndex >= 1 ? path[tableIndex - 1] : null;\n      const row = tableIndex >= 2 ? path[tableIndex - 2] : null;\n      const cell = tableIndex >= 3 ? path[tableIndex - 3] : null;\n\n      return {\n        section,\n        row,\n        cell,\n      };\n    }\n\n    /**\n     * Helper method that maps a focus target cell to the containing grid section\n     * @param {HTMLElement} focusTarget\n     * @returns {HTMLTableSectionElement | null}\n     * @private\n     */\n    _getGridSectionFromFocusTarget(focusTarget) {\n      if (focusTarget === this._headerFocusable) {\n        return this.$.header;\n      }\n      if (focusTarget === this._itemsFocusable) {\n        return this.$.items;\n      }\n      if (focusTarget === this._footerFocusable) {\n        return this.$.footer;\n      }\n      return null;\n    }\n\n    /**\n     * Fired when a cell is focused with click or keyboard navigation.\n     *\n     * Use context property of @see {@link GridCellFocusEvent} to get detail information about the event.\n     *\n     * @event cell-focus\n     */\n  };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}