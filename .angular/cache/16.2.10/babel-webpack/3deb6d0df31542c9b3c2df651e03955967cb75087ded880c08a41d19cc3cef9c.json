{"ast":null,"code":"/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\n/**\n * @polymerMixin\n */\nexport const KeyboardNavigationMixin = superClass => class KeyboardNavigationMixin extends superClass {\n  static get properties() {\n    return {\n      _headerFocusable: {\n        type: Object,\n        observer: '_focusableChanged'\n      },\n      _itemsFocusable: {\n        type: Object,\n        observer: '_focusableChanged'\n      },\n      _footerFocusable: {\n        type: Object,\n        observer: '_focusableChanged'\n      },\n      _navigatingIsHidden: Boolean,\n      _focusedItemIndex: {\n        type: Number,\n        value: 0\n      },\n      _focusedColumnOrder: Number\n    };\n  }\n  ready() {\n    super.ready();\n    if (this._ios || this._android) {\n      // Disable keyboard navigation on mobile devices\n      return;\n    }\n    this.addEventListener('keydown', this._onKeyDown);\n    this.addEventListener('focusin', this._onFocusIn);\n    this.addEventListener('focusout', this._onFocusOut);\n\n    // When focus goes from cell to another cell, focusin/focusout events do\n    // not escape the grid’s shadowRoot, thus listening inside the shadowRoot.\n    this.$.table.addEventListener('focusin', this._onCellFocusIn.bind(this));\n    this.$.table.addEventListener('focusout', this._onCellFocusOut.bind(this));\n    this.addEventListener('mousedown', () => {\n      this._toggleAttribute('navigating', false, this);\n      this._isMousedown = true;\n    });\n    this.addEventListener('mouseup', () => this._isMousedown = false);\n  }\n  _focusableChanged(focusable, oldFocusable) {\n    if (oldFocusable) {\n      oldFocusable.setAttribute('tabindex', '-1');\n    }\n    if (focusable) {\n      focusable.setAttribute('tabindex', '0');\n    }\n  }\n  _onKeyDown(e) {\n    // Ensure standard key value, unified across browsers\n    let key = e.key;\n    if (key === 'Up' || key === 'Down' || key === 'Left' || key === 'Right') {\n      // MSIE & Edge\n      key = 'Arrow' + key;\n    }\n    if (key === 'Esc') {\n      // MSIE & Edge\n      key = 'Escape';\n    }\n    if (key === 'Spacebar') {\n      // MSIE\n      key = ' ';\n    }\n    let keyGroup;\n    switch (key) {\n      case 'ArrowUp':\n      case 'ArrowDown':\n      case 'ArrowLeft':\n      case 'ArrowRight':\n      case 'PageUp':\n      case 'PageDown':\n      case 'Home':\n      case 'End':\n        keyGroup = 'Navigation';\n        break;\n      case 'Enter':\n      case 'Escape':\n      case 'F2':\n        keyGroup = 'Interaction';\n        break;\n      case 'Tab':\n        keyGroup = 'Tab';\n        break;\n      case ' ':\n        keyGroup = 'Space';\n        break;\n    }\n    this._detectInteracting(e);\n    if (this.hasAttribute('interacting') && keyGroup !== 'Interaction') {\n      // When in the interacting mode, only the “Interaction” keys are handled.\n      keyGroup = undefined;\n    }\n    if (keyGroup) {\n      this[`_on${keyGroup}KeyDown`](e, key);\n    }\n  }\n  _ensureScrolledToIndex(index) {\n    const targetRowInDom = Array.from(this.$.items.children).filter(child => child.index === index)[0];\n    if (!targetRowInDom) {\n      this._scrollToIndex(index);\n    }\n  }\n  _onNavigationKeyDown(e, key) {\n    e.preventDefault();\n    function indexOfChildElement(el) {\n      return Array.prototype.indexOf.call(el.parentNode.children, el);\n    }\n    const visibleItemsCount = this._lastVisibleIndex - this._firstVisibleIndex - 1;\n    let dx = 0,\n      dy = 0;\n    switch (key) {\n      case 'ArrowRight':\n        dx = 1;\n        break;\n      case 'ArrowLeft':\n        dx = -1;\n        break;\n      case 'Home':\n        dx = -Infinity;\n        e.ctrlKey && (dy = -Infinity);\n        break;\n      case 'End':\n        dx = Infinity;\n        e.ctrlKey && (dy = Infinity);\n        break;\n      case 'ArrowDown':\n        dy = 1;\n        break;\n      case 'ArrowUp':\n        dy = -1;\n        break;\n      case 'PageDown':\n        dy = visibleItemsCount;\n        break;\n      case 'PageUp':\n        dy = -visibleItemsCount;\n        break;\n    }\n    const activeCell = e.composedPath()[0];\n    const columnIndex = indexOfChildElement(activeCell);\n    const isRowDetails = this._elementMatches(activeCell, '[part~=\"details-cell\"]');\n    const activeRow = activeCell.parentNode;\n    const activeRowGroup = activeRow.parentNode;\n    const maxRowIndex = (activeRowGroup === this.$.items ? this._effectiveSize : activeRowGroup.children.length) - 1;\n\n    // Body rows have index property, otherwise DOM child index of the row is used.\n    const rowIndex = activeRowGroup === this.$.items ? this._focusedItemIndex !== undefined ? this._focusedItemIndex : activeRow.index : indexOfChildElement(activeRow);\n\n    // Index of the destination row\n    let dstRowIndex = Math.max(0, Math.min(rowIndex + dy, maxRowIndex));\n\n    // Row details navigation logic\n    let dstIsRowDetails = false;\n    if (activeRowGroup === this.$.items) {\n      const item = activeRow._item;\n      const dstItem = this._cache.getItemForIndex(dstRowIndex);\n      // Should we navigate to row details?\n      if (isRowDetails) {\n        dstIsRowDetails = dy === 0;\n      } else {\n        dstIsRowDetails = dy === 1 && this._isDetailsOpened(item) || dy === -1 && dstRowIndex !== rowIndex && this._isDetailsOpened(dstItem);\n      }\n      // Should we navigate between details and regular cells of the same row?\n      if (dstIsRowDetails !== isRowDetails && (dy === 1 && dstIsRowDetails || dy === -1 && !dstIsRowDetails)) {\n        dstRowIndex = rowIndex;\n      }\n    }\n\n    // Header and footer could have hidden rows, e. g., if none of the columns\n    // or groups on the given column tree level define template. Skip them\n    // in vertical keyboard navigation.\n    if (activeRowGroup !== this.$.items) {\n      if (dstRowIndex > rowIndex) {\n        while (dstRowIndex < maxRowIndex && activeRowGroup.children[dstRowIndex].hidden) {\n          dstRowIndex++;\n        }\n      } else if (dstRowIndex < rowIndex) {\n        while (dstRowIndex > 0 && activeRowGroup.children[dstRowIndex].hidden) {\n          dstRowIndex--;\n        }\n      }\n    }\n\n    // _focusedColumnOrder is memoized — this is to ensure predictable\n    // navigation when entering and leaving detail and column group cells.\n    if (this._focusedColumnOrder === undefined) {\n      if (isRowDetails) {\n        this._focusedColumnOrder = 0;\n      } else {\n        this._focusedColumnOrder = this._getColumns(activeRowGroup, rowIndex)[columnIndex]._order;\n      }\n    }\n\n    // Find orderedColumnIndex — the index of order closest matching the\n    // original _focusedColumnOrder in the sorted array of orders\n    // of the visible columns on the destination row.\n    const dstColumns = this._getColumns(activeRowGroup, dstRowIndex);\n    const dstSortedColumnOrders = dstColumns.filter(c => !c.hidden).map(c => c._order).sort((b, a) => b - a);\n    const maxOrderedColumnIndex = dstSortedColumnOrders.length - 1;\n    const orderedColumnIndex = dstSortedColumnOrders.indexOf(dstSortedColumnOrders.slice(0).sort((b, a) => Math.abs(b - this._focusedColumnOrder) - Math.abs(a - this._focusedColumnOrder))[0]);\n\n    // Index of the destination column order\n    const dstOrderedColumnIndex = dy === 0 && isRowDetails ? orderedColumnIndex : Math.max(0, Math.min(orderedColumnIndex + dx, maxOrderedColumnIndex));\n    if (dstOrderedColumnIndex !== orderedColumnIndex) {\n      // Horizontal movement invalidates stored _focusedColumnOrder\n      this._focusedColumnOrder = undefined;\n    }\n\n    // Ensure correct vertical scroll position, destination row is visible\n    if (activeRowGroup === this.$.items) {\n      this._ensureScrolledToIndex(dstRowIndex);\n    }\n\n    // This has to be set after scrolling, otherwise it can be removed by\n    // `_preventScrollerRotatingCellFocus(item, index)` during scrolling.\n    this._toggleAttribute('navigating', true, this);\n    const columnIndexByOrder = dstColumns.reduce((acc, col, i) => (acc[col._order] = i, acc), {});\n    const dstColumnIndex = columnIndexByOrder[dstSortedColumnOrders[dstOrderedColumnIndex]];\n\n    // For body rows, use index property to find destination row, otherwise use DOM child index\n    const dstRow = activeRowGroup === this.$.items ? Array.from(activeRowGroup.children).filter(el => el.index === dstRowIndex)[0] : activeRowGroup.children[dstRowIndex];\n    if (!dstRow) {\n      return;\n    }\n\n    // Here we go!\n    const dstCell = dstIsRowDetails ? Array.from(dstRow.children).filter(el => this._elementMatches(el, '[part~=\"details-cell\"]'))[0] : dstRow.children[dstColumnIndex];\n    this._scrollHorizontallyToCell(dstCell);\n    if (activeRowGroup === this.$.items) {\n      // When scrolling with repeated keydown, sometimes FocusEvent listeners\n      // are too late to update _focusedItemIndex. Ensure next keydown\n      // listener invocation gets updated _focusedItemIndex value.\n      this._focusedItemIndex = dstRowIndex;\n    }\n    if (activeRowGroup === this.$.items) {\n      const dstRect = dstCell.getBoundingClientRect();\n      const footerTop = this.$.footer.getBoundingClientRect().top;\n      const headerBottom = this.$.header.getBoundingClientRect().bottom;\n      if (dstRect.bottom > footerTop) {\n        this.$.table.scrollTop += dstRect.bottom - footerTop;\n        this._scrollHandler();\n      } else if (dstRect.top < headerBottom) {\n        this.$.table.scrollTop -= headerBottom - dstRect.top;\n        this._scrollHandler();\n      }\n    }\n    dstCell.focus();\n  }\n  _parseEventPath(path) {\n    const tableIndex = path.indexOf(this.$.table);\n    return {\n      rowGroup: path[tableIndex - 1],\n      row: path[tableIndex - 2],\n      cell: path[tableIndex - 3]\n    };\n  }\n  _onInteractionKeyDown(e, key) {\n    const localTarget = e.composedPath()[0];\n    const localTargetIsTextInput = localTarget.localName === 'input' && !/^(button|checkbox|color|file|image|radio|range|reset|submit)$/i.test(localTarget.type);\n    let wantInteracting;\n    switch (key) {\n      case 'Enter':\n        wantInteracting = this.hasAttribute('interacting') ? !localTargetIsTextInput : true;\n        break;\n      case 'Escape':\n        wantInteracting = false;\n        break;\n      case 'F2':\n        wantInteracting = !this.hasAttribute('interacting');\n        break;\n    }\n    const {\n      cell\n    } = this._parseEventPath(e.composedPath());\n    if (this.hasAttribute('interacting') !== wantInteracting) {\n      if (wantInteracting) {\n        const focusTarget = cell._content.querySelector('[focus-target]') || cell._content.firstElementChild;\n        if (focusTarget) {\n          e.preventDefault();\n          focusTarget.focus();\n          this._toggleAttribute('interacting', true, this);\n          this._toggleAttribute('navigating', false, this);\n        }\n      } else {\n        e.preventDefault();\n        this._focusedColumnOrder = undefined;\n        cell.focus();\n        this._toggleAttribute('interacting', false, this);\n        this._toggleAttribute('navigating', true, this);\n      }\n    }\n  }\n  _predictFocusStepTarget(srcElement, step) {\n    const tabOrder = [this.$.table, this._headerFocusable, this._itemsFocusable, this._footerFocusable, this.$.focusexit];\n    let index = tabOrder.indexOf(srcElement);\n    index += step;\n    while (index >= 0 && index <= tabOrder.length - 1 && (!tabOrder[index] || tabOrder[index].parentNode.hidden)) {\n      index += step;\n    }\n    return tabOrder[index];\n  }\n  _onTabKeyDown(e) {\n    const focusTarget = this._predictFocusStepTarget(e.composedPath()[0], e.shiftKey ? -1 : 1);\n    if (focusTarget === this.$.table) {\n      // The focus is about to exit the grid to the top.\n      this.$.table.focus();\n    } else if (focusTarget === this.$.focusexit) {\n      // The focus is about to exit the grid to the bottom.\n      this.$.focusexit.focus();\n    } else if (focusTarget === this._itemsFocusable) {\n      let itemsFocusTarget = focusTarget;\n      const targetRow = this._itemsFocusable.parentNode;\n      this._ensureScrolledToIndex(this._focusedItemIndex);\n      if (targetRow.index !== this._focusedItemIndex) {\n        // The target row, which is about to be focused next, has been\n        // assigned with a new index since last focus, probably because of\n        // scrolling. Focus the row for the stored focused item index instead.\n        const columnIndex = Array.from(targetRow.children).indexOf(this._itemsFocusable);\n        const focusedItemRow = Array.from(this.$.items.children).filter(row => row.index === this._focusedItemIndex)[0];\n        if (focusedItemRow) {\n          itemsFocusTarget = focusedItemRow.children[columnIndex];\n        }\n      }\n      e.preventDefault();\n      itemsFocusTarget.focus();\n    } else {\n      e.preventDefault();\n      focusTarget.focus();\n    }\n    this._toggleAttribute('navigating', true, this);\n  }\n  _onSpaceKeyDown(e) {\n    e.preventDefault();\n    const cell = e.composedPath()[0];\n    if (cell._content && cell._content.firstElementChild) {\n      const wasNavigating = this.hasAttribute('navigating');\n      cell._content.firstElementChild.click();\n      this._toggleAttribute('navigating', wasNavigating, this);\n    } else {\n      this.dispatchEvent(new CustomEvent('cell-activate', {\n        detail: {\n          model: this.__getRowModel(cell.parentElement)\n        }\n      }));\n    }\n  }\n  _onFocusIn(e) {\n    if (!this._isMousedown) {\n      this._toggleAttribute('navigating', true, this);\n    }\n    const rootTarget = e.composedPath()[0];\n    if (rootTarget === this.$.table || rootTarget === this.$.focusexit) {\n      // The focus enters the top (bottom) of the grid, meaning that user has\n      // tabbed (shift-tabbed) into the grid. Move the focus to\n      // the first (the last) focusable.\n      this._predictFocusStepTarget(rootTarget, rootTarget === this.$.table ? 1 : -1).focus();\n      this._toggleAttribute('interacting', false, this);\n    } else {\n      this._detectInteracting(e);\n    }\n  }\n  _onFocusOut(e) {\n    this._toggleAttribute('navigating', false, this);\n    this._detectInteracting(e);\n  }\n  _onCellFocusIn(e) {\n    this._detectInteracting(e);\n    if (e.composedPath().indexOf(this.$.table) === 3) {\n      const cell = e.composedPath()[0];\n      this._activeRowGroup = cell.parentNode.parentNode;\n      if (this._activeRowGroup === this.$.header) {\n        this._headerFocusable = cell;\n      } else if (this._activeRowGroup === this.$.items) {\n        this._itemsFocusable = cell;\n      } else if (this._activeRowGroup === this.$.footer) {\n        this._footerFocusable = cell;\n      }\n      // Inform cell content of the focus (used in <vaadin-grid-sorter>)\n      cell._content.dispatchEvent(new CustomEvent('cell-focusin', {\n        bubbles: false\n      }));\n    }\n    this._detectFocusedItemIndex(e);\n  }\n  _onCellFocusOut(e) {\n    if (e.composedPath().indexOf(this.$.table) === 3) {\n      const cell = e.composedPath()[0];\n      // Inform cell content of the focus (used in <vaadin-grid-sorter>)\n      cell._content.dispatchEvent(new CustomEvent('cell-focusout', {\n        bubbles: false\n      }));\n    }\n  }\n  _detectInteracting(e) {\n    this._toggleAttribute('interacting', e.composedPath().some(el => el.localName === 'vaadin-grid-cell-content'), this);\n  }\n  _detectFocusedItemIndex(e) {\n    const {\n      rowGroup,\n      row\n    } = this._parseEventPath(e.composedPath());\n    if (rowGroup === this.$.items) {\n      this._focusedItemIndex = row.index;\n    }\n  }\n  _preventScrollerRotatingCellFocus(item, index) {\n    if (item.index === this._focusedItemIndex && this.hasAttribute('navigating') && this._activeRowGroup === this.$.items) {\n      // Focused item has went, hide navigation mode\n      this._navigatingIsHidden = true;\n      this._toggleAttribute('navigating', false, this);\n    }\n    if (index === this._focusedItemIndex && this._navigatingIsHidden) {\n      // Focused item is back, restore navigation mode\n      this._navigatingIsHidden = false;\n      this._toggleAttribute('navigating', true, this);\n    }\n  }\n  _getColumns(rowGroup, rowIndex) {\n    let columnTreeLevel = this._columnTree.length - 1;\n    if (rowGroup === this.$.header) {\n      columnTreeLevel = rowIndex;\n    } else if (rowGroup === this.$.footer) {\n      columnTreeLevel = this._columnTree.length - 1 - rowIndex;\n    }\n    return this._columnTree[columnTreeLevel];\n  }\n  _resetKeyboardNavigation() {\n    if (this.$.header.firstElementChild) {\n      this._headerFocusable = Array.from(this.$.header.firstElementChild.children).filter(el => !el.hidden)[0];\n    }\n    if (this.$.items.firstElementChild) {\n      const firstVisibleIndexRow = this._iterateItems((pidx, vidx) => {\n        if (this._firstVisibleIndex === vidx) {\n          return this.$.items.children[pidx];\n        }\n      });\n      if (firstVisibleIndexRow) {\n        this._itemsFocusable = Array.from(firstVisibleIndexRow.children).filter(el => !el.hidden)[0];\n      }\n    }\n    if (this.$.footer.firstElementChild) {\n      this._footerFocusable = Array.from(this.$.footer.firstElementChild.children).filter(el => !el.hidden)[0];\n    }\n  }\n  _scrollHorizontallyToCell(dstCell) {\n    if (dstCell.hasAttribute('frozen') || this._elementMatches(dstCell, '[part~=\"details-cell\"]')) {\n      // These cells are, by design, always visible, no need to scroll.\n      return;\n    }\n    const dstCellRect = dstCell.getBoundingClientRect();\n    const dstRow = dstCell.parentNode;\n    const dstCellIndex = Array.from(dstRow.children).indexOf(dstCell);\n    const tableRect = this.$.table.getBoundingClientRect();\n    let leftBoundary = tableRect.left,\n      rightBoundary = tableRect.right;\n    for (let i = dstCellIndex - 1; i >= 0; i--) {\n      const cell = dstRow.children[i];\n      if (cell.hasAttribute('hidden') || this._elementMatches(cell, '[part~=\"details-cell\"]')) {\n        continue;\n      }\n      if (cell.hasAttribute('frozen')) {\n        leftBoundary = cell.getBoundingClientRect().right;\n        break;\n      }\n    }\n    for (let i = dstCellIndex + 1; i < dstRow.children.length; i++) {\n      const cell = dstRow.children[i];\n      if (cell.hasAttribute('hidden') || this._elementMatches(cell, '[part~=\"details-cell\"]')) {\n        continue;\n      }\n      if (cell.hasAttribute('frozen')) {\n        rightBoundary = cell.getBoundingClientRect().left;\n        break;\n      }\n    }\n    if (dstCellRect.left < leftBoundary) {\n      this.$.table.scrollLeft += Math.round(dstCellRect.left - leftBoundary);\n    }\n    if (dstCellRect.right > rightBoundary) {\n      this.$.table.scrollLeft += Math.round(dstCellRect.right - rightBoundary);\n    }\n  }\n  _elementMatches(el, query) {\n    return el.matches ? el.matches(query) : Array.from(el.parentNode.querySelectorAll(query)).indexOf(el) !== -1;\n  }\n};","map":{"version":3,"names":["KeyboardNavigationMixin","superClass","properties","_headerFocusable","type","Object","observer","_itemsFocusable","_footerFocusable","_navigatingIsHidden","Boolean","_focusedItemIndex","Number","value","_focusedColumnOrder","ready","_ios","_android","addEventListener","_onKeyDown","_onFocusIn","_onFocusOut","$","table","_onCellFocusIn","bind","_onCellFocusOut","_toggleAttribute","_isMousedown","_focusableChanged","focusable","oldFocusable","setAttribute","e","key","keyGroup","_detectInteracting","hasAttribute","undefined","_ensureScrolledToIndex","index","targetRowInDom","Array","from","items","children","filter","child","_scrollToIndex","_onNavigationKeyDown","preventDefault","indexOfChildElement","el","prototype","indexOf","call","parentNode","visibleItemsCount","_lastVisibleIndex","_firstVisibleIndex","dx","dy","Infinity","ctrlKey","activeCell","composedPath","columnIndex","isRowDetails","_elementMatches","activeRow","activeRowGroup","maxRowIndex","_effectiveSize","length","rowIndex","dstRowIndex","Math","max","min","dstIsRowDetails","item","_item","dstItem","_cache","getItemForIndex","_isDetailsOpened","hidden","_getColumns","_order","dstColumns","dstSortedColumnOrders","c","map","sort","b","a","maxOrderedColumnIndex","orderedColumnIndex","slice","abs","dstOrderedColumnIndex","columnIndexByOrder","reduce","acc","col","i","dstColumnIndex","dstRow","dstCell","_scrollHorizontallyToCell","dstRect","getBoundingClientRect","footerTop","footer","top","headerBottom","header","bottom","scrollTop","_scrollHandler","focus","_parseEventPath","path","tableIndex","rowGroup","row","cell","_onInteractionKeyDown","localTarget","localTargetIsTextInput","localName","test","wantInteracting","focusTarget","_content","querySelector","firstElementChild","_predictFocusStepTarget","srcElement","step","tabOrder","focusexit","_onTabKeyDown","shiftKey","itemsFocusTarget","targetRow","focusedItemRow","_onSpaceKeyDown","wasNavigating","click","dispatchEvent","CustomEvent","detail","model","__getRowModel","parentElement","rootTarget","_activeRowGroup","bubbles","_detectFocusedItemIndex","some","_preventScrollerRotatingCellFocus","columnTreeLevel","_columnTree","_resetKeyboardNavigation","firstVisibleIndexRow","_iterateItems","pidx","vidx","dstCellRect","dstCellIndex","tableRect","leftBoundary","left","rightBoundary","right","scrollLeft","round","query","matches","querySelectorAll"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@vaadin/vaadin-grid/src/vaadin-grid-keyboard-navigation-mixin.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\n/**\n * @polymerMixin\n */\nexport const KeyboardNavigationMixin = superClass => class KeyboardNavigationMixin extends superClass {\n  static get properties() {\n    return {\n      _headerFocusable: {\n        type: Object,\n        observer: '_focusableChanged'\n      },\n      _itemsFocusable: {\n        type: Object,\n        observer: '_focusableChanged'\n      },\n      _footerFocusable: {\n        type: Object,\n        observer: '_focusableChanged'\n      },\n      _navigatingIsHidden: Boolean,\n      _focusedItemIndex: {\n        type: Number,\n        value: 0\n      },\n      _focusedColumnOrder: Number\n    };\n  }\n\n  ready() {\n    super.ready();\n\n    if (this._ios || this._android) {\n      // Disable keyboard navigation on mobile devices\n      return;\n    }\n\n    this.addEventListener('keydown', this._onKeyDown);\n    this.addEventListener('focusin', this._onFocusIn);\n    this.addEventListener('focusout', this._onFocusOut);\n\n    // When focus goes from cell to another cell, focusin/focusout events do\n    // not escape the grid’s shadowRoot, thus listening inside the shadowRoot.\n    this.$.table.addEventListener('focusin', this._onCellFocusIn.bind(this));\n    this.$.table.addEventListener('focusout', this._onCellFocusOut.bind(this));\n\n    this.addEventListener('mousedown', () => {\n      this._toggleAttribute('navigating', false, this);\n      this._isMousedown = true;\n    });\n    this.addEventListener('mouseup', () => this._isMousedown = false);\n  }\n\n  _focusableChanged(focusable, oldFocusable) {\n    if (oldFocusable) {\n      oldFocusable.setAttribute('tabindex', '-1');\n    }\n    if (focusable) {\n      focusable.setAttribute('tabindex', '0');\n    }\n  }\n\n  _onKeyDown(e) {\n    // Ensure standard key value, unified across browsers\n    let key = e.key;\n    if (key === 'Up' || key === 'Down' || key === 'Left' || key === 'Right') {\n      // MSIE & Edge\n      key = 'Arrow' + key;\n    }\n    if (key === 'Esc') {\n      // MSIE & Edge\n      key = 'Escape';\n    }\n    if (key === 'Spacebar') {\n      // MSIE\n      key = ' ';\n    }\n\n    let keyGroup;\n    switch (key) {\n      case 'ArrowUp':\n      case 'ArrowDown':\n      case 'ArrowLeft':\n      case 'ArrowRight':\n      case 'PageUp':\n      case 'PageDown':\n      case 'Home':\n      case 'End':\n        keyGroup = 'Navigation';\n        break;\n      case 'Enter':\n      case 'Escape':\n      case 'F2':\n        keyGroup = 'Interaction';\n        break;\n      case 'Tab':\n        keyGroup = 'Tab';\n        break;\n      case ' ':\n        keyGroup = 'Space';\n        break;\n    }\n\n    this._detectInteracting(e);\n    if (this.hasAttribute('interacting') && keyGroup !== 'Interaction') {\n      // When in the interacting mode, only the “Interaction” keys are handled.\n      keyGroup = undefined;\n    }\n\n    if (keyGroup) {\n      this[`_on${keyGroup}KeyDown`](e, key);\n    }\n  }\n\n  _ensureScrolledToIndex(index) {\n    const targetRowInDom = Array.from(this.$.items.children).filter(child => child.index === index)[0];\n    if (!targetRowInDom) {\n      this._scrollToIndex(index);\n    }\n  }\n\n  _onNavigationKeyDown(e, key) {\n    e.preventDefault();\n\n    function indexOfChildElement(el) {\n      return Array.prototype.indexOf.call(el.parentNode.children, el);\n    }\n\n    const visibleItemsCount = this._lastVisibleIndex - this._firstVisibleIndex - 1;\n\n    let dx = 0, dy = 0;\n    switch (key) {\n      case 'ArrowRight':\n        dx = 1;\n        break;\n      case 'ArrowLeft':\n        dx = -1;\n        break;\n      case 'Home':\n        dx = -Infinity;\n        e.ctrlKey && (dy = -Infinity);\n        break;\n      case 'End':\n        dx = Infinity;\n        e.ctrlKey && (dy = Infinity);\n        break;\n      case 'ArrowDown':\n        dy = 1;\n        break;\n      case 'ArrowUp':\n        dy = -1;\n        break;\n      case 'PageDown':\n        dy = visibleItemsCount;\n        break;\n      case 'PageUp':\n        dy = -visibleItemsCount;\n        break;\n    }\n\n    const activeCell = e.composedPath()[0];\n    const columnIndex = indexOfChildElement(activeCell);\n    const isRowDetails = this._elementMatches(activeCell, '[part~=\"details-cell\"]');\n\n    const activeRow = activeCell.parentNode;\n\n    const activeRowGroup = activeRow.parentNode;\n    const maxRowIndex = (activeRowGroup === this.$.items ? this._effectiveSize : activeRowGroup.children.length) - 1;\n\n    // Body rows have index property, otherwise DOM child index of the row is used.\n    const rowIndex = (activeRowGroup === this.$.items) ?\n      (this._focusedItemIndex !== undefined ? this._focusedItemIndex : activeRow.index) :\n      indexOfChildElement(activeRow);\n\n    // Index of the destination row\n    let dstRowIndex = Math.max(0, Math.min(rowIndex + dy, maxRowIndex));\n\n    // Row details navigation logic\n    let dstIsRowDetails = false;\n    if (activeRowGroup === this.$.items) {\n      const item = activeRow._item;\n      const dstItem = this._cache.getItemForIndex(dstRowIndex);\n      // Should we navigate to row details?\n      if (isRowDetails) {\n        dstIsRowDetails = dy === 0;\n      } else {\n        dstIsRowDetails = dy === 1 && this._isDetailsOpened(item) ||\n          dy === -1 && dstRowIndex !== rowIndex && this._isDetailsOpened(dstItem);\n      }\n      // Should we navigate between details and regular cells of the same row?\n      if (dstIsRowDetails !== isRowDetails &&\n          (dy === 1 && dstIsRowDetails || dy === -1 && !dstIsRowDetails)) {\n        dstRowIndex = rowIndex;\n      }\n    }\n\n    // Header and footer could have hidden rows, e. g., if none of the columns\n    // or groups on the given column tree level define template. Skip them\n    // in vertical keyboard navigation.\n    if (activeRowGroup !== this.$.items) {\n      if (dstRowIndex > rowIndex) {\n        while (\n          dstRowIndex < maxRowIndex &&\n          activeRowGroup.children[dstRowIndex].hidden\n        ) {\n          dstRowIndex++;\n        }\n      } else if (dstRowIndex < rowIndex) {\n        while (\n          dstRowIndex > 0 &&\n          activeRowGroup.children[dstRowIndex].hidden\n        ) {\n          dstRowIndex--;\n        }\n      }\n    }\n\n    // _focusedColumnOrder is memoized — this is to ensure predictable\n    // navigation when entering and leaving detail and column group cells.\n    if (this._focusedColumnOrder === undefined) {\n      if (isRowDetails) {\n        this._focusedColumnOrder = 0;\n      } else {\n        this._focusedColumnOrder = this._getColumns(activeRowGroup, rowIndex)[columnIndex]._order;\n      }\n    }\n\n    // Find orderedColumnIndex — the index of order closest matching the\n    // original _focusedColumnOrder in the sorted array of orders\n    // of the visible columns on the destination row.\n    const dstColumns = this._getColumns(activeRowGroup, dstRowIndex);\n    const dstSortedColumnOrders = dstColumns.filter(c => !c.hidden).map(c => c._order)\n      .sort((b, a) => (b - a));\n    const maxOrderedColumnIndex = dstSortedColumnOrders.length - 1;\n    const orderedColumnIndex = dstSortedColumnOrders.indexOf(\n      dstSortedColumnOrders.slice(0).sort((b, a) =>\n        Math.abs(b - this._focusedColumnOrder) - Math.abs(a - this._focusedColumnOrder)\n      )[0]\n    );\n\n    // Index of the destination column order\n    const dstOrderedColumnIndex = (dy === 0 && isRowDetails) ? orderedColumnIndex :\n      Math.max(0, Math.min(orderedColumnIndex + dx, maxOrderedColumnIndex));\n\n    if (dstOrderedColumnIndex !== orderedColumnIndex) {\n      // Horizontal movement invalidates stored _focusedColumnOrder\n      this._focusedColumnOrder = undefined;\n    }\n\n    // Ensure correct vertical scroll position, destination row is visible\n    if (activeRowGroup === this.$.items) {\n      this._ensureScrolledToIndex(dstRowIndex);\n    }\n\n    // This has to be set after scrolling, otherwise it can be removed by\n    // `_preventScrollerRotatingCellFocus(item, index)` during scrolling.\n    this._toggleAttribute('navigating', true, this);\n\n    const columnIndexByOrder = dstColumns.reduce((acc, col, i) => (acc[col._order] = i, acc), {});\n    const dstColumnIndex = columnIndexByOrder[dstSortedColumnOrders[dstOrderedColumnIndex]];\n\n    // For body rows, use index property to find destination row, otherwise use DOM child index\n    const dstRow = activeRowGroup === this.$.items ?\n      Array.from(activeRowGroup.children).filter(el => el.index === dstRowIndex)[0] :\n      activeRowGroup.children[dstRowIndex];\n    if (!dstRow) {\n      return;\n    }\n\n    // Here we go!\n    const dstCell = dstIsRowDetails ?\n      Array.from(dstRow.children)\n        .filter(el => this._elementMatches(el, '[part~=\"details-cell\"]'))[0] :\n      dstRow.children[dstColumnIndex];\n    this._scrollHorizontallyToCell(dstCell);\n    if (activeRowGroup === this.$.items) {\n      // When scrolling with repeated keydown, sometimes FocusEvent listeners\n      // are too late to update _focusedItemIndex. Ensure next keydown\n      // listener invocation gets updated _focusedItemIndex value.\n      this._focusedItemIndex = dstRowIndex;\n    }\n\n    if (activeRowGroup === this.$.items) {\n      const dstRect = dstCell.getBoundingClientRect();\n      const footerTop = this.$.footer.getBoundingClientRect().top;\n      const headerBottom = this.$.header.getBoundingClientRect().bottom;\n      if (dstRect.bottom > footerTop) {\n        this.$.table.scrollTop += dstRect.bottom - footerTop;\n        this._scrollHandler();\n      } else if (dstRect.top < headerBottom) {\n        this.$.table.scrollTop -= headerBottom - dstRect.top;\n        this._scrollHandler();\n      }\n    }\n\n    dstCell.focus();\n  }\n\n  _parseEventPath(path) {\n    const tableIndex = path.indexOf(this.$.table);\n    return {\n      rowGroup: path[tableIndex - 1],\n      row: path[tableIndex - 2],\n      cell: path[tableIndex - 3]\n    };\n  }\n\n  _onInteractionKeyDown(e, key) {\n    const localTarget = e.composedPath()[0];\n    const localTargetIsTextInput = localTarget.localName === 'input' &&\n      !/^(button|checkbox|color|file|image|radio|range|reset|submit)$/i.test(localTarget.type);\n\n    let wantInteracting;\n    switch (key) {\n      case 'Enter':\n        wantInteracting = this.hasAttribute('interacting') ? !localTargetIsTextInput : true;\n        break;\n      case 'Escape':\n        wantInteracting = false;\n        break;\n      case 'F2':\n        wantInteracting = !this.hasAttribute('interacting');\n        break;\n    }\n\n    const {cell} = this._parseEventPath(e.composedPath());\n\n    if (this.hasAttribute('interacting') !== wantInteracting) {\n      if (wantInteracting) {\n        const focusTarget = cell._content.querySelector('[focus-target]') ||\n          cell._content.firstElementChild;\n        if (focusTarget) {\n          e.preventDefault();\n          focusTarget.focus();\n          this._toggleAttribute('interacting', true, this);\n          this._toggleAttribute('navigating', false, this);\n        }\n      } else {\n        e.preventDefault();\n        this._focusedColumnOrder = undefined;\n        cell.focus();\n        this._toggleAttribute('interacting', false, this);\n        this._toggleAttribute('navigating', true, this);\n      }\n    }\n  }\n\n  _predictFocusStepTarget(srcElement, step) {\n    const tabOrder = [\n      this.$.table,\n      this._headerFocusable,\n      this._itemsFocusable,\n      this._footerFocusable,\n      this.$.focusexit\n    ];\n\n    let index = tabOrder.indexOf(srcElement);\n\n    index += step;\n    while (index >= 0 && index <= tabOrder.length - 1 &&\n        (!tabOrder[index] || tabOrder[index].parentNode.hidden)) {\n      index += step;\n    }\n\n    return tabOrder[index];\n  }\n\n  _onTabKeyDown(e) {\n    const focusTarget = this._predictFocusStepTarget(e.composedPath()[0], e.shiftKey ? -1 : 1);\n\n    if (focusTarget === this.$.table) {\n      // The focus is about to exit the grid to the top.\n      this.$.table.focus();\n    } else if (focusTarget === this.$.focusexit) {\n      // The focus is about to exit the grid to the bottom.\n      this.$.focusexit.focus();\n    } else if (focusTarget === this._itemsFocusable) {\n      let itemsFocusTarget = focusTarget;\n      const targetRow = this._itemsFocusable.parentNode;\n      this._ensureScrolledToIndex(this._focusedItemIndex);\n      if (targetRow.index !== this._focusedItemIndex) {\n        // The target row, which is about to be focused next, has been\n        // assigned with a new index since last focus, probably because of\n        // scrolling. Focus the row for the stored focused item index instead.\n        const columnIndex = Array.from(targetRow.children).indexOf(this._itemsFocusable);\n        const focusedItemRow = Array.from(this.$.items.children)\n          .filter(row => row.index === this._focusedItemIndex)[0];\n        if (focusedItemRow) {\n          itemsFocusTarget = focusedItemRow.children[columnIndex];\n        }\n      }\n      e.preventDefault();\n      itemsFocusTarget.focus();\n    } else {\n      e.preventDefault();\n      focusTarget.focus();\n    }\n\n    this._toggleAttribute('navigating', true, this);\n  }\n\n  _onSpaceKeyDown(e) {\n    e.preventDefault();\n\n    const cell = e.composedPath()[0];\n    if (cell._content && cell._content.firstElementChild) {\n      const wasNavigating = this.hasAttribute('navigating');\n      cell._content.firstElementChild.click();\n      this._toggleAttribute('navigating', wasNavigating, this);\n    } else {\n      this.dispatchEvent(new CustomEvent('cell-activate', {detail: {\n        model: this.__getRowModel(cell.parentElement)\n      }}));\n    }\n  }\n\n  _onFocusIn(e) {\n    if (!this._isMousedown) {\n      this._toggleAttribute('navigating', true, this);\n    }\n\n    const rootTarget = e.composedPath()[0];\n\n    if (rootTarget === this.$.table ||\n        rootTarget === this.$.focusexit) {\n      // The focus enters the top (bottom) of the grid, meaning that user has\n      // tabbed (shift-tabbed) into the grid. Move the focus to\n      // the first (the last) focusable.\n      this._predictFocusStepTarget(\n        rootTarget,\n        rootTarget === this.$.table ? 1 : -1\n      ).focus();\n      this._toggleAttribute('interacting', false, this);\n    } else {\n      this._detectInteracting(e);\n    }\n  }\n\n  _onFocusOut(e) {\n    this._toggleAttribute('navigating', false, this);\n    this._detectInteracting(e);\n  }\n\n  _onCellFocusIn(e) {\n    this._detectInteracting(e);\n\n    if (e.composedPath().indexOf(this.$.table) === 3) {\n      const cell = e.composedPath()[0];\n      this._activeRowGroup = cell.parentNode.parentNode;\n      if (this._activeRowGroup === this.$.header) {\n        this._headerFocusable = cell;\n      } else if (this._activeRowGroup === this.$.items) {\n        this._itemsFocusable = cell;\n      } else if (this._activeRowGroup === this.$.footer) {\n        this._footerFocusable = cell;\n      }\n      // Inform cell content of the focus (used in <vaadin-grid-sorter>)\n      cell._content.dispatchEvent(new CustomEvent('cell-focusin', {bubbles: false}));\n    }\n\n    this._detectFocusedItemIndex(e);\n  }\n\n  _onCellFocusOut(e) {\n    if (e.composedPath().indexOf(this.$.table) === 3) {\n      const cell = e.composedPath()[0];\n      // Inform cell content of the focus (used in <vaadin-grid-sorter>)\n      cell._content.dispatchEvent(new CustomEvent('cell-focusout', {bubbles: false}));\n    }\n  }\n\n  _detectInteracting(e) {\n    this._toggleAttribute('interacting',\n      e.composedPath().some(el => el.localName === 'vaadin-grid-cell-content'),\n      this);\n  }\n\n  _detectFocusedItemIndex(e) {\n    const {rowGroup, row} = this._parseEventPath(e.composedPath());\n    if (rowGroup === this.$.items) {\n      this._focusedItemIndex = row.index;\n    }\n  }\n\n  _preventScrollerRotatingCellFocus(item, index) {\n    if (item.index === this._focusedItemIndex && this.hasAttribute('navigating') && this._activeRowGroup === this.$.items) {\n      // Focused item has went, hide navigation mode\n      this._navigatingIsHidden = true;\n      this._toggleAttribute('navigating', false, this);\n    }\n    if (index === this._focusedItemIndex && this._navigatingIsHidden) {\n      // Focused item is back, restore navigation mode\n      this._navigatingIsHidden = false;\n      this._toggleAttribute('navigating', true, this);\n    }\n  }\n\n  _getColumns(rowGroup, rowIndex) {\n    let columnTreeLevel = this._columnTree.length - 1;\n    if (rowGroup === this.$.header) {\n      columnTreeLevel = rowIndex;\n    } else if (rowGroup === this.$.footer) {\n      columnTreeLevel = this._columnTree.length - 1 - rowIndex;\n    }\n    return this._columnTree[columnTreeLevel];\n  }\n\n  _resetKeyboardNavigation() {\n    if (this.$.header.firstElementChild) {\n      this._headerFocusable = Array.from(this.$.header.firstElementChild.children).filter(el => !el.hidden)[0];\n    }\n\n    if (this.$.items.firstElementChild) {\n      const firstVisibleIndexRow = this._iterateItems((pidx, vidx) => {\n        if (this._firstVisibleIndex === vidx) {\n          return this.$.items.children[pidx];\n        }\n      });\n      if (firstVisibleIndexRow) {\n        this._itemsFocusable = Array.from(firstVisibleIndexRow.children).filter(el => !el.hidden)[0];\n      }\n    }\n\n    if (this.$.footer.firstElementChild) {\n      this._footerFocusable = Array.from(this.$.footer.firstElementChild.children).filter(el => !el.hidden)[0];\n    }\n  }\n\n  _scrollHorizontallyToCell(dstCell) {\n    if (dstCell.hasAttribute('frozen') || this._elementMatches(dstCell, '[part~=\"details-cell\"]')) {\n      // These cells are, by design, always visible, no need to scroll.\n      return;\n    }\n\n    const dstCellRect = dstCell.getBoundingClientRect();\n    const dstRow = dstCell.parentNode;\n    const dstCellIndex = Array.from(dstRow.children).indexOf(dstCell);\n    const tableRect = this.$.table.getBoundingClientRect();\n    let leftBoundary = tableRect.left, rightBoundary = tableRect.right;\n    for (let i = dstCellIndex - 1; i >= 0; i--) {\n      const cell = dstRow.children[i];\n      if (cell.hasAttribute('hidden') ||\n          this._elementMatches(cell, '[part~=\"details-cell\"]')) {\n        continue;\n      }\n      if (cell.hasAttribute('frozen')) {\n        leftBoundary = cell.getBoundingClientRect().right;\n        break;\n      }\n    }\n    for (let i = dstCellIndex + 1; i < dstRow.children.length; i++) {\n      const cell = dstRow.children[i];\n      if (cell.hasAttribute('hidden') ||\n          this._elementMatches(cell, '[part~=\"details-cell\"]')) {\n        continue;\n      }\n      if (cell.hasAttribute('frozen')) {\n        rightBoundary = cell.getBoundingClientRect().left;\n        break;\n      }\n    }\n\n    if (dstCellRect.left < leftBoundary) {\n      this.$.table.scrollLeft += Math.round(dstCellRect.left - leftBoundary);\n    }\n    if (dstCellRect.right > rightBoundary) {\n      this.$.table.scrollLeft += Math.round(dstCellRect.right - rightBoundary);\n    }\n  }\n\n  _elementMatches(el, query) {\n    return el.matches ? el.matches(query) :\n      Array.from(el.parentNode.querySelectorAll(query)).indexOf(el) !== -1;\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}