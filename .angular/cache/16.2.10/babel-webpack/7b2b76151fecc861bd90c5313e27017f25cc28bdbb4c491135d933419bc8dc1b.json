{"ast":null,"code":"/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n/*\n * The apply shim simulates the behavior of `@apply` proposed at\n * https://tabatkins.github.io/specs/css-apply-rule/.\n * The approach is to convert a property like this:\n *\n *    --foo: {color: red; background: blue;}\n *\n * to this:\n *\n *    --foo_-_color: red;\n *    --foo_-_background: blue;\n *\n * Then where `@apply --foo` is used, that is converted to:\n *\n *    color: var(--foo_-_color);\n *    background: var(--foo_-_background);\n *\n * This approach generally works but there are some issues and limitations.\n * Consider, for example, that somewhere *between* where `--foo` is set and used,\n * another element sets it to:\n *\n *    --foo: { border: 2px solid red; }\n *\n * We must now ensure that the color and background from the previous setting\n * do not apply. This is accomplished by changing the property set to this:\n *\n *    --foo_-_border: 2px solid red;\n *    --foo_-_color: initial;\n *    --foo_-_background: initial;\n *\n * This works but introduces one new issue.\n * Consider this setup at the point where the `@apply` is used:\n *\n *    background: orange;\n *    `@apply` --foo;\n *\n * In this case the background will be unset (initial) rather than the desired\n * `orange`. We address this by altering the property set to use a fallback\n * value like this:\n *\n *    color: var(--foo_-_color);\n *    background: var(--foo_-_background, orange);\n *    border: var(--foo_-_border);\n *\n * Note that the default is retained in the property set and the `background` is\n * the desired `orange`. This leads us to a limitation.\n *\n * Limitation 1:\n\n * Only properties in the rule where the `@apply`\n * is used are considered as default values.\n * If another rule matches the element and sets `background` with\n * less specificity than the rule in which `@apply` appears,\n * the `background` will not be set.\n *\n * Limitation 2:\n *\n * When using Polymer's `updateStyles` api, new properties may not be set for\n * `@apply` properties.\n\n*/\n\n'use strict';\n\nimport { forEachRule, processVariableAndFallback, rulesForStyle, toCssText, gatherStyleText } from './style-util.js';\nimport { MIXIN_MATCH, VAR_ASSIGN } from './common-regex.js';\nimport { detectMixin } from './common-utils.js';\nimport { StyleNode } from './css-parse.js'; // eslint-disable-line no-unused-vars\n\nconst APPLY_NAME_CLEAN = /;\\s*/m;\nconst INITIAL_INHERIT = /^\\s*(initial)|(inherit)\\s*$/;\nconst IMPORTANT = /\\s*!important/;\n\n// separator used between mixin-name and mixin-property-name when producing properties\n// NOTE: plain '-' may cause collisions in user styles\nconst MIXIN_VAR_SEP = '_-_';\n\n/**\n * @typedef {!Object<string, string>}\n */\nlet PropertyEntry; // eslint-disable-line no-unused-vars\n\n/**\n * @typedef {!Object<string, boolean>}\n */\nlet DependantsEntry; // eslint-disable-line no-unused-vars\n\n/** @typedef {{\n *    properties: PropertyEntry,\n *    dependants: DependantsEntry\n * }}\n */\nlet MixinMapEntry; // eslint-disable-line no-unused-vars\n\n// map of mixin to property names\n// --foo: {border: 2px} -> {properties: {(--foo, ['border'])}, dependants: {'element-name': proto}}\nclass MixinMap {\n  constructor() {\n    /** @type {!Object<string, !MixinMapEntry>} */\n    this._map = {};\n  }\n  /**\n   * @param {string} name\n   * @param {!PropertyEntry} props\n   */\n  set(name, props) {\n    name = name.trim();\n    this._map[name] = {\n      properties: props,\n      dependants: {}\n    };\n  }\n  /**\n   * @param {string} name\n   * @return {MixinMapEntry}\n   */\n  get(name) {\n    name = name.trim();\n    return this._map[name] || null;\n  }\n}\n\n/**\n * Callback for when an element is marked invalid\n * @type {?function(string)}\n */\nlet invalidCallback = null;\n\n/** @unrestricted */\nclass ApplyShim {\n  constructor() {\n    /** @type {?string} */\n    this._currentElement = null;\n    /** @type {HTMLMetaElement} */\n    this._measureElement = null;\n    this._map = new MixinMap();\n  }\n  /**\n   * return true if `cssText` contains a mixin definition or consumption\n   * @param {string} cssText\n   * @return {boolean}\n   */\n  detectMixin(cssText) {\n    return detectMixin(cssText);\n  }\n\n  /**\n   * Gather styles into one style for easier processing\n   * @param {!HTMLTemplateElement} template\n   * @return {HTMLStyleElement}\n   */\n  gatherStyles(template) {\n    const styleText = gatherStyleText(template.content);\n    if (styleText) {\n      const style = /** @type {!HTMLStyleElement} */document.createElement('style');\n      style.textContent = styleText;\n      template.content.insertBefore(style, template.content.firstChild);\n      return style;\n    }\n    return null;\n  }\n  /**\n   * @param {!HTMLTemplateElement} template\n   * @param {string} elementName\n   * @return {StyleNode}\n   */\n  transformTemplate(template, elementName) {\n    if (template._gatheredStyle === undefined) {\n      template._gatheredStyle = this.gatherStyles(template);\n    }\n    /** @type {HTMLStyleElement} */\n    const style = template._gatheredStyle;\n    return style ? this.transformStyle(style, elementName) : null;\n  }\n  /**\n   * @param {!HTMLStyleElement} style\n   * @param {string} elementName\n   * @return {StyleNode}\n   */\n  transformStyle(style, elementName = '') {\n    let ast = rulesForStyle(style);\n    this.transformRules(ast, elementName);\n    style.textContent = toCssText(ast);\n    return ast;\n  }\n  /**\n   * @param {!HTMLStyleElement} style\n   * @return {StyleNode}\n   */\n  transformCustomStyle(style) {\n    let ast = rulesForStyle(style);\n    forEachRule(ast, rule => {\n      if (rule['selector'] === ':root') {\n        rule['selector'] = 'html';\n      }\n      this.transformRule(rule);\n    });\n    style.textContent = toCssText(ast);\n    return ast;\n  }\n  /**\n   * @param {StyleNode} rules\n   * @param {string} elementName\n   */\n  transformRules(rules, elementName) {\n    this._currentElement = elementName;\n    forEachRule(rules, r => {\n      this.transformRule(r);\n    });\n    this._currentElement = null;\n  }\n  /**\n   * @param {!StyleNode} rule\n   */\n  transformRule(rule) {\n    rule['cssText'] = this.transformCssText(rule['parsedCssText'], rule);\n    // :root was only used for variable assignment in property shim,\n    // but generates invalid selectors with real properties.\n    // replace with `:host > *`, which serves the same effect\n    if (rule['selector'] === ':root') {\n      rule['selector'] = ':host > *';\n    }\n  }\n  /**\n   * @param {string} cssText\n   * @param {!StyleNode} rule\n   * @return {string}\n   */\n  transformCssText(cssText, rule) {\n    // produce variables\n    cssText = cssText.replace(VAR_ASSIGN, (matchText, propertyName, valueProperty, valueMixin) => this._produceCssProperties(matchText, propertyName, valueProperty, valueMixin, rule));\n    // consume mixins\n    return this._consumeCssProperties(cssText, rule);\n  }\n  /**\n   * @param {string} property\n   * @return {string}\n   */\n  _getInitialValueForProperty(property) {\n    if (!this._measureElement) {\n      this._measureElement = /** @type {HTMLMetaElement} */document.createElement('meta');\n      this._measureElement.setAttribute('apply-shim-measure', '');\n      this._measureElement.style.all = 'initial';\n      document.head.appendChild(this._measureElement);\n    }\n    return window.getComputedStyle(this._measureElement).getPropertyValue(property);\n  }\n  /**\n   * Walk over all rules before this rule to find fallbacks for mixins\n   *\n   * @param {!StyleNode} startRule\n   * @return {!Object}\n   */\n  _fallbacksFromPreviousRules(startRule) {\n    // find the \"top\" rule\n    let topRule = startRule;\n    while (topRule['parent']) {\n      topRule = topRule['parent'];\n    }\n    const fallbacks = {};\n    let seenStartRule = false;\n    forEachRule(topRule, r => {\n      // stop when we hit the input rule\n      seenStartRule = seenStartRule || r === startRule;\n      if (seenStartRule) {\n        return;\n      }\n      // NOTE: Only matching selectors are \"safe\" for this fallback processing\n      // It would be prohibitive to run `matchesSelector()` on each selector,\n      // so we cheat and only check if the same selector string is used, which\n      // guarantees things like specificity matching\n      if (r['selector'] === startRule['selector']) {\n        Object.assign(fallbacks, this._cssTextToMap(r['parsedCssText']));\n      }\n    });\n    return fallbacks;\n  }\n  /**\n   * replace mixin consumption with variable consumption\n   * @param {string} text\n   * @param {!StyleNode=} rule\n   * @return {string}\n   */\n  _consumeCssProperties(text, rule) {\n    /** @type {Array} */\n    let m = null;\n    // loop over text until all mixins with defintions have been applied\n    while (m = MIXIN_MATCH.exec(text)) {\n      let matchText = m[0];\n      let mixinName = m[1];\n      let idx = m.index;\n      // collect properties before apply to be \"defaults\" if mixin might override them\n      // match includes a \"prefix\", so find the start and end positions of @apply\n      let applyPos = idx + matchText.indexOf('@apply');\n      let afterApplyPos = idx + matchText.length;\n      // find props defined before this @apply\n      let textBeforeApply = text.slice(0, applyPos);\n      let textAfterApply = text.slice(afterApplyPos);\n      let defaults = rule ? this._fallbacksFromPreviousRules(rule) : {};\n      Object.assign(defaults, this._cssTextToMap(textBeforeApply));\n      let replacement = this._atApplyToCssProperties(mixinName, defaults);\n      // use regex match position to replace mixin, keep linear processing time\n      text = `${textBeforeApply}${replacement}${textAfterApply}`;\n      // move regex search to _after_ replacement\n      MIXIN_MATCH.lastIndex = idx + replacement.length;\n    }\n    return text;\n  }\n  /**\n   * produce variable consumption at the site of mixin consumption\n   * `@apply` --foo; -> for all props (${propname}: var(--foo_-_${propname}, ${fallback[propname]}}))\n   * Example:\n   *  border: var(--foo_-_border); padding: var(--foo_-_padding, 2px)\n   *\n   * @param {string} mixinName\n   * @param {Object} fallbacks\n   * @return {string}\n   */\n  _atApplyToCssProperties(mixinName, fallbacks) {\n    mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');\n    let vars = [];\n    let mixinEntry = this._map.get(mixinName);\n    // if we depend on a mixin before it is created\n    // make a sentinel entry in the map to add this element as a dependency for when it is defined.\n    if (!mixinEntry) {\n      this._map.set(mixinName, {});\n      mixinEntry = this._map.get(mixinName);\n    }\n    if (mixinEntry) {\n      if (this._currentElement) {\n        mixinEntry.dependants[this._currentElement] = true;\n      }\n      let p, parts, f;\n      const properties = mixinEntry.properties;\n      for (p in properties) {\n        f = fallbacks && fallbacks[p];\n        parts = [p, ': var(', mixinName, MIXIN_VAR_SEP, p];\n        if (f) {\n          parts.push(',', f.replace(IMPORTANT, ''));\n        }\n        parts.push(')');\n        if (IMPORTANT.test(properties[p])) {\n          parts.push(' !important');\n        }\n        vars.push(parts.join(''));\n      }\n    }\n    return vars.join('; ');\n  }\n\n  /**\n   * @param {string} property\n   * @param {string} value\n   * @return {string}\n   */\n  _replaceInitialOrInherit(property, value) {\n    let match = INITIAL_INHERIT.exec(value);\n    if (match) {\n      if (match[1]) {\n        // initial\n        // replace `initial` with the concrete initial value for this property\n        value = this._getInitialValueForProperty(property);\n      } else {\n        // inherit\n        // with this purposfully illegal value, the variable will be invalid at\n        // compute time (https://www.w3.org/TR/css-variables/#invalid-at-computed-value-time)\n        // and for inheriting values, will behave similarly\n        // we cannot support the same behavior for non inheriting values like 'border'\n        value = 'apply-shim-inherit';\n      }\n    }\n    return value;\n  }\n\n  /**\n   * \"parse\" a mixin definition into a map of properties and values\n   * cssTextToMap('border: 2px solid black') -> ('border', '2px solid black')\n   * @param {string} text\n   * @param {boolean=} replaceInitialOrInherit\n   * @return {!Object<string, string>}\n   */\n  _cssTextToMap(text, replaceInitialOrInherit = false) {\n    let props = text.split(';');\n    let property, value;\n    let out = {};\n    for (let i = 0, p, sp; i < props.length; i++) {\n      p = props[i];\n      if (p) {\n        sp = p.split(':');\n        // ignore lines that aren't definitions like @media\n        if (sp.length > 1) {\n          property = sp[0].trim();\n          // some properties may have ':' in the value, like data urls\n          value = sp.slice(1).join(':');\n          if (replaceInitialOrInherit) {\n            value = this._replaceInitialOrInherit(property, value);\n          }\n          out[property] = value;\n        }\n      }\n    }\n    return out;\n  }\n\n  /**\n   * @param {MixinMapEntry} mixinEntry\n   */\n  _invalidateMixinEntry(mixinEntry) {\n    if (!invalidCallback) {\n      return;\n    }\n    for (let elementName in mixinEntry.dependants) {\n      if (elementName !== this._currentElement) {\n        invalidCallback(elementName);\n      }\n    }\n  }\n\n  /**\n   * @param {string} matchText\n   * @param {string} propertyName\n   * @param {?string} valueProperty\n   * @param {?string} valueMixin\n   * @param {!StyleNode} rule\n   * @return {string}\n   */\n  _produceCssProperties(matchText, propertyName, valueProperty, valueMixin, rule) {\n    // handle case where property value is a mixin\n    if (valueProperty) {\n      // form: --mixin2: var(--mixin1), where --mixin1 is in the map\n      processVariableAndFallback(valueProperty, (prefix, value) => {\n        if (value && this._map.get(value)) {\n          valueMixin = `@apply ${value};`;\n        }\n      });\n    }\n    if (!valueMixin) {\n      return matchText;\n    }\n    let mixinAsProperties = this._consumeCssProperties('' + valueMixin, rule);\n    let prefix = matchText.slice(0, matchText.indexOf('--'));\n    // `initial` and `inherit` as properties in a map should be replaced because\n    // these keywords are eagerly evaluated when the mixin becomes CSS Custom Properties,\n    // and would set the variable value, rather than carry the keyword to the `var()` usage.\n    let mixinValues = this._cssTextToMap(mixinAsProperties, true);\n    let combinedProps = mixinValues;\n    let mixinEntry = this._map.get(propertyName);\n    let oldProps = mixinEntry && mixinEntry.properties;\n    if (oldProps) {\n      // NOTE: since we use mixin, the map of properties is updated here\n      // and this is what we want.\n      combinedProps = Object.assign(Object.create(oldProps), mixinValues);\n    } else {\n      this._map.set(propertyName, combinedProps);\n    }\n    let out = [];\n    let p, v;\n    // set variables defined by current mixin\n    let needToInvalidate = false;\n    for (p in combinedProps) {\n      v = mixinValues[p];\n      // if property not defined by current mixin, set initial\n      if (v === undefined) {\n        v = 'initial';\n      }\n      if (oldProps && !(p in oldProps)) {\n        needToInvalidate = true;\n      }\n      out.push(`${propertyName}${MIXIN_VAR_SEP}${p}: ${v}`);\n    }\n    if (needToInvalidate) {\n      this._invalidateMixinEntry(mixinEntry);\n    }\n    if (mixinEntry) {\n      mixinEntry.properties = combinedProps;\n    }\n    // because the mixinMap is global, the mixin might conflict with\n    // a different scope's simple variable definition:\n    // Example:\n    // some style somewhere:\n    // --mixin1:{ ... }\n    // --mixin2: var(--mixin1);\n    // some other element:\n    // --mixin1: 10px solid red;\n    // --foo: var(--mixin1);\n    // In this case, we leave the original variable definition in place.\n    if (valueProperty) {\n      prefix = `${matchText};${prefix}`;\n    }\n    return `${prefix}${out.join('; ')};`;\n  }\n}\n\n/* exports */\n/* eslint-disable no-self-assign */\nApplyShim.prototype['detectMixin'] = ApplyShim.prototype.detectMixin;\nApplyShim.prototype['transformStyle'] = ApplyShim.prototype.transformStyle;\nApplyShim.prototype['transformCustomStyle'] = ApplyShim.prototype.transformCustomStyle;\nApplyShim.prototype['transformRules'] = ApplyShim.prototype.transformRules;\nApplyShim.prototype['transformRule'] = ApplyShim.prototype.transformRule;\nApplyShim.prototype['transformTemplate'] = ApplyShim.prototype.transformTemplate;\nApplyShim.prototype['_separator'] = MIXIN_VAR_SEP;\n/* eslint-enable no-self-assign */\nObject.defineProperty(ApplyShim.prototype, 'invalidCallback', {\n  /** @return {?function(string)} */\n  get() {\n    return invalidCallback;\n  },\n  /** @param {?function(string)} cb */\n  set(cb) {\n    invalidCallback = cb;\n  }\n});\nexport default ApplyShim;","map":{"version":3,"names":["forEachRule","processVariableAndFallback","rulesForStyle","toCssText","gatherStyleText","MIXIN_MATCH","VAR_ASSIGN","detectMixin","StyleNode","APPLY_NAME_CLEAN","INITIAL_INHERIT","IMPORTANT","MIXIN_VAR_SEP","PropertyEntry","DependantsEntry","MixinMapEntry","MixinMap","constructor","_map","set","name","props","trim","properties","dependants","get","invalidCallback","ApplyShim","_currentElement","_measureElement","cssText","gatherStyles","template","styleText","content","style","document","createElement","textContent","insertBefore","firstChild","transformTemplate","elementName","_gatheredStyle","undefined","transformStyle","ast","transformRules","transformCustomStyle","rule","transformRule","rules","r","transformCssText","replace","matchText","propertyName","valueProperty","valueMixin","_produceCssProperties","_consumeCssProperties","_getInitialValueForProperty","property","setAttribute","all","head","appendChild","window","getComputedStyle","getPropertyValue","_fallbacksFromPreviousRules","startRule","topRule","fallbacks","seenStartRule","Object","assign","_cssTextToMap","text","m","exec","mixinName","idx","index","applyPos","indexOf","afterApplyPos","length","textBeforeApply","slice","textAfterApply","defaults","replacement","_atApplyToCssProperties","lastIndex","vars","mixinEntry","p","parts","f","push","test","join","_replaceInitialOrInherit","value","match","replaceInitialOrInherit","split","out","i","sp","_invalidateMixinEntry","prefix","mixinAsProperties","mixinValues","combinedProps","oldProps","create","v","needToInvalidate","prototype","defineProperty","cb"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@webcomponents/shadycss/src/apply-shim.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n/*\n * The apply shim simulates the behavior of `@apply` proposed at\n * https://tabatkins.github.io/specs/css-apply-rule/.\n * The approach is to convert a property like this:\n *\n *    --foo: {color: red; background: blue;}\n *\n * to this:\n *\n *    --foo_-_color: red;\n *    --foo_-_background: blue;\n *\n * Then where `@apply --foo` is used, that is converted to:\n *\n *    color: var(--foo_-_color);\n *    background: var(--foo_-_background);\n *\n * This approach generally works but there are some issues and limitations.\n * Consider, for example, that somewhere *between* where `--foo` is set and used,\n * another element sets it to:\n *\n *    --foo: { border: 2px solid red; }\n *\n * We must now ensure that the color and background from the previous setting\n * do not apply. This is accomplished by changing the property set to this:\n *\n *    --foo_-_border: 2px solid red;\n *    --foo_-_color: initial;\n *    --foo_-_background: initial;\n *\n * This works but introduces one new issue.\n * Consider this setup at the point where the `@apply` is used:\n *\n *    background: orange;\n *    `@apply` --foo;\n *\n * In this case the background will be unset (initial) rather than the desired\n * `orange`. We address this by altering the property set to use a fallback\n * value like this:\n *\n *    color: var(--foo_-_color);\n *    background: var(--foo_-_background, orange);\n *    border: var(--foo_-_border);\n *\n * Note that the default is retained in the property set and the `background` is\n * the desired `orange`. This leads us to a limitation.\n *\n * Limitation 1:\n\n * Only properties in the rule where the `@apply`\n * is used are considered as default values.\n * If another rule matches the element and sets `background` with\n * less specificity than the rule in which `@apply` appears,\n * the `background` will not be set.\n *\n * Limitation 2:\n *\n * When using Polymer's `updateStyles` api, new properties may not be set for\n * `@apply` properties.\n\n*/\n\n'use strict';\n\nimport {forEachRule, processVariableAndFallback, rulesForStyle, toCssText, gatherStyleText} from './style-util.js';\nimport {MIXIN_MATCH, VAR_ASSIGN} from './common-regex.js';\nimport {detectMixin} from './common-utils.js';\nimport {StyleNode} from './css-parse.js'; // eslint-disable-line no-unused-vars\n\nconst APPLY_NAME_CLEAN = /;\\s*/m;\nconst INITIAL_INHERIT = /^\\s*(initial)|(inherit)\\s*$/;\nconst IMPORTANT = /\\s*!important/;\n\n// separator used between mixin-name and mixin-property-name when producing properties\n// NOTE: plain '-' may cause collisions in user styles\nconst MIXIN_VAR_SEP = '_-_';\n\n/**\n * @typedef {!Object<string, string>}\n */\nlet PropertyEntry; // eslint-disable-line no-unused-vars\n\n/**\n * @typedef {!Object<string, boolean>}\n */\nlet DependantsEntry; // eslint-disable-line no-unused-vars\n\n/** @typedef {{\n *    properties: PropertyEntry,\n *    dependants: DependantsEntry\n * }}\n */\nlet MixinMapEntry; // eslint-disable-line no-unused-vars\n\n// map of mixin to property names\n// --foo: {border: 2px} -> {properties: {(--foo, ['border'])}, dependants: {'element-name': proto}}\nclass MixinMap {\n  constructor() {\n    /** @type {!Object<string, !MixinMapEntry>} */\n    this._map = {};\n  }\n  /**\n   * @param {string} name\n   * @param {!PropertyEntry} props\n   */\n  set(name, props) {\n    name = name.trim();\n    this._map[name] = {\n      properties: props,\n      dependants: {}\n    }\n  }\n  /**\n   * @param {string} name\n   * @return {MixinMapEntry}\n   */\n  get(name) {\n    name = name.trim();\n    return this._map[name] || null;\n  }\n}\n\n/**\n * Callback for when an element is marked invalid\n * @type {?function(string)}\n */\nlet invalidCallback = null;\n\n/** @unrestricted */\nclass ApplyShim {\n  constructor() {\n    /** @type {?string} */\n    this._currentElement = null;\n    /** @type {HTMLMetaElement} */\n    this._measureElement = null;\n    this._map = new MixinMap();\n  }\n  /**\n   * return true if `cssText` contains a mixin definition or consumption\n   * @param {string} cssText\n   * @return {boolean}\n   */\n  detectMixin(cssText) {\n    return detectMixin(cssText);\n  }\n\n  /**\n   * Gather styles into one style for easier processing\n   * @param {!HTMLTemplateElement} template\n   * @return {HTMLStyleElement}\n   */\n  gatherStyles(template) {\n    const styleText = gatherStyleText(template.content);\n    if (styleText) {\n      const style = /** @type {!HTMLStyleElement} */(document.createElement('style'));\n      style.textContent = styleText;\n      template.content.insertBefore(style, template.content.firstChild);\n      return style;\n    }\n    return null;\n  }\n  /**\n   * @param {!HTMLTemplateElement} template\n   * @param {string} elementName\n   * @return {StyleNode}\n   */\n  transformTemplate(template, elementName) {\n    if (template._gatheredStyle === undefined) {\n      template._gatheredStyle = this.gatherStyles(template);\n    }\n    /** @type {HTMLStyleElement} */\n    const style = template._gatheredStyle;\n    return style ? this.transformStyle(style, elementName) : null;\n  }\n  /**\n   * @param {!HTMLStyleElement} style\n   * @param {string} elementName\n   * @return {StyleNode}\n   */\n  transformStyle(style, elementName = '') {\n    let ast = rulesForStyle(style);\n    this.transformRules(ast, elementName);\n    style.textContent = toCssText(ast);\n    return ast;\n  }\n  /**\n   * @param {!HTMLStyleElement} style\n   * @return {StyleNode}\n   */\n  transformCustomStyle(style) {\n    let ast = rulesForStyle(style);\n    forEachRule(ast, (rule) => {\n      if (rule['selector'] === ':root') {\n        rule['selector'] = 'html';\n      }\n      this.transformRule(rule);\n    })\n    style.textContent = toCssText(ast);\n    return ast;\n  }\n  /**\n   * @param {StyleNode} rules\n   * @param {string} elementName\n   */\n  transformRules(rules, elementName) {\n    this._currentElement = elementName;\n    forEachRule(rules, (r) => {\n      this.transformRule(r);\n    });\n    this._currentElement = null;\n  }\n  /**\n   * @param {!StyleNode} rule\n   */\n  transformRule(rule) {\n    rule['cssText'] = this.transformCssText(rule['parsedCssText'], rule);\n    // :root was only used for variable assignment in property shim,\n    // but generates invalid selectors with real properties.\n    // replace with `:host > *`, which serves the same effect\n    if (rule['selector'] === ':root') {\n      rule['selector'] = ':host > *';\n    }\n  }\n  /**\n   * @param {string} cssText\n   * @param {!StyleNode} rule\n   * @return {string}\n   */\n  transformCssText(cssText, rule) {\n    // produce variables\n    cssText = cssText.replace(VAR_ASSIGN, (matchText, propertyName, valueProperty, valueMixin) =>\n      this._produceCssProperties(matchText, propertyName, valueProperty, valueMixin, rule));\n    // consume mixins\n    return this._consumeCssProperties(cssText, rule);\n  }\n  /**\n   * @param {string} property\n   * @return {string}\n   */\n  _getInitialValueForProperty(property) {\n    if (!this._measureElement) {\n      this._measureElement = /** @type {HTMLMetaElement} */(document.createElement('meta'));\n      this._measureElement.setAttribute('apply-shim-measure', '');\n      this._measureElement.style.all = 'initial';\n      document.head.appendChild(this._measureElement);\n    }\n    return window.getComputedStyle(this._measureElement).getPropertyValue(property);\n  }\n  /**\n   * Walk over all rules before this rule to find fallbacks for mixins\n   *\n   * @param {!StyleNode} startRule\n   * @return {!Object}\n   */\n  _fallbacksFromPreviousRules(startRule) {\n    // find the \"top\" rule\n    let topRule = startRule;\n    while (topRule['parent']) {\n      topRule = topRule['parent'];\n    }\n    const fallbacks = {};\n    let seenStartRule = false;\n    forEachRule(topRule, (r) => {\n      // stop when we hit the input rule\n      seenStartRule = seenStartRule || r === startRule;\n      if (seenStartRule) {\n        return;\n      }\n      // NOTE: Only matching selectors are \"safe\" for this fallback processing\n      // It would be prohibitive to run `matchesSelector()` on each selector,\n      // so we cheat and only check if the same selector string is used, which\n      // guarantees things like specificity matching\n      if (r['selector'] === startRule['selector']) {\n        Object.assign(fallbacks, this._cssTextToMap(r['parsedCssText']));\n      }\n    });\n    return fallbacks;\n  }\n  /**\n   * replace mixin consumption with variable consumption\n   * @param {string} text\n   * @param {!StyleNode=} rule\n   * @return {string}\n   */\n  _consumeCssProperties(text, rule) {\n    /** @type {Array} */\n    let m = null;\n    // loop over text until all mixins with defintions have been applied\n    while((m = MIXIN_MATCH.exec(text))) {\n      let matchText = m[0];\n      let mixinName = m[1];\n      let idx = m.index;\n      // collect properties before apply to be \"defaults\" if mixin might override them\n      // match includes a \"prefix\", so find the start and end positions of @apply\n      let applyPos = idx + matchText.indexOf('@apply');\n      let afterApplyPos = idx + matchText.length;\n      // find props defined before this @apply\n      let textBeforeApply = text.slice(0, applyPos);\n      let textAfterApply = text.slice(afterApplyPos);\n      let defaults = rule ? this._fallbacksFromPreviousRules(rule) : {};\n      Object.assign(defaults, this._cssTextToMap(textBeforeApply));\n      let replacement = this._atApplyToCssProperties(mixinName, defaults);\n      // use regex match position to replace mixin, keep linear processing time\n      text = `${textBeforeApply}${replacement}${textAfterApply}`;\n      // move regex search to _after_ replacement\n      MIXIN_MATCH.lastIndex = idx + replacement.length;\n    }\n    return text;\n  }\n  /**\n   * produce variable consumption at the site of mixin consumption\n   * `@apply` --foo; -> for all props (${propname}: var(--foo_-_${propname}, ${fallback[propname]}}))\n   * Example:\n   *  border: var(--foo_-_border); padding: var(--foo_-_padding, 2px)\n   *\n   * @param {string} mixinName\n   * @param {Object} fallbacks\n   * @return {string}\n   */\n  _atApplyToCssProperties(mixinName, fallbacks) {\n    mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');\n    let vars = [];\n    let mixinEntry = this._map.get(mixinName);\n    // if we depend on a mixin before it is created\n    // make a sentinel entry in the map to add this element as a dependency for when it is defined.\n    if (!mixinEntry) {\n      this._map.set(mixinName, {});\n      mixinEntry = this._map.get(mixinName);\n    }\n    if (mixinEntry) {\n      if (this._currentElement) {\n        mixinEntry.dependants[this._currentElement] = true;\n      }\n      let p, parts, f;\n      const properties = mixinEntry.properties;\n      for (p in properties) {\n        f = fallbacks && fallbacks[p];\n        parts = [p, ': var(', mixinName, MIXIN_VAR_SEP, p];\n        if (f) {\n          parts.push(',', f.replace(IMPORTANT, ''));\n        }\n        parts.push(')');\n        if (IMPORTANT.test(properties[p])) {\n          parts.push(' !important');\n        }\n        vars.push(parts.join(''));\n      }\n    }\n    return vars.join('; ');\n  }\n\n  /**\n   * @param {string} property\n   * @param {string} value\n   * @return {string}\n   */\n  _replaceInitialOrInherit(property, value) {\n    let match = INITIAL_INHERIT.exec(value);\n    if (match) {\n      if (match[1]) {\n        // initial\n        // replace `initial` with the concrete initial value for this property\n        value = this._getInitialValueForProperty(property);\n      } else {\n        // inherit\n        // with this purposfully illegal value, the variable will be invalid at\n        // compute time (https://www.w3.org/TR/css-variables/#invalid-at-computed-value-time)\n        // and for inheriting values, will behave similarly\n        // we cannot support the same behavior for non inheriting values like 'border'\n        value = 'apply-shim-inherit';\n      }\n    }\n    return value;\n  }\n\n  /**\n   * \"parse\" a mixin definition into a map of properties and values\n   * cssTextToMap('border: 2px solid black') -> ('border', '2px solid black')\n   * @param {string} text\n   * @param {boolean=} replaceInitialOrInherit\n   * @return {!Object<string, string>}\n   */\n  _cssTextToMap(text, replaceInitialOrInherit = false) {\n    let props = text.split(';');\n    let property, value;\n    let out = {};\n    for (let i = 0, p, sp; i < props.length; i++) {\n      p = props[i];\n      if (p) {\n        sp = p.split(':');\n        // ignore lines that aren't definitions like @media\n        if (sp.length > 1) {\n          property = sp[0].trim();\n          // some properties may have ':' in the value, like data urls\n          value = sp.slice(1).join(':');\n          if (replaceInitialOrInherit) {\n            value = this._replaceInitialOrInherit(property, value);\n          }\n          out[property] = value;\n        }\n      }\n    }\n    return out;\n  }\n\n  /**\n   * @param {MixinMapEntry} mixinEntry\n   */\n  _invalidateMixinEntry(mixinEntry) {\n    if (!invalidCallback) {\n      return;\n    }\n    for (let elementName in mixinEntry.dependants) {\n      if (elementName !== this._currentElement) {\n        invalidCallback(elementName);\n      }\n    }\n  }\n\n  /**\n   * @param {string} matchText\n   * @param {string} propertyName\n   * @param {?string} valueProperty\n   * @param {?string} valueMixin\n   * @param {!StyleNode} rule\n   * @return {string}\n   */\n  _produceCssProperties(matchText, propertyName, valueProperty, valueMixin, rule) {\n    // handle case where property value is a mixin\n    if (valueProperty) {\n      // form: --mixin2: var(--mixin1), where --mixin1 is in the map\n      processVariableAndFallback(valueProperty, (prefix, value) => {\n        if (value && this._map.get(value)) {\n          valueMixin = `@apply ${value};`\n        }\n      });\n    }\n    if (!valueMixin) {\n      return matchText;\n    }\n    let mixinAsProperties = this._consumeCssProperties('' + valueMixin, rule);\n    let prefix = matchText.slice(0, matchText.indexOf('--'));\n    // `initial` and `inherit` as properties in a map should be replaced because\n    // these keywords are eagerly evaluated when the mixin becomes CSS Custom Properties,\n    // and would set the variable value, rather than carry the keyword to the `var()` usage.\n    let mixinValues = this._cssTextToMap(mixinAsProperties, true);\n    let combinedProps = mixinValues;\n    let mixinEntry = this._map.get(propertyName);\n    let oldProps = mixinEntry && mixinEntry.properties;\n    if (oldProps) {\n      // NOTE: since we use mixin, the map of properties is updated here\n      // and this is what we want.\n      combinedProps = Object.assign(Object.create(oldProps), mixinValues);\n    } else {\n      this._map.set(propertyName, combinedProps);\n    }\n    let out = [];\n    let p, v;\n    // set variables defined by current mixin\n    let needToInvalidate = false;\n    for (p in combinedProps) {\n      v = mixinValues[p];\n      // if property not defined by current mixin, set initial\n      if (v === undefined) {\n        v = 'initial';\n      }\n      if (oldProps && !(p in oldProps)) {\n        needToInvalidate = true;\n      }\n      out.push(`${propertyName}${MIXIN_VAR_SEP}${p}: ${v}`);\n    }\n    if (needToInvalidate) {\n      this._invalidateMixinEntry(mixinEntry);\n    }\n    if (mixinEntry) {\n      mixinEntry.properties = combinedProps;\n    }\n    // because the mixinMap is global, the mixin might conflict with\n    // a different scope's simple variable definition:\n    // Example:\n    // some style somewhere:\n    // --mixin1:{ ... }\n    // --mixin2: var(--mixin1);\n    // some other element:\n    // --mixin1: 10px solid red;\n    // --foo: var(--mixin1);\n    // In this case, we leave the original variable definition in place.\n    if (valueProperty) {\n      prefix = `${matchText};${prefix}`;\n    }\n    return `${prefix}${out.join('; ')};`;\n  }\n}\n\n/* exports */\n/* eslint-disable no-self-assign */\nApplyShim.prototype['detectMixin'] = ApplyShim.prototype.detectMixin;\nApplyShim.prototype['transformStyle'] = ApplyShim.prototype.transformStyle;\nApplyShim.prototype['transformCustomStyle'] = ApplyShim.prototype.transformCustomStyle;\nApplyShim.prototype['transformRules'] = ApplyShim.prototype.transformRules;\nApplyShim.prototype['transformRule'] = ApplyShim.prototype.transformRule;\nApplyShim.prototype['transformTemplate'] = ApplyShim.prototype.transformTemplate;\nApplyShim.prototype['_separator'] = MIXIN_VAR_SEP;\n/* eslint-enable no-self-assign */\nObject.defineProperty(ApplyShim.prototype, 'invalidCallback', {\n  /** @return {?function(string)} */\n  get() {\n    return invalidCallback;\n  },\n  /** @param {?function(string)} cb */\n  set(cb) {\n    invalidCallback = cb;\n  }\n});\n\nexport default ApplyShim;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,SAAQA,WAAW,EAAEC,0BAA0B,EAAEC,aAAa,EAAEC,SAAS,EAAEC,eAAe,QAAO,iBAAiB;AAClH,SAAQC,WAAW,EAAEC,UAAU,QAAO,mBAAmB;AACzD,SAAQC,WAAW,QAAO,mBAAmB;AAC7C,SAAQC,SAAS,QAAO,gBAAgB,CAAC,CAAC;;AAE1C,MAAMC,gBAAgB,GAAG,OAAO;AAChC,MAAMC,eAAe,GAAG,6BAA6B;AACrD,MAAMC,SAAS,GAAG,eAAe;;AAEjC;AACA;AACA,MAAMC,aAAa,GAAG,KAAK;;AAE3B;AACA;AACA;AACA,IAAIC,aAAa,CAAC,CAAC;;AAEnB;AACA;AACA;AACA,IAAIC,eAAe,CAAC,CAAC;;AAErB;AACA;AACA;AACA;AACA;AACA,IAAIC,aAAa,CAAC,CAAC;;AAEnB;AACA;AACA,MAAMC,QAAQ,CAAC;EACbC,WAAWA,CAAA,EAAG;IACZ;IACA,IAAI,CAACC,IAAI,GAAG,CAAC,CAAC;EAChB;EACA;AACF;AACA;AACA;EACEC,GAAGA,CAACC,IAAI,EAAEC,KAAK,EAAE;IACfD,IAAI,GAAGA,IAAI,CAACE,IAAI,CAAC,CAAC;IAClB,IAAI,CAACJ,IAAI,CAACE,IAAI,CAAC,GAAG;MAChBG,UAAU,EAAEF,KAAK;MACjBG,UAAU,EAAE,CAAC;IACf,CAAC;EACH;EACA;AACF;AACA;AACA;EACEC,GAAGA,CAACL,IAAI,EAAE;IACRA,IAAI,GAAGA,IAAI,CAACE,IAAI,CAAC,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"},"metadata":{},"sourceType":"module","externalDependencies":[]}