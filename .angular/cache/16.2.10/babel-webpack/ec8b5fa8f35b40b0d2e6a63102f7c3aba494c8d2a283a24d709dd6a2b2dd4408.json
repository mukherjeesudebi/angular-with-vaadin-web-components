{"ast":null,"code":"/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { afterNextRender } from '@polymer/polymer/lib/utils/render-status.js';\nimport { animationFrame } from '@polymer/polymer/lib/utils/async.js';\nimport { flush } from '@polymer/polymer/lib/utils/flush.js';\nimport { PolymerIronList } from './iron-list.js';\nimport { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\n/**\n * This Element is used internally by vaadin-grid.\n *\n * @private\n */\nclass GridScrollerElement extends PolymerIronList {\n  static get is() {\n    return 'vaadin-grid-scroller';\n  }\n  static get properties() {\n    return {\n      size: {\n        type: Number,\n        notify: true\n      },\n      _vidxOffset: {\n        value: 0\n      }\n    };\n  }\n  static get observers() {\n    return ['_effectiveSizeChanged(_effectiveSize)'];\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    this._scrollHandler();\n  }\n\n  /**\n  * @protected\n  */\n  _updateScrollerItem(item, index) {}\n  /**\n  * @protected\n  */\n  _afterScroll() {}\n  /**\n  * @protected\n  */\n  _getRowTarget() {}\n  /**\n  * @protected\n  */\n  _createScrollerRows() {}\n  /**\n  * @protected\n  */\n  _canPopulate() {}\n\n  /**\n  * @private\n  */\n  scrollToIndex(index) {\n    this._warnPrivateAPIAccess('scrollToIndex');\n    if (index > 0) {\n      this._pendingScrollToIndex = null;\n    }\n    if (!parseInt(this.$.items.style.borderTopWidth) && index > 0) {\n      // Schedule another scroll to be invoked once init is complete\n      this._pendingScrollToIndex = index;\n    }\n    this._scrollingToIndex = true;\n    index = Math.min(Math.max(index, 0), this._effectiveSize - 1);\n    this.$.table.scrollTop = index / this._effectiveSize * (this.$.table.scrollHeight - this.$.table.offsetHeight);\n    this._scrollHandler();\n    if (this._accessIronListAPI(() => this._maxScrollTop) && this._virtualCount < this._effectiveSize) {\n      this._adjustVirtualIndexOffset(1000000);\n    }\n    this._accessIronListAPI(() => super.scrollToIndex(index - this._vidxOffset));\n    this._scrollHandler();\n\n    // Ensure scroll position\n    const row = Array.from(this.$.items.children).filter(child => child.index === index)[0];\n    if (row) {\n      const headerOffset = row.getBoundingClientRect().top - this.$.header.getBoundingClientRect().bottom;\n      if (Math.abs(headerOffset) > 1) {\n        this.$.table.scrollTop += headerOffset;\n        this._scrollHandler();\n      }\n    }\n    this._scrollingToIndex = false;\n  }\n  _effectiveSizeChanged(size) {\n    let fvi; // first visible (adjusted) index\n    let fviOffset = 0;\n    this._iterateItems((pidx, vidx) => {\n      if (vidx === this._firstVisibleIndex) {\n        const row = this._physicalItems[pidx];\n        fvi = row.index;\n        fviOffset = row.getBoundingClientRect().top;\n      }\n    });\n    if (this.items && size < this.items.length) {\n      // Size was reduced, scroll to 0 first\n      this._scrollTop = 0;\n    }\n    if (!Array.isArray(this.items)) {\n      // Edge/IE seems to have the lowest maximum\n      const maxVirtualItems = this._edge || this._ie ? 30000 : 100000;\n      this.items = {\n        length: Math.min(size, maxVirtualItems)\n      };\n    }\n    this._accessIronListAPI(() => super._itemsChanged({\n      path: 'items'\n    }));\n    this._virtualCount = Math.min(this.items.length, size) || 0;\n    if (this._scrollTop === 0) {\n      this._accessIronListAPI(() => this._scrollToIndex(Math.min(size - 1, fvi)));\n      this._iterateItems((pidx, vidx) => {\n        const row = this._physicalItems[pidx];\n        if (row.index === fvi) {\n          this.$.table.scrollTop += Math.round(row.getBoundingClientRect().top - fviOffset);\n        }\n        // Restore keyboard focus to the right cell\n        if (row.index === this._focusedItemIndex && this._itemsFocusable && this.$.items.contains(this.shadowRoot.activeElement)) {\n          const cellIndex = Array.from(this._itemsFocusable.parentElement.children).indexOf(this._itemsFocusable);\n          row.children[cellIndex].focus();\n        }\n      });\n    }\n    this._assignModels();\n    requestAnimationFrame(() => this._update());\n  }\n  _positionItems() {\n    this._adjustScrollPosition();\n    let rePosition;\n    if (isNaN(this._physicalTop)) {\n      rePosition = true;\n      this._physicalTop = 0;\n    }\n    let y = this._physicalTop;\n    this._iterateItems((pidx, vidx) => {\n      this._physicalItems[pidx].style.transform = `translateY(${y}px)`;\n      y += this._physicalSizes[pidx];\n    });\n    if (rePosition) {\n      this._scrollToIndex(0);\n    }\n  }\n  _increasePoolIfNeeded(count) {\n    if (count === 0 && this._scrollingToIndex || !this._canPopulate() || !this._effectiveSize) {\n      return;\n    }\n    if (!this._initialPoolCreated) {\n      this._initialPoolCreated = true;\n      super._increasePoolIfNeeded(25);\n    } else if (this._optPhysicalSize !== Infinity) {\n      this._debounceIncreasePool = Debouncer.debounce(this._debounceIncreasePool, animationFrame, () => {\n        this._updateMetrics();\n        const remainingPhysicalSize = this._optPhysicalSize - this._physicalSize;\n        let estimatedMissingRowCount = Math.ceil(remainingPhysicalSize / this._physicalAverage);\n        if (this._physicalCount + estimatedMissingRowCount > this._effectiveSize) {\n          // Do not increase the physical item count above the this._effectiveSize\n          estimatedMissingRowCount = Math.max(0, this._effectiveSize - this._physicalCount);\n        }\n        if (this._physicalSize && estimatedMissingRowCount > 0) {\n          super._increasePoolIfNeeded(estimatedMissingRowCount);\n          // Ensure the rows are in order after increasing pool\n          this.__reorderChildNodes();\n        }\n      });\n    }\n  }\n  __reorderChildNodes() {\n    const childNodes = Array.from(this.$.items.childNodes);\n    const rowsInOrder = !!childNodes.reduce((inOrder, current, currentIndex, array) => {\n      if (currentIndex === 0 || array[currentIndex - 1].index === current.index - 1) {\n        return inOrder;\n      }\n    }, true);\n    if (!rowsInOrder) {\n      childNodes.sort((row1, row2) => {\n        return row1.index - row2.index;\n      }).forEach(row => this.$.items.appendChild(row));\n    }\n  }\n  _createPool(size) {\n    const fragment = document.createDocumentFragment();\n    const physicalItems = this._createScrollerRows(size);\n    physicalItems.forEach(inst => fragment.appendChild(inst));\n    this._getRowTarget().appendChild(fragment);\n\n    // Weird hack needed to get Safari to actually distribute slots\n    const content = this.querySelector('[slot]');\n    if (content) {\n      const slot = content.getAttribute('slot');\n      content.setAttribute('slot', 'foo-bar');\n      content.setAttribute('slot', slot);\n    }\n    this._updateHeaderFooterMetrics();\n    afterNextRender(this, () => this.notifyResize());\n    return physicalItems;\n  }\n\n  /**\n   * Assigns the data models to a given set of items.\n   * @param {!Array<number>=} itemSet\n   */\n  _assignModels(itemSet) {\n    this._iterateItems((pidx, vidx) => {\n      const el = this._physicalItems[pidx];\n      this._toggleAttribute('hidden', vidx >= this._effectiveSize, el);\n      this._updateScrollerItem(el, vidx + (this._vidxOffset || 0));\n    }, itemSet);\n  }\n  _scrollHandler() {\n    const delta = this.$.table.scrollTop - this._scrollPosition;\n    this._accessIronListAPI(super._scrollHandler);\n    const oldOffset = this._vidxOffset;\n    if (this._accessIronListAPI(() => this._maxScrollTop) && this._virtualCount < this._effectiveSize) {\n      this._adjustVirtualIndexOffset(delta);\n    }\n    if (this._vidxOffset !== oldOffset) {\n      this._update();\n    }\n    this._afterScroll();\n  }\n  _adjustVirtualIndexOffset(delta) {\n    if (Math.abs(delta) > 10000) {\n      if (this._noScale) {\n        this._noScale = false;\n        return;\n      }\n      const scale = this.$.table.scrollTop / (this.$.table.scrollHeight - this.$.table.offsetHeight);\n      const offset = scale * this._effectiveSize;\n      this._vidxOffset = Math.round(offset - scale * this._virtualCount);\n    } else {\n      // Make sure user can always swipe/wheel scroll to the start and end\n      const oldOffset = this._vidxOffset || 0;\n      const threshold = 1000;\n      const maxShift = 100;\n      // At start\n      if (this._scrollTop === 0) {\n        this._vidxOffset = 0;\n        if (oldOffset !== this._vidxOffset) {\n          super.scrollToIndex(0);\n        }\n      } else if (this.firstVisibleIndex < threshold && this._vidxOffset > 0) {\n        this._vidxOffset -= Math.min(this._vidxOffset, maxShift);\n        if (oldOffset !== this._vidxOffset) {\n          super.scrollToIndex(this.firstVisibleIndex + (oldOffset - this._vidxOffset));\n        }\n        this._noScale = true;\n      }\n      // At end\n      const maxOffset = this._effectiveSize - this._virtualCount;\n      if (this._scrollTop >= this._maxScrollTop && this._maxScrollTop > 0) {\n        this._vidxOffset = maxOffset;\n        if (oldOffset !== this._vidxOffset) {\n          super.scrollToIndex(this._virtualCount);\n        }\n      } else if (this.firstVisibleIndex > this._virtualCount - threshold && this._vidxOffset < maxOffset) {\n        this._vidxOffset += Math.min(maxOffset - this._vidxOffset, maxShift);\n        if (oldOffset !== this._vidxOffset) {\n          super.scrollToIndex(this.firstVisibleIndex - (this._vidxOffset - oldOffset));\n        }\n        this._noScale = true;\n      }\n    }\n  }\n  _accessIronListAPI(cb) {\n    this._warnPrivateAPIAccessAsyncEnabled = false;\n    const returnValue = cb.apply(this);\n    this._debouncerWarnPrivateAPIAccess = Debouncer.debounce(this._debouncerWarnPrivateAPIAccess, animationFrame, () => this._warnPrivateAPIAccessAsyncEnabled = true);\n    return returnValue;\n  }\n\n  /* Allow iron-list to access its APIs from debounced callbacks without warns */\n  _debounceRender(cb, asyncModule) {\n    super._debounceRender(() => this._accessIronListAPI(cb), asyncModule);\n  }\n\n  /* Warn when iron-list APIs are being accessed directly */\n  _warnPrivateAPIAccess(apiName) {\n    if (this._warnPrivateAPIAccessAsyncEnabled) {\n      console.warn(`Accessing private API (${apiName})!`);\n    }\n  }\n  _render() {\n    this._accessIronListAPI(super._render);\n  }\n  _createFocusBackfillItem() {/* Ignore */}\n  _multiSelectionChanged() {/* Ignore */}\n  clearSelection() {/* Ignore */}\n  _itemsChanged() {/* Ignore */}\n  _manageFocus() {/* Ignore */}\n  _removeFocusedItem() {/* Ignore */}\n  get _firstVisibleIndex() {\n    return this._accessIronListAPI(() => super.firstVisibleIndex);\n  }\n  get _lastVisibleIndex() {\n    return this._accessIronListAPI(() => super.lastVisibleIndex);\n  }\n  _scrollToIndex(index) {\n    this._accessIronListAPI(() => this.scrollToIndex(index));\n  }\n  get firstVisibleIndex() {\n    this._warnPrivateAPIAccess('firstVisibleIndex');\n    return super.firstVisibleIndex;\n  }\n  set firstVisibleIndex(value) {\n    this._warnPrivateAPIAccess('firstVisibleIndex');\n    super.firstVisibleIndex = value;\n  }\n  get lastVisibleIndex() {\n    this._warnPrivateAPIAccess('lastVisibleIndex');\n    return super.lastVisibleIndex;\n  }\n  set lastVisibleIndex(value) {\n    this._warnPrivateAPIAccess('lastVisibleIndex');\n    super.lastVisibleIndex = value;\n  }\n  updateViewportBoundaries() {\n    this._warnPrivateAPIAccess('updateViewportBoundaries');\n    super.updateViewportBoundaries.apply(this, arguments);\n  }\n  _resizeHandler() {\n    super._resizeHandler();\n    flush();\n  }\n}\ncustomElements.define(GridScrollerElement.is, GridScrollerElement);\nexport { GridScrollerElement as ScrollerElement };","map":{"version":3,"names":["afterNextRender","animationFrame","flush","PolymerIronList","Debouncer","GridScrollerElement","is","properties","size","type","Number","notify","_vidxOffset","value","observers","connectedCallback","_scrollHandler","_updateScrollerItem","item","index","_afterScroll","_getRowTarget","_createScrollerRows","_canPopulate","scrollToIndex","_warnPrivateAPIAccess","_pendingScrollToIndex","parseInt","$","items","style","borderTopWidth","_scrollingToIndex","Math","min","max","_effectiveSize","table","scrollTop","scrollHeight","offsetHeight","_accessIronListAPI","_maxScrollTop","_virtualCount","_adjustVirtualIndexOffset","row","Array","from","children","filter","child","headerOffset","getBoundingClientRect","top","header","bottom","abs","_effectiveSizeChanged","fvi","fviOffset","_iterateItems","pidx","vidx","_firstVisibleIndex","_physicalItems","length","_scrollTop","isArray","maxVirtualItems","_edge","_ie","_itemsChanged","path","_scrollToIndex","round","_focusedItemIndex","_itemsFocusable","contains","shadowRoot","activeElement","cellIndex","parentElement","indexOf","focus","_assignModels","requestAnimationFrame","_update","_positionItems","_adjustScrollPosition","rePosition","isNaN","_physicalTop","y","transform","_physicalSizes","_increasePoolIfNeeded","count","_initialPoolCreated","_optPhysicalSize","Infinity","_debounceIncreasePool","debounce","_updateMetrics","remainingPhysicalSize","_physicalSize","estimatedMissingRowCount","ceil","_physicalAverage","_physicalCount","__reorderChildNodes","childNodes","rowsInOrder","reduce","inOrder","current","currentIndex","array","sort","row1","row2","forEach","appendChild","_createPool","fragment","document","createDocumentFragment","physicalItems","inst","content","querySelector","slot","getAttribute","setAttribute","_updateHeaderFooterMetrics","notifyResize","itemSet","el","_toggleAttribute","delta","_scrollPosition","oldOffset","_noScale","scale","offset","threshold","maxShift","firstVisibleIndex","maxOffset","cb","_warnPrivateAPIAccessAsyncEnabled","returnValue","apply","_debouncerWarnPrivateAPIAccess","_debounceRender","asyncModule","apiName","console","warn","_render","_createFocusBackfillItem","_multiSelectionChanged","clearSelection","_manageFocus","_removeFocusedItem","_lastVisibleIndex","lastVisibleIndex","updateViewportBoundaries","arguments","_resizeHandler","customElements","define","ScrollerElement"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@vaadin/vaadin-grid/src/vaadin-grid-scroller.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { afterNextRender } from '@polymer/polymer/lib/utils/render-status.js';\n\nimport { animationFrame } from '@polymer/polymer/lib/utils/async.js';\nimport { flush } from '@polymer/polymer/lib/utils/flush.js';\nimport { PolymerIronList } from './iron-list.js';\nimport { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\n/**\n * This Element is used internally by vaadin-grid.\n *\n * @private\n */\nclass GridScrollerElement extends PolymerIronList {\n\n  static get is() {\n    return 'vaadin-grid-scroller';\n  }\n\n  static get properties() {\n    return {\n      size: {\n        type: Number,\n        notify: true\n      },\n      _vidxOffset: {\n        value: 0\n      }\n    };\n  }\n\n  static get observers() {\n    return [\n      '_effectiveSizeChanged(_effectiveSize)'\n    ];\n  }\n\n  connectedCallback() {\n    super.connectedCallback();\n    this._scrollHandler();\n  }\n\n  /**\n  * @protected\n  */\n  _updateScrollerItem(item, index) {}\n  /**\n  * @protected\n  */\n  _afterScroll() {}\n  /**\n  * @protected\n  */\n  _getRowTarget() {}\n  /**\n  * @protected\n  */\n  _createScrollerRows() {}\n  /**\n  * @protected\n  */\n  _canPopulate() {}\n\n  /**\n  * @private\n  */\n  scrollToIndex(index) {\n    this._warnPrivateAPIAccess('scrollToIndex');\n\n    if (index > 0) {\n      this._pendingScrollToIndex = null;\n    }\n    if (!parseInt(this.$.items.style.borderTopWidth) && index > 0) {\n      // Schedule another scroll to be invoked once init is complete\n      this._pendingScrollToIndex = index;\n    }\n\n    this._scrollingToIndex = true;\n    index = Math.min(Math.max(index, 0), this._effectiveSize - 1);\n    this.$.table.scrollTop = index / this._effectiveSize * (this.$.table.scrollHeight - this.$.table.offsetHeight);\n    this._scrollHandler();\n\n    if (this._accessIronListAPI(() => this._maxScrollTop) && this._virtualCount < this._effectiveSize) {\n      this._adjustVirtualIndexOffset(1000000);\n    }\n\n    this._accessIronListAPI(() => super.scrollToIndex(index - this._vidxOffset));\n    this._scrollHandler();\n\n    // Ensure scroll position\n    const row = Array.from(this.$.items.children).filter(child => child.index === index)[0];\n    if (row) {\n      const headerOffset = row.getBoundingClientRect().top - this.$.header.getBoundingClientRect().bottom;\n      if (Math.abs(headerOffset) > 1) {\n        this.$.table.scrollTop += headerOffset;\n        this._scrollHandler();\n      }\n    }\n\n    this._scrollingToIndex = false;\n  }\n\n  _effectiveSizeChanged(size) {\n    let fvi; // first visible (adjusted) index\n    let fviOffset = 0;\n    this._iterateItems((pidx, vidx) => {\n      if (vidx === this._firstVisibleIndex) {\n        const row = this._physicalItems[pidx];\n        fvi = row.index;\n        fviOffset = row.getBoundingClientRect().top;\n      }\n    });\n\n    if (this.items && size < this.items.length) {\n      // Size was reduced, scroll to 0 first\n      this._scrollTop = 0;\n    }\n    if (!Array.isArray(this.items)) {\n      // Edge/IE seems to have the lowest maximum\n      const maxVirtualItems = this._edge || this._ie ? 30000 : 100000;\n      this.items = {length: Math.min(size, maxVirtualItems)};\n    }\n\n    this._accessIronListAPI(() => super._itemsChanged({path: 'items'}));\n\n    this._virtualCount = Math.min(this.items.length, size) || 0;\n\n    if (this._scrollTop === 0) {\n      this._accessIronListAPI(() => this._scrollToIndex(Math.min(size - 1, fvi)));\n      this._iterateItems((pidx, vidx) => {\n        const row = this._physicalItems[pidx];\n        if (row.index === fvi) {\n          this.$.table.scrollTop += Math.round(row.getBoundingClientRect().top - fviOffset);\n        }\n        // Restore keyboard focus to the right cell\n        if (row.index === this._focusedItemIndex && this._itemsFocusable && this.$.items.contains(this.shadowRoot.activeElement)) {\n          const cellIndex = Array.from(this._itemsFocusable.parentElement.children).indexOf(this._itemsFocusable);\n          row.children[cellIndex].focus();\n        }\n      });\n    }\n    this._assignModels();\n    requestAnimationFrame(() => this._update());\n  }\n\n  _positionItems() {\n    this._adjustScrollPosition();\n\n    let rePosition;\n    if (isNaN(this._physicalTop)) {\n      rePosition = true;\n      this._physicalTop = 0;\n    }\n\n    let y = this._physicalTop;\n    this._iterateItems((pidx, vidx) => {\n      this._physicalItems[pidx].style.transform = `translateY(${y}px)`;\n      y += this._physicalSizes[pidx];\n    });\n\n    if (rePosition) {\n      this._scrollToIndex(0);\n    }\n  }\n\n  _increasePoolIfNeeded(count) {\n    if ((count === 0 && this._scrollingToIndex) || !this._canPopulate() || !this._effectiveSize) {\n      return;\n    }\n\n    if (!this._initialPoolCreated) {\n      this._initialPoolCreated = true;\n      super._increasePoolIfNeeded(25);\n    } else if (this._optPhysicalSize !== Infinity) {\n      this._debounceIncreasePool = Debouncer.debounce(\n        this._debounceIncreasePool,\n        animationFrame,\n        () => {\n          this._updateMetrics();\n          const remainingPhysicalSize = this._optPhysicalSize - this._physicalSize;\n          let estimatedMissingRowCount = Math.ceil(remainingPhysicalSize / this._physicalAverage);\n\n          if (this._physicalCount + estimatedMissingRowCount > this._effectiveSize) {\n            // Do not increase the physical item count above the this._effectiveSize\n            estimatedMissingRowCount = Math.max(0, this._effectiveSize - this._physicalCount);\n          }\n\n          if (this._physicalSize && estimatedMissingRowCount > 0) {\n            super._increasePoolIfNeeded(estimatedMissingRowCount);\n            // Ensure the rows are in order after increasing pool\n            this.__reorderChildNodes();\n          }\n        });\n    }\n  }\n\n  __reorderChildNodes() {\n    const childNodes = Array.from(this.$.items.childNodes);\n    const rowsInOrder = !!childNodes.reduce((inOrder, current, currentIndex, array) => {\n      if (currentIndex === 0 || array[currentIndex - 1].index === current.index - 1) {\n        return inOrder;\n      }\n    }, true);\n\n    if (!rowsInOrder) {\n      childNodes.sort((row1, row2) => {\n        return row1.index - row2.index;\n      }).forEach(row => this.$.items.appendChild(row));\n    }\n  }\n\n  _createPool(size) {\n    const fragment = document.createDocumentFragment();\n    const physicalItems = this._createScrollerRows(size);\n\n    physicalItems.forEach(inst => fragment.appendChild(inst));\n    this._getRowTarget().appendChild(fragment);\n\n    // Weird hack needed to get Safari to actually distribute slots\n    const content = this.querySelector('[slot]');\n    if (content) {\n      const slot = content.getAttribute('slot');\n      content.setAttribute('slot', 'foo-bar');\n      content.setAttribute('slot', slot);\n    }\n\n    this._updateHeaderFooterMetrics();\n\n    afterNextRender(this, () => this.notifyResize());\n    return physicalItems;\n  }\n\n  /**\n   * Assigns the data models to a given set of items.\n   * @param {!Array<number>=} itemSet\n   */\n  _assignModels(itemSet) {\n    this._iterateItems((pidx, vidx) => {\n      const el = this._physicalItems[pidx];\n      this._toggleAttribute('hidden', vidx >= this._effectiveSize, el);\n      this._updateScrollerItem(el, vidx + (this._vidxOffset || 0));\n    }, itemSet);\n  }\n\n  _scrollHandler() {\n    const delta = this.$.table.scrollTop - this._scrollPosition;\n    this._accessIronListAPI(super._scrollHandler);\n    const oldOffset = this._vidxOffset;\n    if (this._accessIronListAPI(() => this._maxScrollTop) && this._virtualCount < this._effectiveSize) {\n      this._adjustVirtualIndexOffset(delta);\n    }\n    if (this._vidxOffset !== oldOffset) {\n      this._update();\n    }\n    this._afterScroll();\n  }\n\n  _adjustVirtualIndexOffset(delta) {\n    if (Math.abs(delta) > 10000) {\n      if (this._noScale) {\n        this._noScale = false;\n        return;\n      }\n      const scale = this.$.table.scrollTop / (this.$.table.scrollHeight - this.$.table.offsetHeight);\n      const offset = scale * this._effectiveSize;\n      this._vidxOffset = Math.round(offset - scale * this._virtualCount);\n    } else {\n      // Make sure user can always swipe/wheel scroll to the start and end\n      const oldOffset = this._vidxOffset || 0;\n      const threshold = 1000;\n      const maxShift = 100;\n      // At start\n      if (this._scrollTop === 0) {\n        this._vidxOffset = 0;\n        if (oldOffset !== this._vidxOffset) {\n          super.scrollToIndex(0);\n        }\n      } else if (this.firstVisibleIndex < threshold && this._vidxOffset > 0) {\n        this._vidxOffset -= Math.min(this._vidxOffset, maxShift);\n        if (oldOffset !== this._vidxOffset) {\n          super.scrollToIndex(this.firstVisibleIndex + (oldOffset - this._vidxOffset));\n        }\n        this._noScale = true;\n      }\n      // At end\n      const maxOffset = this._effectiveSize - this._virtualCount;\n      if (this._scrollTop >= this._maxScrollTop && this._maxScrollTop > 0) {\n        this._vidxOffset = maxOffset;\n        if (oldOffset !== this._vidxOffset) {\n          super.scrollToIndex(this._virtualCount);\n        }\n      } else if (this.firstVisibleIndex > this._virtualCount - threshold && this._vidxOffset < maxOffset) {\n        this._vidxOffset += Math.min(maxOffset - this._vidxOffset, maxShift);\n        if (oldOffset !== this._vidxOffset) {\n          super.scrollToIndex(this.firstVisibleIndex - (this._vidxOffset - oldOffset));\n        }\n        this._noScale = true;\n      }\n    }\n  }\n\n  _accessIronListAPI(cb) {\n    this._warnPrivateAPIAccessAsyncEnabled = false;\n    const returnValue = cb.apply(this);\n    this._debouncerWarnPrivateAPIAccess = Debouncer.debounce(\n      this._debouncerWarnPrivateAPIAccess,\n      animationFrame,\n      () => this._warnPrivateAPIAccessAsyncEnabled = true\n    );\n    return returnValue;\n  }\n\n  /* Allow iron-list to access its APIs from debounced callbacks without warns */\n  _debounceRender(cb, asyncModule) {\n    super._debounceRender(() => this._accessIronListAPI(cb), asyncModule);\n  }\n\n  /* Warn when iron-list APIs are being accessed directly */\n  _warnPrivateAPIAccess(apiName) {\n    if (this._warnPrivateAPIAccessAsyncEnabled) {\n      console.warn(`Accessing private API (${apiName})!`);\n    }\n  }\n\n  _render() {\n    this._accessIronListAPI(super._render);\n  }\n\n  _createFocusBackfillItem() { /* Ignore */ }\n  _multiSelectionChanged() { /* Ignore */ }\n  clearSelection() { /* Ignore */ }\n  _itemsChanged() { /* Ignore */ }\n  _manageFocus() { /* Ignore */ }\n  _removeFocusedItem() { /* Ignore */ }\n\n  get _firstVisibleIndex() {\n    return this._accessIronListAPI(() => super.firstVisibleIndex);\n  }\n  get _lastVisibleIndex() {\n    return this._accessIronListAPI(() => super.lastVisibleIndex);\n  }\n  _scrollToIndex(index) {\n    this._accessIronListAPI(() => this.scrollToIndex(index));\n  }\n  get firstVisibleIndex() {\n    this._warnPrivateAPIAccess('firstVisibleIndex'); return super.firstVisibleIndex;\n  }\n  set firstVisibleIndex(value) {\n    this._warnPrivateAPIAccess('firstVisibleIndex'); super.firstVisibleIndex = value;\n  }\n  get lastVisibleIndex() {\n    this._warnPrivateAPIAccess('lastVisibleIndex'); return super.lastVisibleIndex;\n  }\n  set lastVisibleIndex(value) {\n    this._warnPrivateAPIAccess('lastVisibleIndex'); super.lastVisibleIndex = value;\n  }\n  updateViewportBoundaries() {\n    this._warnPrivateAPIAccess('updateViewportBoundaries'); super.updateViewportBoundaries.apply(this, arguments);\n  }\n  _resizeHandler() {\n    super._resizeHandler();\n    flush();\n  }\n}\n\ncustomElements.define(GridScrollerElement.is, GridScrollerElement);\n\nexport { GridScrollerElement as ScrollerElement };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}