{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n/**\n * A helper for observing slot changes.\n */\nexport class SlotObserver {\n  constructor(slot, callback) {\n    /** @type HTMLSlotElement */\n    this.slot = slot;\n\n    /** @type Function */\n    this.callback = callback;\n\n    /** @type {Node[]} */\n    this._storedNodes = [];\n    this._connected = false;\n    this._scheduled = false;\n    this._boundSchedule = () => {\n      this._schedule();\n    };\n    this.connect();\n    this._schedule();\n  }\n\n  /**\n   * Activates an observer. This method is automatically called when\n   * a `SlotObserver` is created. It should only be called to  re-activate\n   * an observer that has been deactivated via the `disconnect` method.\n   */\n  connect() {\n    this.slot.addEventListener('slotchange', this._boundSchedule);\n    this._connected = true;\n  }\n\n  /**\n   * Deactivates the observer. After calling this method the observer callback\n   * will not be called when changes to slotted nodes occur. The `connect` method\n   * may be subsequently called to reactivate the observer.\n   */\n  disconnect() {\n    this.slot.removeEventListener('slotchange', this._boundSchedule);\n    this._connected = false;\n  }\n\n  /** @private */\n  _schedule() {\n    if (!this._scheduled) {\n      this._scheduled = true;\n      queueMicrotask(() => {\n        this.flush();\n      });\n    }\n  }\n\n  /**\n   * Run the observer callback synchronously.\n   */\n  flush() {\n    if (!this._connected) {\n      return;\n    }\n    this._scheduled = false;\n    this._processNodes();\n  }\n\n  /** @private */\n  _processNodes() {\n    const currentNodes = this.slot.assignedNodes({\n      flatten: true\n    });\n    let addedNodes = [];\n    const removedNodes = [];\n    const movedNodes = [];\n    if (currentNodes.length) {\n      addedNodes = currentNodes.filter(node => !this._storedNodes.includes(node));\n    }\n    if (this._storedNodes.length) {\n      this._storedNodes.forEach((node, index) => {\n        const idx = currentNodes.indexOf(node);\n        if (idx === -1) {\n          removedNodes.push(node);\n        } else if (idx !== index) {\n          movedNodes.push(node);\n        }\n      });\n    }\n    if (addedNodes.length || removedNodes.length || movedNodes.length) {\n      this.callback({\n        addedNodes,\n        movedNodes,\n        removedNodes\n      });\n    }\n    this._storedNodes = currentNodes;\n  }\n}","map":{"version":3,"names":["SlotObserver","constructor","slot","callback","_storedNodes","_connected","_scheduled","_boundSchedule","_schedule","connect","addEventListener","disconnect","removeEventListener","queueMicrotask","flush","_processNodes","currentNodes","assignedNodes","flatten","addedNodes","removedNodes","movedNodes","length","filter","node","includes","forEach","index","idx","indexOf","push"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@vaadin/component-base/src/slot-observer.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n/**\n * A helper for observing slot changes.\n */\nexport class SlotObserver {\n  constructor(slot, callback) {\n    /** @type HTMLSlotElement */\n    this.slot = slot;\n\n    /** @type Function */\n    this.callback = callback;\n\n    /** @type {Node[]} */\n    this._storedNodes = [];\n\n    this._connected = false;\n    this._scheduled = false;\n\n    this._boundSchedule = () => {\n      this._schedule();\n    };\n\n    this.connect();\n    this._schedule();\n  }\n\n  /**\n   * Activates an observer. This method is automatically called when\n   * a `SlotObserver` is created. It should only be called to  re-activate\n   * an observer that has been deactivated via the `disconnect` method.\n   */\n  connect() {\n    this.slot.addEventListener('slotchange', this._boundSchedule);\n    this._connected = true;\n  }\n\n  /**\n   * Deactivates the observer. After calling this method the observer callback\n   * will not be called when changes to slotted nodes occur. The `connect` method\n   * may be subsequently called to reactivate the observer.\n   */\n  disconnect() {\n    this.slot.removeEventListener('slotchange', this._boundSchedule);\n    this._connected = false;\n  }\n\n  /** @private */\n  _schedule() {\n    if (!this._scheduled) {\n      this._scheduled = true;\n\n      queueMicrotask(() => {\n        this.flush();\n      });\n    }\n  }\n\n  /**\n   * Run the observer callback synchronously.\n   */\n  flush() {\n    if (!this._connected) {\n      return;\n    }\n\n    this._scheduled = false;\n\n    this._processNodes();\n  }\n\n  /** @private */\n  _processNodes() {\n    const currentNodes = this.slot.assignedNodes({ flatten: true });\n\n    let addedNodes = [];\n    const removedNodes = [];\n    const movedNodes = [];\n\n    if (currentNodes.length) {\n      addedNodes = currentNodes.filter((node) => !this._storedNodes.includes(node));\n    }\n\n    if (this._storedNodes.length) {\n      this._storedNodes.forEach((node, index) => {\n        const idx = currentNodes.indexOf(node);\n        if (idx === -1) {\n          removedNodes.push(node);\n        } else if (idx !== index) {\n          movedNodes.push(node);\n        }\n      });\n    }\n\n    if (addedNodes.length || removedNodes.length || movedNodes.length) {\n      this.callback({ addedNodes, movedNodes, removedNodes });\n    }\n\n    this._storedNodes = currentNodes;\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO,MAAMA,YAAY,CAAC;EACxBC,WAAWA,CAACC,IAAI,EAAEC,QAAQ,EAAE;IAC1B;IACA,IAAI,CAACD,IAAI,GAAGA,IAAI;;IAEhB;IACA,IAAI,CAACC,QAAQ,GAAGA,QAAQ;;IAExB;IACA,IAAI,CAACC,YAAY,GAAG,EAAE;IAEtB,IAAI,CAACC,UAAU,GAAG,KAAK;IACvB,IAAI,CAACC,UAAU,GAAG,KAAK;IAEvB,IAAI,CAACC,cAAc,GAAG,MAAM;MAC1B,IAAI,CAACC,SAAS,CAAC,CAAC;IAClB,CAAC;IAED,IAAI,CAACC,OAAO,CAAC,CAAC;IACd,IAAI,CAACD,SAAS,CAAC,CAAC;EAClB;;EAEA;AACF;AACA;AACA;AACA;EACEC,OAAOA,CAAA,EAAG;IACR,IAAI,CAACP,IAAI,CAACQ,gBAAgB,CAAC,YAAY,EAAE,IAAI,CAACH,cAAc,CAAC;IAC7D,IAAI,CAACF,UAAU,GAAG,IAAI;EACxB;;EAEA;AACF;AACA;AACA;AACA;EACEM,UAAUA,CAAA,EAAG;IACX,IAAI,CAACT,IAAI,CAACU,mBAAmB,CAAC,YAAY,EAAE,IAAI,CAACL,cAAc,CAAC;IAChE,IAAI,CAACF,UAAU,GAAG,KAAK;EACzB;;EAEA;EACAG,SAASA,CAAA,EAAG;IACV,IAAI,CAAC,IAAI,CAACF,UAAU,EAAE;MACpB,IAAI,CAACA,UAAU,GAAG,IAAI;MAEtBO,cAAc,CAAC,MAAM;QACnB,IAAI,CAACC,KAAK,CAAC,CAAC;MACd,CAAC,CAAC;IACJ;EACF;;EAEA;AACF;AACA;EACEA,KAAKA,CAAA,EAAG;IACN,IAAI,CAAC,IAAI,CAACT,UAAU,EAAE;MACpB;IACF;IAEA,IAAI,CAACC,UAAU,GAAG,KAAK;IAEvB,IAAI,CAACS,aAAa,CAAC,CAAC;EACtB;;EAEA;EACAA,aAAaA,CAAA,EAAG;IACd,MAAMC,YAAY,GAAG,IAAI,CAACd,IAAI,CAACe,aAAa,CAAC;MAAEC,OAAO,EAAE;IAAK,CAAC,CAAC;IAE/D,IAAIC,UAAU,GAAG,EAAE;IACnB,MAAMC,YAAY,GAAG,EAAE;IACvB,MAAMC,UAAU,GAAG,EAAE;IAErB,IAAIL,YAAY,CAACM,MAAM,EAAE;MACvBH,UAAU,GAAGH,YAAY,CAACO,MAAM,CAAEC,IAAI,IAAK,CAAC,IAAI,CAACpB,YAAY,CAACqB,QAAQ,CAACD,IAAI,CAAC,CAAC;IAC/E;IAEA,IAAI,IAAI,CAACpB,YAAY,CAACkB,MAAM,EAAE;MAC5B,IAAI,CAAClB,YAAY,CAACsB,OAAO,CAAC,CAACF,IAAI,EAAEG,KAAK,KAAK;QACzC,MAAMC,GAAG,GAAGZ,YAAY,CAACa,OAAO,CAACL,IAAI,CAAC;QACtC,IAAII,GAAG,KAAK,CAAC,CAAC,EAAE;UACdR,YAAY,CAACU,IAAI,CAACN,IAAI,CAAC;QACzB,CAAC,MAAM,IAAII,GAAG,KAAKD,KAAK,EAAE;UACxBN,UAAU,CAACS,IAAI,CAACN,IAAI,CAAC;QACvB;MACF,CAAC,CAAC;IACJ;IAEA,IAAIL,UAAU,CAACG,MAAM,IAAIF,YAAY,CAACE,MAAM,IAAID,UAAU,CAACC,MAAM,EAAE;MACjE,IAAI,CAACnB,QAAQ,CAAC;QAAEgB,UAAU;QAAEE,UAAU;QAAED;MAAa,CAAC,CAAC;IACzD;IAEA,IAAI,CAAChB,YAAY,GAAGY,YAAY;EAClC;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}