{"ast":null,"code":"/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/*\nExtremely simple css parser. Intended to be not more than what we need\nand definitely not necessarily correct =).\n*/\n\n'use strict';\n\n/** @unrestricted */\nclass StyleNode {\n  constructor() {\n    /** @type {number} */\n    this['start'] = 0;\n    /** @type {number} */\n    this['end'] = 0;\n    /** @type {StyleNode} */\n    this['previous'] = null;\n    /** @type {StyleNode} */\n    this['parent'] = null;\n    /** @type {Array<StyleNode>} */\n    this['rules'] = null;\n    /** @type {string} */\n    this['parsedCssText'] = '';\n    /** @type {string} */\n    this['cssText'] = '';\n    /** @type {boolean} */\n    this['atRule'] = false;\n    /** @type {number} */\n    this['type'] = 0;\n    /** @type {string} */\n    this['keyframesName'] = '';\n    /** @type {string} */\n    this['selector'] = '';\n    /** @type {string} */\n    this['parsedSelector'] = '';\n  }\n}\nexport { StyleNode };\n\n// given a string of css, return a simple rule tree\n/**\n * @param {string} text\n * @return {StyleNode}\n */\nexport function parse(text) {\n  text = clean(text);\n  return parseCss(lex(text), text);\n}\n\n// remove stuff we don't care about that may hinder parsing\n/**\n * @param {string} cssText\n * @return {string}\n */\nfunction clean(cssText) {\n  return cssText.replace(RX.comments, '').replace(RX.port, '');\n}\n\n// super simple {...} lexer that returns a node tree\n/**\n * @param {string} text\n * @return {StyleNode}\n */\nfunction lex(text) {\n  let root = new StyleNode();\n  root['start'] = 0;\n  root['end'] = text.length;\n  let n = root;\n  for (let i = 0, l = text.length; i < l; i++) {\n    if (text[i] === OPEN_BRACE) {\n      if (!n['rules']) {\n        n['rules'] = [];\n      }\n      let p = n;\n      let previous = p['rules'][p['rules'].length - 1] || null;\n      n = new StyleNode();\n      n['start'] = i + 1;\n      n['parent'] = p;\n      n['previous'] = previous;\n      p['rules'].push(n);\n    } else if (text[i] === CLOSE_BRACE) {\n      n['end'] = i + 1;\n      n = n['parent'] || root;\n    }\n  }\n  return root;\n}\n\n// add selectors/cssText to node tree\n/**\n * @param {StyleNode} node\n * @param {string} text\n * @return {StyleNode}\n */\nfunction parseCss(node, text) {\n  let t = text.substring(node['start'], node['end'] - 1);\n  node['parsedCssText'] = node['cssText'] = t.trim();\n  if (node['parent']) {\n    let ss = node['previous'] ? node['previous']['end'] : node['parent']['start'];\n    t = text.substring(ss, node['start'] - 1);\n    t = _expandUnicodeEscapes(t);\n    t = t.replace(RX.multipleSpaces, ' ');\n    // TODO(sorvell): ad hoc; make selector include only after last ;\n    // helps with mixin syntax\n    t = t.substring(t.lastIndexOf(';') + 1);\n    let s = node['parsedSelector'] = node['selector'] = t.trim();\n    node['atRule'] = s.indexOf(AT_START) === 0;\n    // note, support a subset of rule types...\n    if (node['atRule']) {\n      if (s.indexOf(MEDIA_START) === 0) {\n        node['type'] = types.MEDIA_RULE;\n      } else if (s.match(RX.keyframesRule)) {\n        node['type'] = types.KEYFRAMES_RULE;\n        node['keyframesName'] = node['selector'].split(RX.multipleSpaces).pop();\n      }\n    } else {\n      if (s.indexOf(VAR_START) === 0) {\n        node['type'] = types.MIXIN_RULE;\n      } else {\n        node['type'] = types.STYLE_RULE;\n      }\n    }\n  }\n  let r$ = node['rules'];\n  if (r$) {\n    for (let i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n      parseCss(r, text);\n    }\n  }\n  return node;\n}\n\n/**\n * conversion of sort unicode escapes with spaces like `\\33 ` (and longer) into\n * expanded form that doesn't require trailing space `\\000033`\n * @param {string} s\n * @return {string}\n */\nfunction _expandUnicodeEscapes(s) {\n  return s.replace(/\\\\([0-9a-f]{1,6})\\s/gi, function () {\n    let code = arguments[1],\n      repeat = 6 - code.length;\n    while (repeat--) {\n      code = '0' + code;\n    }\n    return '\\\\' + code;\n  });\n}\n\n/**\n * stringify parsed css.\n * @param {StyleNode} node\n * @param {boolean=} preserveProperties\n * @param {string=} text\n * @return {string}\n */\nexport function stringify(node, preserveProperties, text = '') {\n  // calc rule cssText\n  let cssText = '';\n  if (node['cssText'] || node['rules']) {\n    let r$ = node['rules'];\n    if (r$ && !_hasMixinRules(r$)) {\n      for (let i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n        cssText = stringify(r, preserveProperties, cssText);\n      }\n    } else {\n      cssText = preserveProperties ? node['cssText'] : removeCustomProps(node['cssText']);\n      cssText = cssText.trim();\n      if (cssText) {\n        cssText = '  ' + cssText + '\\n';\n      }\n    }\n  }\n  // emit rule if there is cssText\n  if (cssText) {\n    if (node['selector']) {\n      text += node['selector'] + ' ' + OPEN_BRACE + '\\n';\n    }\n    text += cssText;\n    if (node['selector']) {\n      text += CLOSE_BRACE + '\\n\\n';\n    }\n  }\n  return text;\n}\n\n/**\n * @param {Array<StyleNode>} rules\n * @return {boolean}\n */\nfunction _hasMixinRules(rules) {\n  let r = rules[0];\n  return Boolean(r) && Boolean(r['selector']) && r['selector'].indexOf(VAR_START) === 0;\n}\n\n/**\n * @param {string} cssText\n * @return {string}\n */\nfunction removeCustomProps(cssText) {\n  cssText = removeCustomPropAssignment(cssText);\n  return removeCustomPropApply(cssText);\n}\n\n/**\n * @param {string} cssText\n * @return {string}\n */\nexport function removeCustomPropAssignment(cssText) {\n  return cssText.replace(RX.customProp, '').replace(RX.mixinProp, '');\n}\n\n/**\n * @param {string} cssText\n * @return {string}\n */\nfunction removeCustomPropApply(cssText) {\n  return cssText.replace(RX.mixinApply, '').replace(RX.varApply, '');\n}\n\n/** @enum {number} */\nexport const types = {\n  STYLE_RULE: 1,\n  KEYFRAMES_RULE: 7,\n  MEDIA_RULE: 4,\n  MIXIN_RULE: 1000\n};\nconst OPEN_BRACE = '{';\nconst CLOSE_BRACE = '}';\n\n// helper regexp's\nconst RX = {\n  comments: /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//gim,\n  port: /@import[^;]*;/gim,\n  customProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\\n]|$)/gim,\n  mixinProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\\n]|$)?/gim,\n  mixinApply: /@apply\\s*\\(?[^);]*\\)?\\s*(?:[;\\n]|$)?/gim,\n  varApply: /[^;:]*?:[^;]*?var\\([^;]*\\)(?:[;\\n]|$)?/gim,\n  keyframesRule: /^@[^\\s]*keyframes/,\n  multipleSpaces: /\\s+/g\n};\nconst VAR_START = '--';\nconst MEDIA_START = '@media';\nconst AT_START = '@';","map":{"version":3,"names":["StyleNode","constructor","parse","text","clean","parseCss","lex","cssText","replace","RX","comments","port","root","length","n","i","l","OPEN_BRACE","p","previous","push","CLOSE_BRACE","node","t","substring","trim","ss","_expandUnicodeEscapes","multipleSpaces","lastIndexOf","s","indexOf","AT_START","MEDIA_START","types","MEDIA_RULE","match","keyframesRule","KEYFRAMES_RULE","split","pop","VAR_START","MIXIN_RULE","STYLE_RULE","r$","r","code","arguments","repeat","stringify","preserveProperties","_hasMixinRules","removeCustomProps","rules","Boolean","removeCustomPropAssignment","removeCustomPropApply","customProp","mixinProp","mixinApply","varApply"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@webcomponents/shadycss/src/css-parse.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/*\nExtremely simple css parser. Intended to be not more than what we need\nand definitely not necessarily correct =).\n*/\n\n'use strict';\n\n/** @unrestricted */\nclass StyleNode {\n  constructor() {\n    /** @type {number} */\n    this['start'] = 0;\n    /** @type {number} */\n    this['end'] = 0;\n    /** @type {StyleNode} */\n    this['previous'] = null;\n    /** @type {StyleNode} */\n    this['parent'] = null;\n    /** @type {Array<StyleNode>} */\n    this['rules'] = null;\n    /** @type {string} */\n    this['parsedCssText'] = '';\n    /** @type {string} */\n    this['cssText'] = '';\n    /** @type {boolean} */\n    this['atRule'] = false;\n    /** @type {number} */\n    this['type'] = 0;\n    /** @type {string} */\n    this['keyframesName'] = '';\n    /** @type {string} */\n    this['selector'] = '';\n    /** @type {string} */\n    this['parsedSelector'] = '';\n  }\n}\n\nexport {StyleNode}\n\n// given a string of css, return a simple rule tree\n/**\n * @param {string} text\n * @return {StyleNode}\n */\nexport function parse(text) {\n  text = clean(text);\n  return parseCss(lex(text), text);\n}\n\n// remove stuff we don't care about that may hinder parsing\n/**\n * @param {string} cssText\n * @return {string}\n */\nfunction clean(cssText) {\n  return cssText.replace(RX.comments, '').replace(RX.port, '');\n}\n\n// super simple {...} lexer that returns a node tree\n/**\n * @param {string} text\n * @return {StyleNode}\n */\nfunction lex(text) {\n  let root = new StyleNode();\n  root['start'] = 0;\n  root['end'] = text.length\n  let n = root;\n  for (let i = 0, l = text.length; i < l; i++) {\n    if (text[i] === OPEN_BRACE) {\n      if (!n['rules']) {\n        n['rules'] = [];\n      }\n      let p = n;\n      let previous = p['rules'][p['rules'].length - 1] || null;\n      n = new StyleNode();\n      n['start'] = i + 1;\n      n['parent'] = p;\n      n['previous'] = previous;\n      p['rules'].push(n);\n    } else if (text[i] === CLOSE_BRACE) {\n      n['end'] = i + 1;\n      n = n['parent'] || root;\n    }\n  }\n  return root;\n}\n\n// add selectors/cssText to node tree\n/**\n * @param {StyleNode} node\n * @param {string} text\n * @return {StyleNode}\n */\nfunction parseCss(node, text) {\n  let t = text.substring(node['start'], node['end'] - 1);\n  node['parsedCssText'] = node['cssText'] = t.trim();\n  if (node['parent']) {\n    let ss = node['previous'] ? node['previous']['end'] : node['parent']['start'];\n    t = text.substring(ss, node['start'] - 1);\n    t = _expandUnicodeEscapes(t);\n    t = t.replace(RX.multipleSpaces, ' ');\n    // TODO(sorvell): ad hoc; make selector include only after last ;\n    // helps with mixin syntax\n    t = t.substring(t.lastIndexOf(';') + 1);\n    let s = node['parsedSelector'] = node['selector'] = t.trim();\n    node['atRule'] = (s.indexOf(AT_START) === 0);\n    // note, support a subset of rule types...\n    if (node['atRule']) {\n      if (s.indexOf(MEDIA_START) === 0) {\n        node['type'] = types.MEDIA_RULE;\n      } else if (s.match(RX.keyframesRule)) {\n        node['type'] = types.KEYFRAMES_RULE;\n        node['keyframesName'] =\n          node['selector'].split(RX.multipleSpaces).pop();\n      }\n    } else {\n      if (s.indexOf(VAR_START) === 0) {\n        node['type'] = types.MIXIN_RULE;\n      } else {\n        node['type'] = types.STYLE_RULE;\n      }\n    }\n  }\n  let r$ = node['rules'];\n  if (r$) {\n    for (let i = 0, l = r$.length, r;\n      (i < l) && (r = r$[i]); i++) {\n      parseCss(r, text);\n    }\n  }\n  return node;\n}\n\n/**\n * conversion of sort unicode escapes with spaces like `\\33 ` (and longer) into\n * expanded form that doesn't require trailing space `\\000033`\n * @param {string} s\n * @return {string}\n */\nfunction _expandUnicodeEscapes(s) {\n  return s.replace(/\\\\([0-9a-f]{1,6})\\s/gi, function() {\n    let code = arguments[1],\n      repeat = 6 - code.length;\n    while (repeat--) {\n      code = '0' + code;\n    }\n    return '\\\\' + code;\n  });\n}\n\n/**\n * stringify parsed css.\n * @param {StyleNode} node\n * @param {boolean=} preserveProperties\n * @param {string=} text\n * @return {string}\n */\nexport function stringify(node, preserveProperties, text = '') {\n  // calc rule cssText\n  let cssText = '';\n  if (node['cssText'] || node['rules']) {\n    let r$ = node['rules'];\n    if (r$ && !_hasMixinRules(r$)) {\n      for (let i = 0, l = r$.length, r;\n        (i < l) && (r = r$[i]); i++) {\n        cssText = stringify(r, preserveProperties, cssText);\n      }\n    } else {\n      cssText = preserveProperties ? node['cssText'] :\n        removeCustomProps(node['cssText']);\n      cssText = cssText.trim();\n      if (cssText) {\n        cssText = '  ' + cssText + '\\n';\n      }\n    }\n  }\n  // emit rule if there is cssText\n  if (cssText) {\n    if (node['selector']) {\n      text += node['selector'] + ' ' + OPEN_BRACE + '\\n';\n    }\n    text += cssText;\n    if (node['selector']) {\n      text += CLOSE_BRACE + '\\n\\n';\n    }\n  }\n  return text;\n}\n\n/**\n * @param {Array<StyleNode>} rules\n * @return {boolean}\n */\nfunction _hasMixinRules(rules) {\n  let r = rules[0];\n  return Boolean(r) && Boolean(r['selector']) && r['selector'].indexOf(VAR_START) === 0;\n}\n\n/**\n * @param {string} cssText\n * @return {string}\n */\nfunction removeCustomProps(cssText) {\n  cssText = removeCustomPropAssignment(cssText);\n  return removeCustomPropApply(cssText);\n}\n\n/**\n * @param {string} cssText\n * @return {string}\n */\nexport function removeCustomPropAssignment(cssText) {\n  return cssText\n    .replace(RX.customProp, '')\n    .replace(RX.mixinProp, '');\n}\n\n/**\n * @param {string} cssText\n * @return {string}\n */\nfunction removeCustomPropApply(cssText) {\n  return cssText\n    .replace(RX.mixinApply, '')\n    .replace(RX.varApply, '');\n}\n\n/** @enum {number} */\nexport const types = {\n  STYLE_RULE: 1,\n  KEYFRAMES_RULE: 7,\n  MEDIA_RULE: 4,\n  MIXIN_RULE: 1000\n}\n\nconst OPEN_BRACE = '{';\nconst CLOSE_BRACE = '}';\n\n// helper regexp's\nconst RX = {\n  comments: /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//gim,\n  port: /@import[^;]*;/gim,\n  customProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\\n]|$)/gim,\n  mixinProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\\n]|$)?/gim,\n  mixinApply: /@apply\\s*\\(?[^);]*\\)?\\s*(?:[;\\n]|$)?/gim,\n  varApply: /[^;:]*?:[^;]*?var\\([^;]*\\)(?:[;\\n]|$)?/gim,\n  keyframesRule: /^@[^\\s]*keyframes/,\n  multipleSpaces: /\\s+/g\n}\n\nconst VAR_START = '--';\nconst MEDIA_START = '@media';\nconst AT_START = '@';\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA,MAAMA,SAAS,CAAC;EACdC,WAAWA,CAAA,EAAG;IACZ;IACA,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC;IACjB;IACA,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;IACf;IACA,IAAI,CAAC,UAAU,CAAC,GAAG,IAAI;IACvB;IACA,IAAI,CAAC,QAAQ,CAAC,GAAG,IAAI;IACrB;IACA,IAAI,CAAC,OAAO,CAAC,GAAG,IAAI;IACpB;IACA,IAAI,CAAC,eAAe,CAAC,GAAG,EAAE;IAC1B;IACA,IAAI,CAAC,SAAS,CAAC,GAAG,EAAE;IACpB;IACA,IAAI,CAAC,QAAQ,CAAC,GAAG,KAAK;IACtB;IACA,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC;IAChB;IACA,IAAI,CAAC,eAAe,CAAC,GAAG,EAAE;IAC1B;IACA,IAAI,CAAC,UAAU,CAAC,GAAG,EAAE;IACrB;IACA,IAAI,CAAC,gBAAgB,CAAC,GAAG,EAAE;EAC7B;AACF;AAEA,SAAQD,SAAS;;AAEjB;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,KAAKA,CAACC,IAAI,EAAE;EAC1BA,IAAI,GAAGC,KAAK,CAACD,IAAI,CAAC;EAClB,OAAOE,QAAQ,CAACC,GAAG,CAACH,IAAI,CAAC,EAAEA,IAAI,CAAC;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASC,KAAKA,CAACG,OAAO,EAAE;EACtB,OAAOA,OAAO,CAACC,OAAO,CAACC,EAAE,CAACC,QAAQ,EAAE,EAAE,CAAC,CAACF,OAAO,CAACC,EAAE,CAACE,IAAI,EAAE,EAAE,CAAC;AAC9D;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASL,GAAGA,CAACH,IAAI,EAAE;EACjB,IAAIS,IAAI,GAAG,IAAIZ,SAAS,CAAC,CAAC;EAC1BY,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC;EACjBA,IAAI,CAAC,KAAK,CAAC,GAAGT,IAAI,CAACU,MAAM;EACzB,IAAIC,CAAC,GAAGF,IAAI;EACZ,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGb,IAAI,CAACU,MAAM,EAAEE,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;IAC3C,IAAIZ,IAAI,CAACY,CAAC,CAAC,KAAKE,UAAU,EAAE;MAC1B,IAAI,CAACH,CAAC,CAAC,OAAO,CAAC,EAAE;QACfA,CAAC,CAAC,OAAO,CAAC,GAAG,EAAE;MACjB;MACA,IAAII,CAAC,GAAGJ,CAAC;MACT,IAAIK,QAAQ,GAAGD,CAAC,CAAC,OAAO,CAAC,CAACA,CAAC,CAAC,OAAO,CAAC,CAACL,MAAM,GAAG,CAAC,CAAC,IAAI,IAAI;MACxDC,CAAC,GAAG,IAAId,SAAS,CAAC,CAAC;MACnBc,CAAC,CAAC,OAAO,CAAC,GAAGC,CAAC,GAAG,CAAC;MAClBD,CAAC,CAAC,QAAQ,CAAC,GAAGI,CAAC;MACfJ,CAAC,CAAC,UAAU,CAAC,GAAGK,QAAQ;MACxBD,CAAC,CAAC,OAAO,CAAC,CAACE,IAAI,CAACN,CAAC,CAAC;IACpB,CAAC,MAAM,IAAIX,IAAI,CAACY,CAAC,CAAC,KAAKM,WAAW,EAAE;MAClCP,CAAC,CAAC,KAAK,CAAC,GAAGC,CAAC,GAAG,CAAC;MAChBD,CAAC,GAAGA,CAAC,CAAC,QAAQ,CAAC,IAAIF,IAAI;IACzB;EACF;EACA,OAAOA,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASP,QAAQA,CAACiB,IAAI,EAAEnB,IAAI,EAAE;EAC5B,IAAIoB,CAAC,GAAGpB,IAAI,CAACqB,SAAS,CAACF,IAAI,CAAC,OAAO,CAAC,EAAEA,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;EACtDA,IAAI,CAAC,eAAe,CAAC,GAAGA,IAAI,CAAC,SAAS,CAAC,GAAGC,CAAC,CAACE,IAAI,CAAC,CAAC;EAClD,IAAIH,IAAI,CAAC,QAAQ,CAAC,EAAE;IAClB,IAAII,EAAE,GAAGJ,IAAI,CAAC,UAAU,CAAC,GAAGA,IAAI,CAAC,UAAU,CAAC,CAAC,KAAK,CAAC,GAAGA,IAAI,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC;IAC7EC,CAAC,GAAGpB,IAAI,CAACqB,SAAS,CAACE,EAAE,EAAEJ,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;IACzCC,CAAC,GAAGI,qBAAqB,CAACJ,CAAC,CAAC;IAC5BA,CAAC,GAAGA,CAAC,CAACf,OAAO,CAACC,EAAE,CAACmB,cAAc,EAAE,GAAG,CAAC;IACrC;IACA;IACAL,CAAC,GAAGA,CAAC,CAACC,SAAS,CAACD,CAAC,CAACM,WAAW,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IACvC,IAAIC,CAAC,GAAGR,IAAI,CAAC,gBAAgB,CAAC,GAAGA,IAAI,CAAC,UAAU,CAAC,GAAGC,CAAC,CAACE,IAAI,CAAC,CAAC;IAC5DH,IAAI,CAAC,QAAQ,CAAC,GAAIQ,CAAC,CAACC,OAAO,CAACC,QAAQ,CAAC,KAAK,CAAE;IAC5C;IACA,IAAIV,IAAI,CAAC,QAAQ,CAAC,EAAE;MAClB,IAAIQ,CAAC,CAACC,OAAO,CAACE,WAAW,CAAC,KAAK,CAAC,EAAE;QAChCX,IAAI,CAAC,MAAM,CAAC,GAAGY,KAAK,CAACC,UAAU;MACjC,CAAC,MAAM,IAAIL,CAAC,CAACM,KAAK,CAAC3B,EAAE,CAAC4B,aAAa,CAAC,EAAE;QACpCf,IAAI,CAAC,MAAM,CAAC,GAAGY,KAAK,CAACI,cAAc;QACnChB,IAAI,CAAC,eAAe,CAAC,GACnBA,IAAI,CAAC,UAAU,CAAC,CAACiB,KAAK,CAAC9B,EAAE,CAACmB,cAAc,CAAC,CAACY,GAAG,CAAC,CAAC;MACnD;IACF,CAAC,MAAM;MACL,IAAIV,CAAC,CAACC,OAAO,CAACU,SAAS,CAAC,KAAK,CAAC,EAAE;QAC9BnB,IAAI,CAAC,MAAM,CAAC,GAAGY,KAAK,CAACQ,UAAU;MACjC,CAAC,MAAM;QACLpB,IAAI,CAAC,MAAM,CAAC,GAAGY,KAAK,CAACS,UAAU;MACjC;IACF;EACF;EACA,IAAIC,EAAE,GAAGtB,IAAI,CAAC,OAAO,CAAC;EACtB,IAAIsB,EAAE,EAAE;IACN,KAAK,IAAI7B,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG4B,EAAE,CAAC/B,MAAM,EAAEgC,CAAC,EAC7B9B,CAAC,GAAGC,CAAC,KAAM6B,CAAC,GAAGD,EAAE,CAAC7B,CAAC,CAAC,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC7BV,QAAQ,CAACwC,CAAC,EAAE1C,IAAI,CAAC;IACnB;EACF;EACA,OAAOmB,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASK,qBAAqBA,CAACG,CAAC,EAAE;EAChC,OAAOA,CAAC,CAACtB,OAAO,CAAC,uBAAuB,EAAE,YAAW;IACnD,IAAIsC,IAAI,GAAGC,SAAS,CAAC,CAAC,CAAC;MACrBC,MAAM,GAAG,CAAC,GAAGF,IAAI,CAACjC,MAAM;IAC1B,OAAOmC,MAAM,EAAE,EAAE;MACfF,IAAI,GAAG,GAAG,GAAGA,IAAI;IACnB;IACA,OAAO,IAAI,GAAGA,IAAI;EACpB,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASG,SAASA,CAAC3B,IAAI,EAAE4B,kBAAkB,EAAE/C,IAAI,GAAG,EAAE,EAAE;EAC7D;EACA,IAAII,OAAO,GAAG,EAAE;EAChB,IAAIe,IAAI,CAAC,SAAS,CAAC,IAAIA,IAAI,CAAC,OAAO,CAAC,EAAE;IACpC,IAAIsB,EAAE,GAAGtB,IAAI,CAAC,OAAO,CAAC;IACtB,IAAIsB,EAAE,IAAI,CAACO,cAAc,CAACP,EAAE,CAAC,EAAE;MAC7B,KAAK,IAAI7B,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG4B,EAAE,CAAC/B,MAAM,EAAEgC,CAAC,EAC7B9B,CAAC,GAAGC,CAAC,KAAM6B,CAAC,GAAGD,EAAE,CAAC7B,CAAC,CAAC,CAAC,EAAEA,CAAC,EAAE,EAAE;QAC7BR,OAAO,GAAG0C,SAAS,CAACJ,CAAC,EAAEK,kBAAkB,EAAE3C,OAAO,CAAC;MACrD;IACF,CAAC,MAAM;MACLA,OAAO,GAAG2C,kBAAkB,GAAG5B,IAAI,CAAC,SAAS,CAAC,GAC5C8B,iBAAiB,CAAC9B,IAAI,CAAC,SAAS,CAAC,CAAC;MACpCf,OAAO,GAAGA,OAAO,CAACkB,IAAI,CAAC,CAAC;MACxB,IAAIlB,OAAO,EAAE;QACXA,OAAO,GAAG,IAAI,GAAGA,OAAO,GAAG,IAAI;MACjC;IACF;EACF;EACA;EACA,IAAIA,OAAO,EAAE;IACX,IAAIe,IAAI,CAAC,UAAU,CAAC,EAAE;MACpBnB,IAAI,IAAImB,IAAI,CAAC,UAAU,CAAC,GAAG,GAAG,GAAGL,UAAU,GAAG,IAAI;IACpD;IACAd,IAAI,IAAII,OAAO;IACf,IAAIe,IAAI,CAAC,UAAU,CAAC,EAAE;MACpBnB,IAAI,IAAIkB,WAAW,GAAG,MAAM;IAC9B;EACF;EACA,OAAOlB,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA,SAASgD,cAAcA,CAACE,KAAK,EAAE;EAC7B,IAAIR,CAAC,GAAGQ,KAAK,CAAC,CAAC,CAAC;EAChB,OAAOC,OAAO,CAACT,CAAC,CAAC,IAAIS,OAAO,CAACT,CAAC,CAAC,UAAU,CAAC,CAAC,IAAIA,CAAC,CAAC,UAAU,CAAC,CAACd,OAAO,CAACU,SAAS,CAAC,KAAK,CAAC;AACvF;;AAEA;AACA;AACA;AACA;AACA,SAASW,iBAAiBA,CAAC7C,OAAO,EAAE;EAClCA,OAAO,GAAGgD,0BAA0B,CAAChD,OAAO,CAAC;EAC7C,OAAOiD,qBAAqB,CAACjD,OAAO,CAAC;AACvC;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASgD,0BAA0BA,CAAChD,OAAO,EAAE;EAClD,OAAOA,OAAO,CACXC,OAAO,CAACC,EAAE,CAACgD,UAAU,EAAE,EAAE,CAAC,CAC1BjD,OAAO,CAACC,EAAE,CAACiD,SAAS,EAAE,EAAE,CAAC;AAC9B;;AAEA;AACA;AACA;AACA;AACA,SAASF,qBAAqBA,CAACjD,OAAO,EAAE;EACtC,OAAOA,OAAO,CACXC,OAAO,CAACC,EAAE,CAACkD,UAAU,EAAE,EAAE,CAAC,CAC1BnD,OAAO,CAACC,EAAE,CAACmD,QAAQ,EAAE,EAAE,CAAC;AAC7B;;AAEA;AACA,OAAO,MAAM1B,KAAK,GAAG;EACnBS,UAAU,EAAE,CAAC;EACbL,cAAc,EAAE,CAAC;EACjBH,UAAU,EAAE,CAAC;EACbO,UAAU,EAAE;AACd,CAAC;AAED,MAAMzB,UAAU,GAAG,GAAG;AACtB,MAAMI,WAAW,GAAG,GAAG;;AAEvB;AACA,MAAMZ,EAAE,GAAG;EACTC,QAAQ,EAAE,mCAAmC;EAC7CC,IAAI,EAAE,kBAAkB;EACxB8C,UAAU,EAAE,mDAAmD;EAC/DC,SAAS,EAAE,4DAA4D;EACvEC,UAAU,EAAE,yCAAyC;EACrDC,QAAQ,EAAE,2CAA2C;EACrDvB,aAAa,EAAE,mBAAmB;EAClCT,cAAc,EAAE;AAClB,CAAC;AAED,MAAMa,SAAS,GAAG,IAAI;AACtB,MAAMR,WAAW,GAAG,QAAQ;AAC5B,MAAMD,QAAQ,GAAG,GAAG"},"metadata":{},"sourceType":"module","externalDependencies":[]}