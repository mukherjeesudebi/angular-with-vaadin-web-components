{"ast":null,"code":"/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/* eslint-disable @typescript-eslint/no-use-before-define */\n\n/**\n * @fileoverview\n *\n * Module for adding listeners to a node for the following normalized\n * cross-platform \"gesture\" events:\n * - `down` - mouse or touch went down\n * - `up` - mouse or touch went up\n * - `tap` - mouse click or finger tap\n * - `track` - mouse drag or touch move\n *\n * @summary Module for adding cross-platform gesture event listeners.\n */\n\nimport { microTask } from './async.js';\nconst passiveTouchGestures = false;\nconst wrap = node => node;\n\n// Detect native touch action support\nconst HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';\nconst GESTURE_KEY = '__polymerGestures';\nconst HANDLED_OBJ = '__polymerGesturesHandled';\nconst TOUCH_ACTION = '__polymerGesturesTouchAction';\n// Radius for tap and track\nconst TAP_DISTANCE = 25;\nconst TRACK_DISTANCE = 5;\n// Number of last N track positions to keep\nconst TRACK_LENGTH = 2;\nconst MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'click'];\n// An array of bitmask values for mapping MouseEvent.which to MouseEvent.buttons\nconst MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];\nconst MOUSE_HAS_BUTTONS = function () {\n  try {\n    return new MouseEvent('test', {\n      buttons: 1\n    }).buttons === 1;\n  } catch (e) {\n    return false;\n  }\n}();\n\n/**\n * @param {string} name Possible mouse event name\n * @return {boolean} true if mouse event, false if not\n */\nfunction isMouseEvent(name) {\n  return MOUSE_EVENTS.indexOf(name) > -1;\n}\n\n/* eslint no-empty: [\"error\", { \"allowEmptyCatch\": true }] */\n// check for passive event listeners\nlet supportsPassive = false;\n(function () {\n  try {\n    const opts = Object.defineProperty({}, 'passive', {\n      // eslint-disable-next-line getter-return\n      get() {\n        supportsPassive = true;\n      }\n    });\n    window.addEventListener('test', null, opts);\n    window.removeEventListener('test', null, opts);\n  } catch (e) {}\n})();\n\n/**\n * Generate settings for event listeners, dependant on `passiveTouchGestures`\n *\n * @param {string} eventName Event name to determine if `{passive}` option is\n *   needed\n * @return {{passive: boolean} | undefined} Options to use for addEventListener\n *   and removeEventListener\n */\nfunction PASSIVE_TOUCH(eventName) {\n  if (isMouseEvent(eventName) || eventName === 'touchend') {\n    return;\n  }\n  if (HAS_NATIVE_TA && supportsPassive && passiveTouchGestures) {\n    return {\n      passive: true\n    };\n  }\n}\n\n// Check for touch-only devices\nconst IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/u);\n\n// Defined at https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#enabling-and-disabling-form-controls:-the-disabled-attribute\n/** @type {!Object<boolean>} */\nconst canBeDisabled = {\n  button: true,\n  command: true,\n  fieldset: true,\n  input: true,\n  keygen: true,\n  optgroup: true,\n  option: true,\n  select: true,\n  textarea: true\n};\n\n/**\n * @param {MouseEvent} ev event to test for left mouse button down\n * @return {boolean} has left mouse button down\n */\nfunction hasLeftMouseButton(ev) {\n  const type = ev.type;\n  // Exit early if the event is not a mouse event\n  if (!isMouseEvent(type)) {\n    return false;\n  }\n  // Ev.button is not reliable for mousemove (0 is overloaded as both left button and no buttons)\n  // instead we use ev.buttons (bitmask of buttons) or fall back to ev.which (deprecated, 0 for no buttons, 1 for left button)\n  if (type === 'mousemove') {\n    // Allow undefined for testing events\n    let buttons = ev.buttons === undefined ? 1 : ev.buttons;\n    if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {\n      buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;\n    }\n    // Buttons is a bitmask, check that the left button bit is set (1)\n    return Boolean(buttons & 1);\n  }\n  // Allow undefined for testing events\n  const button = ev.button === undefined ? 0 : ev.button;\n  // Ev.button is 0 in mousedown/mouseup/click for left button activation\n  return button === 0;\n}\nfunction isSyntheticClick(ev) {\n  if (ev.type === 'click') {\n    // Ev.detail is 0 for HTMLElement.click in most browsers\n    if (ev.detail === 0) {\n      return true;\n    }\n    // In the worst case, check that the x/y position of the click is within\n    // the bounding box of the target of the event\n    // Thanks IE 10 >:(\n    const t = _findOriginalTarget(ev);\n    // Make sure the target of the event is an element so we can use getBoundingClientRect,\n    // if not, just assume it is a synthetic click\n    if (!t.nodeType || /** @type {Element} */t.nodeType !== Node.ELEMENT_NODE) {\n      return true;\n    }\n    const bcr = /** @type {Element} */t.getBoundingClientRect();\n    // Use page x/y to account for scrolling\n    const x = ev.pageX,\n      y = ev.pageY;\n    // Ev is a synthetic click if the position is outside the bounding box of the target\n    return !(x >= bcr.left && x <= bcr.right && y >= bcr.top && y <= bcr.bottom);\n  }\n  return false;\n}\nconst POINTERSTATE = {\n  mouse: {\n    target: null,\n    mouseIgnoreJob: null\n  },\n  touch: {\n    x: 0,\n    y: 0,\n    id: -1,\n    scrollDecided: false\n  }\n};\nfunction firstTouchAction(ev) {\n  let ta = 'auto';\n  const path = getComposedPath(ev);\n  for (let i = 0, n; i < path.length; i++) {\n    n = path[i];\n    if (n[TOUCH_ACTION]) {\n      ta = n[TOUCH_ACTION];\n      break;\n    }\n  }\n  return ta;\n}\nfunction trackDocument(stateObj, movefn, upfn) {\n  stateObj.movefn = movefn;\n  stateObj.upfn = upfn;\n  document.addEventListener('mousemove', movefn);\n  document.addEventListener('mouseup', upfn);\n}\nfunction untrackDocument(stateObj) {\n  document.removeEventListener('mousemove', stateObj.movefn);\n  document.removeEventListener('mouseup', stateObj.upfn);\n  stateObj.movefn = null;\n  stateObj.upfn = null;\n}\n\n/**\n * Returns the composedPath for the given event.\n * @param {Event} event to process\n * @return {!Array<!EventTarget>} Path of the event\n */\nconst getComposedPath = window.ShadyDOM && window.ShadyDOM.noPatch ? window.ShadyDOM.composedPath : event => event.composedPath && event.composedPath() || [];\n\n/** @type {!Object<string, !GestureRecognizer>} */\nexport const gestures = {};\n\n/** @type {!Array<!GestureRecognizer>} */\nexport const recognizers = [];\n\n/**\n * Finds the element rendered on the screen at the provided coordinates.\n *\n * Similar to `document.elementFromPoint`, but pierces through\n * shadow roots.\n *\n * @param {number} x Horizontal pixel coordinate\n * @param {number} y Vertical pixel coordinate\n * @return {Element} Returns the deepest shadowRoot inclusive element\n * found at the screen position given.\n */\nexport function deepTargetFind(x, y) {\n  let node = document.elementFromPoint(x, y);\n  let next = node;\n  // This code path is only taken when native ShadowDOM is used\n  // if there is a shadowroot, it may have a node at x/y\n  // if there is not a shadowroot, exit the loop\n  while (next && next.shadowRoot && !window.ShadyDOM) {\n    // If there is a node at x/y in the shadowroot, look deeper\n    const oldNext = next;\n    next = next.shadowRoot.elementFromPoint(x, y);\n    // On Safari, elementFromPoint may return the shadowRoot host\n    if (oldNext === next) {\n      break;\n    }\n    if (next) {\n      node = next;\n    }\n  }\n  return node;\n}\n\n/**\n * A cheaper check than ev.composedPath()[0];\n *\n * @private\n * @param {Event|Touch} ev Event.\n * @return {EventTarget} Returns the event target.\n */\nfunction _findOriginalTarget(ev) {\n  const path = getComposedPath( /** @type {?Event} */ev);\n  // It shouldn't be, but sometimes path is empty (window on Safari).\n  return path.length > 0 ? path[0] : ev.target;\n}\n\n/**\n * @private\n * @param {Event} ev Event.\n * @return {void}\n */\nfunction _handleNative(ev) {\n  const type = ev.type;\n  const node = ev.currentTarget;\n  const gobj = node[GESTURE_KEY];\n  if (!gobj) {\n    return;\n  }\n  const gs = gobj[type];\n  if (!gs) {\n    return;\n  }\n  if (!ev[HANDLED_OBJ]) {\n    ev[HANDLED_OBJ] = {};\n    if (type.startsWith('touch')) {\n      const t = ev.changedTouches[0];\n      if (type === 'touchstart') {\n        // Only handle the first finger\n        if (ev.touches.length === 1) {\n          POINTERSTATE.touch.id = t.identifier;\n        }\n      }\n      if (POINTERSTATE.touch.id !== t.identifier) {\n        return;\n      }\n      if (!HAS_NATIVE_TA) {\n        if (type === 'touchstart' || type === 'touchmove') {\n          _handleTouchAction(ev);\n        }\n      }\n    }\n  }\n  const handled = ev[HANDLED_OBJ];\n  // Used to ignore synthetic mouse events\n  if (handled.skip) {\n    return;\n  }\n  // Reset recognizer state\n  for (let i = 0, r; i < recognizers.length; i++) {\n    r = recognizers[i];\n    if (gs[r.name] && !handled[r.name]) {\n      if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {\n        r.reset();\n      }\n    }\n  }\n  // Enforce gesture recognizer order\n  for (let i = 0, r; i < recognizers.length; i++) {\n    r = recognizers[i];\n    if (gs[r.name] && !handled[r.name]) {\n      handled[r.name] = true;\n      r[type](ev);\n    }\n  }\n}\n\n/**\n * @private\n * @param {TouchEvent} ev Event.\n * @return {void}\n */\nfunction _handleTouchAction(ev) {\n  const t = ev.changedTouches[0];\n  const type = ev.type;\n  if (type === 'touchstart') {\n    POINTERSTATE.touch.x = t.clientX;\n    POINTERSTATE.touch.y = t.clientY;\n    POINTERSTATE.touch.scrollDecided = false;\n  } else if (type === 'touchmove') {\n    if (POINTERSTATE.touch.scrollDecided) {\n      return;\n    }\n    POINTERSTATE.touch.scrollDecided = true;\n    const ta = firstTouchAction(ev);\n    let shouldPrevent = false;\n    const dx = Math.abs(POINTERSTATE.touch.x - t.clientX);\n    const dy = Math.abs(POINTERSTATE.touch.y - t.clientY);\n    if (!ev.cancelable) {\n      // Scrolling is happening\n    } else if (ta === 'none') {\n      shouldPrevent = true;\n    } else if (ta === 'pan-x') {\n      shouldPrevent = dy > dx;\n    } else if (ta === 'pan-y') {\n      shouldPrevent = dx > dy;\n    }\n    if (shouldPrevent) {\n      ev.preventDefault();\n    } else {\n      prevent('track');\n    }\n  }\n}\n\n/**\n * Adds an event listener to a node for the given gesture type.\n *\n * @param {!EventTarget} node Node to add listener on\n * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`\n * @param {!function(!Event):void} handler Event listener function to call\n * @return {boolean} Returns true if a gesture event listener was added.\n */\nexport function addListener(node, evType, handler) {\n  if (gestures[evType]) {\n    _add(node, evType, handler);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Removes an event listener from a node for the given gesture type.\n *\n * @param {!EventTarget} node Node to remove listener from\n * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`\n * @param {!function(!Event):void} handler Event listener function previously passed to\n *  `addListener`.\n * @return {boolean} Returns true if a gesture event listener was removed.\n */\nexport function removeListener(node, evType, handler) {\n  if (gestures[evType]) {\n    _remove(node, evType, handler);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Automate the event listeners for the native events\n *\n * @private\n * @param {!EventTarget} node Node on which to add the event.\n * @param {string} evType Event type to add.\n * @param {function(!Event)} handler Event handler function.\n * @return {void}\n */\nfunction _add(node, evType, handler) {\n  const recognizer = gestures[evType];\n  const deps = recognizer.deps;\n  const name = recognizer.name;\n  let gobj = node[GESTURE_KEY];\n  if (!gobj) {\n    node[GESTURE_KEY] = gobj = {};\n  }\n  for (let i = 0, dep, gd; i < deps.length; i++) {\n    dep = deps[i];\n    // Don't add mouse handlers on iOS because they cause gray selection overlays\n    if (IS_TOUCH_ONLY && isMouseEvent(dep) && dep !== 'click') {\n      continue;\n    }\n    gd = gobj[dep];\n    if (!gd) {\n      gobj[dep] = gd = {\n        _count: 0\n      };\n    }\n    if (gd._count === 0) {\n      node.addEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));\n    }\n    gd[name] = (gd[name] || 0) + 1;\n    gd._count = (gd._count || 0) + 1;\n  }\n  node.addEventListener(evType, handler);\n  if (recognizer.touchAction) {\n    setTouchAction(node, recognizer.touchAction);\n  }\n}\n\n/**\n * Automate event listener removal for native events\n *\n * @private\n * @param {!EventTarget} node Node on which to remove the event.\n * @param {string} evType Event type to remove.\n * @param {function(!Event): void} handler Event handler function.\n * @return {void}\n */\nfunction _remove(node, evType, handler) {\n  const recognizer = gestures[evType];\n  const deps = recognizer.deps;\n  const name = recognizer.name;\n  const gobj = node[GESTURE_KEY];\n  if (gobj) {\n    for (let i = 0, dep, gd; i < deps.length; i++) {\n      dep = deps[i];\n      gd = gobj[dep];\n      if (gd && gd[name]) {\n        gd[name] = (gd[name] || 1) - 1;\n        gd._count = (gd._count || 1) - 1;\n        if (gd._count === 0) {\n          node.removeEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));\n        }\n      }\n    }\n  }\n  node.removeEventListener(evType, handler);\n}\n\n/**\n * Registers a new gesture event recognizer for adding new custom\n * gesture event types.\n *\n * @param {!GestureRecognizer} recog Gesture recognizer descriptor\n * @return {void}\n */\nexport function register(recog) {\n  recognizers.push(recog);\n  recog.emits.forEach(emit => {\n    gestures[emit] = recog;\n  });\n}\n\n/**\n * @private\n * @param {string} evName Event name.\n * @return {Object} Returns the gesture for the given event name.\n */\nfunction _findRecognizerByEvent(evName) {\n  for (let i = 0, r; i < recognizers.length; i++) {\n    r = recognizers[i];\n    for (let j = 0, n; j < r.emits.length; j++) {\n      n = r.emits[j];\n      if (n === evName) {\n        return r;\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Sets scrolling direction on node.\n *\n * This value is checked on first move, thus it should be called prior to\n * adding event listeners.\n *\n * @param {!EventTarget} node Node to set touch action setting on\n * @param {string} value Touch action value\n * @return {void}\n */\nexport function setTouchAction(node, value) {\n  if (HAS_NATIVE_TA && node instanceof HTMLElement) {\n    // NOTE: add touchAction async so that events can be added in\n    // custom element constructors. Otherwise we run afoul of custom\n    // elements restriction against settings attributes (style) in the\n    // constructor.\n    microTask.run(() => {\n      node.style.touchAction = value;\n    });\n  }\n  node[TOUCH_ACTION] = value;\n}\n\n/**\n * Dispatches an event on the `target` element of `type` with the given\n * `detail`.\n * @private\n * @param {!EventTarget} target The element on which to fire an event.\n * @param {string} type The type of event to fire.\n * @param {!Object=} detail The detail object to populate on the event.\n * @return {void}\n */\nfunction _fire(target, type, detail) {\n  const ev = new Event(type, {\n    bubbles: true,\n    cancelable: true,\n    composed: true\n  });\n  ev.detail = detail;\n  wrap( /** @type {!Node} */target).dispatchEvent(ev);\n  // Forward `preventDefault` in a clean way\n  if (ev.defaultPrevented) {\n    const preventer = detail.preventer || detail.sourceEvent;\n    if (preventer && preventer.preventDefault) {\n      preventer.preventDefault();\n    }\n  }\n}\n\n/**\n * Prevents the dispatch and default action of the given event name.\n *\n * @param {string} evName Event name.\n * @return {void}\n */\nexport function prevent(evName) {\n  const recognizer = _findRecognizerByEvent(evName);\n  if (recognizer.info) {\n    recognizer.info.prevent = true;\n  }\n}\nregister({\n  name: 'downup',\n  deps: ['mousedown', 'touchstart', 'touchend'],\n  flow: {\n    start: ['mousedown', 'touchstart'],\n    end: ['mouseup', 'touchend']\n  },\n  emits: ['down', 'up'],\n  info: {\n    movefn: null,\n    upfn: null\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @return {void}\n   */\n  reset() {\n    untrackDocument(this.info);\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   * @return {void}\n   */\n  mousedown(e) {\n    if (!hasLeftMouseButton(e)) {\n      return;\n    }\n    const t = _findOriginalTarget(e);\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    const movefn = e => {\n      if (!hasLeftMouseButton(e)) {\n        downupFire('up', t, e);\n        untrackDocument(self.info);\n      }\n    };\n    const upfn = e => {\n      if (hasLeftMouseButton(e)) {\n        downupFire('up', t, e);\n      }\n      untrackDocument(self.info);\n    };\n    trackDocument(this.info, movefn, upfn);\n    downupFire('down', t, e);\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchstart(e) {\n    downupFire('down', _findOriginalTarget(e), e.changedTouches[0], e);\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchend(e) {\n    downupFire('up', _findOriginalTarget(e), e.changedTouches[0], e);\n  }\n});\n\n/**\n * @param {string} type\n * @param {EventTarget} target\n * @param {Event|Touch} event\n * @param {Event=} preventer\n * @return {void}\n */\nfunction downupFire(type, target, event, preventer) {\n  if (!target) {\n    return;\n  }\n  _fire(target, type, {\n    x: event.clientX,\n    y: event.clientY,\n    sourceEvent: event,\n    preventer,\n    prevent(e) {\n      return prevent(e);\n    }\n  });\n}\nregister({\n  name: 'track',\n  touchAction: 'none',\n  deps: ['mousedown', 'touchstart', 'touchmove', 'touchend'],\n  flow: {\n    start: ['mousedown', 'touchstart'],\n    end: ['mouseup', 'touchend']\n  },\n  emits: ['track'],\n  info: {\n    x: 0,\n    y: 0,\n    state: 'start',\n    started: false,\n    moves: [],\n    /** @this {GestureInfo} */\n    addMove(move) {\n      if (this.moves.length > TRACK_LENGTH) {\n        this.moves.shift();\n      }\n      this.moves.push(move);\n    },\n    movefn: null,\n    upfn: null,\n    prevent: false\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @return {void}\n   */\n  reset() {\n    this.info.state = 'start';\n    this.info.started = false;\n    this.info.moves = [];\n    this.info.x = 0;\n    this.info.y = 0;\n    this.info.prevent = false;\n    untrackDocument(this.info);\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   * @return {void}\n   */\n  mousedown(e) {\n    if (!hasLeftMouseButton(e)) {\n      return;\n    }\n    const t = _findOriginalTarget(e);\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    const movefn = e => {\n      const x = e.clientX,\n        y = e.clientY;\n      if (trackHasMovedEnough(self.info, x, y)) {\n        // First move is 'start', subsequent moves are 'move', mouseup is 'end'\n        self.info.state = self.info.started ? e.type === 'mouseup' ? 'end' : 'track' : 'start';\n        if (self.info.state === 'start') {\n          // If and only if tracking, always prevent tap\n          prevent('tap');\n        }\n        self.info.addMove({\n          x,\n          y\n        });\n        if (!hasLeftMouseButton(e)) {\n          // Always fire \"end\"\n          self.info.state = 'end';\n          untrackDocument(self.info);\n        }\n        if (t) {\n          trackFire(self.info, t, e);\n        }\n        self.info.started = true;\n      }\n    };\n    const upfn = e => {\n      if (self.info.started) {\n        movefn(e);\n      }\n\n      // Remove the temporary listeners\n      untrackDocument(self.info);\n    };\n    // Add temporary document listeners as mouse retargets\n    trackDocument(this.info, movefn, upfn);\n    this.info.x = e.clientX;\n    this.info.y = e.clientY;\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchstart(e) {\n    const ct = e.changedTouches[0];\n    this.info.x = ct.clientX;\n    this.info.y = ct.clientY;\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchmove(e) {\n    const t = _findOriginalTarget(e);\n    const ct = e.changedTouches[0];\n    const x = ct.clientX,\n      y = ct.clientY;\n    if (trackHasMovedEnough(this.info, x, y)) {\n      if (this.info.state === 'start') {\n        // If and only if tracking, always prevent tap\n        prevent('tap');\n      }\n      this.info.addMove({\n        x,\n        y\n      });\n      trackFire(this.info, t, ct);\n      this.info.state = 'track';\n      this.info.started = true;\n    }\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchend(e) {\n    const t = _findOriginalTarget(e);\n    const ct = e.changedTouches[0];\n    // Only trackend if track was started and not aborted\n    if (this.info.started) {\n      // Reset started state on up\n      this.info.state = 'end';\n      this.info.addMove({\n        x: ct.clientX,\n        y: ct.clientY\n      });\n      trackFire(this.info, t, ct);\n    }\n  }\n});\n\n/**\n * @param {!GestureInfo} info\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nfunction trackHasMovedEnough(info, x, y) {\n  if (info.prevent) {\n    return false;\n  }\n  if (info.started) {\n    return true;\n  }\n  const dx = Math.abs(info.x - x);\n  const dy = Math.abs(info.y - y);\n  return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;\n}\n\n/**\n * @param {!GestureInfo} info\n * @param {?EventTarget} target\n * @param {Touch} touch\n * @return {void}\n */\nfunction trackFire(info, target, touch) {\n  if (!target) {\n    return;\n  }\n  const secondlast = info.moves[info.moves.length - 2];\n  const lastmove = info.moves[info.moves.length - 1];\n  const dx = lastmove.x - info.x;\n  const dy = lastmove.y - info.y;\n  let ddx,\n    ddy = 0;\n  if (secondlast) {\n    ddx = lastmove.x - secondlast.x;\n    ddy = lastmove.y - secondlast.y;\n  }\n  _fire(target, 'track', {\n    state: info.state,\n    x: touch.clientX,\n    y: touch.clientY,\n    dx,\n    dy,\n    ddx,\n    ddy,\n    sourceEvent: touch,\n    hover() {\n      return deepTargetFind(touch.clientX, touch.clientY);\n    }\n  });\n}\nregister({\n  name: 'tap',\n  deps: ['mousedown', 'click', 'touchstart', 'touchend'],\n  flow: {\n    start: ['mousedown', 'touchstart'],\n    end: ['click', 'touchend']\n  },\n  emits: ['tap'],\n  info: {\n    x: NaN,\n    y: NaN,\n    prevent: false\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @return {void}\n   */\n  reset() {\n    this.info.x = NaN;\n    this.info.y = NaN;\n    this.info.prevent = false;\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   * @return {void}\n   */\n  mousedown(e) {\n    if (hasLeftMouseButton(e)) {\n      this.info.x = e.clientX;\n      this.info.y = e.clientY;\n    }\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   * @return {void}\n   */\n  click(e) {\n    if (hasLeftMouseButton(e)) {\n      trackForward(this.info, e);\n    }\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchstart(e) {\n    const touch = e.changedTouches[0];\n    this.info.x = touch.clientX;\n    this.info.y = touch.clientY;\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchend(e) {\n    trackForward(this.info, e.changedTouches[0], e);\n  }\n});\n\n/**\n * @param {!GestureInfo} info\n * @param {Event | Touch} e\n * @param {Event=} preventer\n * @return {void}\n */\nfunction trackForward(info, e, preventer) {\n  const dx = Math.abs(e.clientX - info.x);\n  const dy = Math.abs(e.clientY - info.y);\n  // Find original target from `preventer` for TouchEvents, or `e` for MouseEvents\n  const t = _findOriginalTarget(preventer || e);\n  if (!t || canBeDisabled[/** @type {!HTMLElement} */t.localName] && t.hasAttribute('disabled')) {\n    return;\n  }\n  // Dx,dy can be NaN if `click` has been simulated and there was no `down` for `start`\n  if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e)) {\n    // Prevent taps from being generated if an event has canceled them\n    if (!info.prevent) {\n      _fire(t, 'tap', {\n        x: e.clientX,\n        y: e.clientY,\n        sourceEvent: e,\n        preventer\n      });\n    }\n  }\n}","map":{"version":3,"names":["microTask","passiveTouchGestures","wrap","node","HAS_NATIVE_TA","document","head","style","touchAction","GESTURE_KEY","HANDLED_OBJ","TOUCH_ACTION","TAP_DISTANCE","TRACK_DISTANCE","TRACK_LENGTH","MOUSE_EVENTS","MOUSE_WHICH_TO_BUTTONS","MOUSE_HAS_BUTTONS","MouseEvent","buttons","e","isMouseEvent","name","indexOf","supportsPassive","opts","Object","defineProperty","get","window","addEventListener","removeEventListener","PASSIVE_TOUCH","eventName","passive","IS_TOUCH_ONLY","navigator","userAgent","match","canBeDisabled","button","command","fieldset","input","keygen","optgroup","option","select","textarea","hasLeftMouseButton","ev","type","undefined","which","Boolean","isSyntheticClick","detail","t","_findOriginalTarget","nodeType","Node","ELEMENT_NODE","bcr","getBoundingClientRect","x","pageX","y","pageY","left","right","top","bottom","POINTERSTATE","mouse","target","mouseIgnoreJob","touch","id","scrollDecided","firstTouchAction","ta","path","getComposedPath","i","n","length","trackDocument","stateObj","movefn","upfn","untrackDocument","ShadyDOM","noPatch","composedPath","event","gestures","recognizers","deepTargetFind","elementFromPoint","next","shadowRoot","oldNext","_handleNative","currentTarget","gobj","gs","startsWith","changedTouches","touches","identifier","_handleTouchAction","handled","skip","r","flow","start","reset","clientX","clientY","shouldPrevent","dx","Math","abs","dy","cancelable","preventDefault","prevent","addListener","evType","handler","_add","removeListener","_remove","recognizer","deps","dep","gd","_count","setTouchAction","register","recog","push","emits","forEach","emit","_findRecognizerByEvent","evName","j","value","HTMLElement","run","_fire","Event","bubbles","composed","dispatchEvent","defaultPrevented","preventer","sourceEvent","info","end","mousedown","self","downupFire","touchstart","touchend","state","started","moves","addMove","move","shift","trackHasMovedEnough","trackFire","ct","touchmove","secondlast","lastmove","ddx","ddy","hover","NaN","click","trackForward","localName","hasAttribute","isNaN"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@vaadin/component-base/src/gestures.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/* eslint-disable @typescript-eslint/no-use-before-define */\n\n/**\n * @fileoverview\n *\n * Module for adding listeners to a node for the following normalized\n * cross-platform \"gesture\" events:\n * - `down` - mouse or touch went down\n * - `up` - mouse or touch went up\n * - `tap` - mouse click or finger tap\n * - `track` - mouse drag or touch move\n *\n * @summary Module for adding cross-platform gesture event listeners.\n */\n\nimport { microTask } from './async.js';\n\nconst passiveTouchGestures = false;\nconst wrap = (node) => node;\n\n// Detect native touch action support\nconst HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';\nconst GESTURE_KEY = '__polymerGestures';\nconst HANDLED_OBJ = '__polymerGesturesHandled';\nconst TOUCH_ACTION = '__polymerGesturesTouchAction';\n// Radius for tap and track\nconst TAP_DISTANCE = 25;\nconst TRACK_DISTANCE = 5;\n// Number of last N track positions to keep\nconst TRACK_LENGTH = 2;\n\nconst MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'click'];\n// An array of bitmask values for mapping MouseEvent.which to MouseEvent.buttons\nconst MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];\nconst MOUSE_HAS_BUTTONS = (function () {\n  try {\n    return new MouseEvent('test', { buttons: 1 }).buttons === 1;\n  } catch (e) {\n    return false;\n  }\n})();\n\n/**\n * @param {string} name Possible mouse event name\n * @return {boolean} true if mouse event, false if not\n */\nfunction isMouseEvent(name) {\n  return MOUSE_EVENTS.indexOf(name) > -1;\n}\n\n/* eslint no-empty: [\"error\", { \"allowEmptyCatch\": true }] */\n// check for passive event listeners\nlet supportsPassive = false;\n(function () {\n  try {\n    const opts = Object.defineProperty({}, 'passive', {\n      // eslint-disable-next-line getter-return\n      get() {\n        supportsPassive = true;\n      },\n    });\n    window.addEventListener('test', null, opts);\n    window.removeEventListener('test', null, opts);\n  } catch (e) {}\n})();\n\n/**\n * Generate settings for event listeners, dependant on `passiveTouchGestures`\n *\n * @param {string} eventName Event name to determine if `{passive}` option is\n *   needed\n * @return {{passive: boolean} | undefined} Options to use for addEventListener\n *   and removeEventListener\n */\nfunction PASSIVE_TOUCH(eventName) {\n  if (isMouseEvent(eventName) || eventName === 'touchend') {\n    return;\n  }\n  if (HAS_NATIVE_TA && supportsPassive && passiveTouchGestures) {\n    return { passive: true };\n  }\n}\n\n// Check for touch-only devices\nconst IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/u);\n\n// Defined at https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#enabling-and-disabling-form-controls:-the-disabled-attribute\n/** @type {!Object<boolean>} */\nconst canBeDisabled = {\n  button: true,\n  command: true,\n  fieldset: true,\n  input: true,\n  keygen: true,\n  optgroup: true,\n  option: true,\n  select: true,\n  textarea: true,\n};\n\n/**\n * @param {MouseEvent} ev event to test for left mouse button down\n * @return {boolean} has left mouse button down\n */\nfunction hasLeftMouseButton(ev) {\n  const type = ev.type;\n  // Exit early if the event is not a mouse event\n  if (!isMouseEvent(type)) {\n    return false;\n  }\n  // Ev.button is not reliable for mousemove (0 is overloaded as both left button and no buttons)\n  // instead we use ev.buttons (bitmask of buttons) or fall back to ev.which (deprecated, 0 for no buttons, 1 for left button)\n  if (type === 'mousemove') {\n    // Allow undefined for testing events\n    let buttons = ev.buttons === undefined ? 1 : ev.buttons;\n    if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {\n      buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;\n    }\n    // Buttons is a bitmask, check that the left button bit is set (1)\n    return Boolean(buttons & 1);\n  }\n  // Allow undefined for testing events\n  const button = ev.button === undefined ? 0 : ev.button;\n  // Ev.button is 0 in mousedown/mouseup/click for left button activation\n  return button === 0;\n}\n\nfunction isSyntheticClick(ev) {\n  if (ev.type === 'click') {\n    // Ev.detail is 0 for HTMLElement.click in most browsers\n    if (ev.detail === 0) {\n      return true;\n    }\n    // In the worst case, check that the x/y position of the click is within\n    // the bounding box of the target of the event\n    // Thanks IE 10 >:(\n    const t = _findOriginalTarget(ev);\n    // Make sure the target of the event is an element so we can use getBoundingClientRect,\n    // if not, just assume it is a synthetic click\n    if (!t.nodeType || /** @type {Element} */ (t).nodeType !== Node.ELEMENT_NODE) {\n      return true;\n    }\n    const bcr = /** @type {Element} */ (t).getBoundingClientRect();\n    // Use page x/y to account for scrolling\n    const x = ev.pageX,\n      y = ev.pageY;\n    // Ev is a synthetic click if the position is outside the bounding box of the target\n    return !(x >= bcr.left && x <= bcr.right && y >= bcr.top && y <= bcr.bottom);\n  }\n  return false;\n}\n\nconst POINTERSTATE = {\n  mouse: {\n    target: null,\n    mouseIgnoreJob: null,\n  },\n  touch: {\n    x: 0,\n    y: 0,\n    id: -1,\n    scrollDecided: false,\n  },\n};\n\nfunction firstTouchAction(ev) {\n  let ta = 'auto';\n  const path = getComposedPath(ev);\n  for (let i = 0, n; i < path.length; i++) {\n    n = path[i];\n    if (n[TOUCH_ACTION]) {\n      ta = n[TOUCH_ACTION];\n      break;\n    }\n  }\n  return ta;\n}\n\nfunction trackDocument(stateObj, movefn, upfn) {\n  stateObj.movefn = movefn;\n  stateObj.upfn = upfn;\n  document.addEventListener('mousemove', movefn);\n  document.addEventListener('mouseup', upfn);\n}\n\nfunction untrackDocument(stateObj) {\n  document.removeEventListener('mousemove', stateObj.movefn);\n  document.removeEventListener('mouseup', stateObj.upfn);\n  stateObj.movefn = null;\n  stateObj.upfn = null;\n}\n\n/**\n * Returns the composedPath for the given event.\n * @param {Event} event to process\n * @return {!Array<!EventTarget>} Path of the event\n */\nconst getComposedPath =\n  window.ShadyDOM && window.ShadyDOM.noPatch\n    ? window.ShadyDOM.composedPath\n    : (event) => (event.composedPath && event.composedPath()) || [];\n\n/** @type {!Object<string, !GestureRecognizer>} */\nexport const gestures = {};\n\n/** @type {!Array<!GestureRecognizer>} */\nexport const recognizers = [];\n\n/**\n * Finds the element rendered on the screen at the provided coordinates.\n *\n * Similar to `document.elementFromPoint`, but pierces through\n * shadow roots.\n *\n * @param {number} x Horizontal pixel coordinate\n * @param {number} y Vertical pixel coordinate\n * @return {Element} Returns the deepest shadowRoot inclusive element\n * found at the screen position given.\n */\nexport function deepTargetFind(x, y) {\n  let node = document.elementFromPoint(x, y);\n  let next = node;\n  // This code path is only taken when native ShadowDOM is used\n  // if there is a shadowroot, it may have a node at x/y\n  // if there is not a shadowroot, exit the loop\n  while (next && next.shadowRoot && !window.ShadyDOM) {\n    // If there is a node at x/y in the shadowroot, look deeper\n    const oldNext = next;\n    next = next.shadowRoot.elementFromPoint(x, y);\n    // On Safari, elementFromPoint may return the shadowRoot host\n    if (oldNext === next) {\n      break;\n    }\n    if (next) {\n      node = next;\n    }\n  }\n  return node;\n}\n\n/**\n * A cheaper check than ev.composedPath()[0];\n *\n * @private\n * @param {Event|Touch} ev Event.\n * @return {EventTarget} Returns the event target.\n */\nfunction _findOriginalTarget(ev) {\n  const path = getComposedPath(/** @type {?Event} */ (ev));\n  // It shouldn't be, but sometimes path is empty (window on Safari).\n  return path.length > 0 ? path[0] : ev.target;\n}\n\n/**\n * @private\n * @param {Event} ev Event.\n * @return {void}\n */\nfunction _handleNative(ev) {\n  const type = ev.type;\n  const node = ev.currentTarget;\n  const gobj = node[GESTURE_KEY];\n  if (!gobj) {\n    return;\n  }\n  const gs = gobj[type];\n  if (!gs) {\n    return;\n  }\n  if (!ev[HANDLED_OBJ]) {\n    ev[HANDLED_OBJ] = {};\n    if (type.startsWith('touch')) {\n      const t = ev.changedTouches[0];\n      if (type === 'touchstart') {\n        // Only handle the first finger\n        if (ev.touches.length === 1) {\n          POINTERSTATE.touch.id = t.identifier;\n        }\n      }\n      if (POINTERSTATE.touch.id !== t.identifier) {\n        return;\n      }\n      if (!HAS_NATIVE_TA) {\n        if (type === 'touchstart' || type === 'touchmove') {\n          _handleTouchAction(ev);\n        }\n      }\n    }\n  }\n  const handled = ev[HANDLED_OBJ];\n  // Used to ignore synthetic mouse events\n  if (handled.skip) {\n    return;\n  }\n  // Reset recognizer state\n  for (let i = 0, r; i < recognizers.length; i++) {\n    r = recognizers[i];\n    if (gs[r.name] && !handled[r.name]) {\n      if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {\n        r.reset();\n      }\n    }\n  }\n  // Enforce gesture recognizer order\n  for (let i = 0, r; i < recognizers.length; i++) {\n    r = recognizers[i];\n    if (gs[r.name] && !handled[r.name]) {\n      handled[r.name] = true;\n      r[type](ev);\n    }\n  }\n}\n\n/**\n * @private\n * @param {TouchEvent} ev Event.\n * @return {void}\n */\nfunction _handleTouchAction(ev) {\n  const t = ev.changedTouches[0];\n  const type = ev.type;\n  if (type === 'touchstart') {\n    POINTERSTATE.touch.x = t.clientX;\n    POINTERSTATE.touch.y = t.clientY;\n    POINTERSTATE.touch.scrollDecided = false;\n  } else if (type === 'touchmove') {\n    if (POINTERSTATE.touch.scrollDecided) {\n      return;\n    }\n    POINTERSTATE.touch.scrollDecided = true;\n    const ta = firstTouchAction(ev);\n    let shouldPrevent = false;\n    const dx = Math.abs(POINTERSTATE.touch.x - t.clientX);\n    const dy = Math.abs(POINTERSTATE.touch.y - t.clientY);\n    if (!ev.cancelable) {\n      // Scrolling is happening\n    } else if (ta === 'none') {\n      shouldPrevent = true;\n    } else if (ta === 'pan-x') {\n      shouldPrevent = dy > dx;\n    } else if (ta === 'pan-y') {\n      shouldPrevent = dx > dy;\n    }\n    if (shouldPrevent) {\n      ev.preventDefault();\n    } else {\n      prevent('track');\n    }\n  }\n}\n\n/**\n * Adds an event listener to a node for the given gesture type.\n *\n * @param {!EventTarget} node Node to add listener on\n * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`\n * @param {!function(!Event):void} handler Event listener function to call\n * @return {boolean} Returns true if a gesture event listener was added.\n */\nexport function addListener(node, evType, handler) {\n  if (gestures[evType]) {\n    _add(node, evType, handler);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Removes an event listener from a node for the given gesture type.\n *\n * @param {!EventTarget} node Node to remove listener from\n * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`\n * @param {!function(!Event):void} handler Event listener function previously passed to\n *  `addListener`.\n * @return {boolean} Returns true if a gesture event listener was removed.\n */\nexport function removeListener(node, evType, handler) {\n  if (gestures[evType]) {\n    _remove(node, evType, handler);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Automate the event listeners for the native events\n *\n * @private\n * @param {!EventTarget} node Node on which to add the event.\n * @param {string} evType Event type to add.\n * @param {function(!Event)} handler Event handler function.\n * @return {void}\n */\nfunction _add(node, evType, handler) {\n  const recognizer = gestures[evType];\n  const deps = recognizer.deps;\n  const name = recognizer.name;\n  let gobj = node[GESTURE_KEY];\n  if (!gobj) {\n    node[GESTURE_KEY] = gobj = {};\n  }\n  for (let i = 0, dep, gd; i < deps.length; i++) {\n    dep = deps[i];\n    // Don't add mouse handlers on iOS because they cause gray selection overlays\n    if (IS_TOUCH_ONLY && isMouseEvent(dep) && dep !== 'click') {\n      continue;\n    }\n    gd = gobj[dep];\n    if (!gd) {\n      gobj[dep] = gd = { _count: 0 };\n    }\n    if (gd._count === 0) {\n      node.addEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));\n    }\n    gd[name] = (gd[name] || 0) + 1;\n    gd._count = (gd._count || 0) + 1;\n  }\n  node.addEventListener(evType, handler);\n  if (recognizer.touchAction) {\n    setTouchAction(node, recognizer.touchAction);\n  }\n}\n\n/**\n * Automate event listener removal for native events\n *\n * @private\n * @param {!EventTarget} node Node on which to remove the event.\n * @param {string} evType Event type to remove.\n * @param {function(!Event): void} handler Event handler function.\n * @return {void}\n */\nfunction _remove(node, evType, handler) {\n  const recognizer = gestures[evType];\n  const deps = recognizer.deps;\n  const name = recognizer.name;\n  const gobj = node[GESTURE_KEY];\n  if (gobj) {\n    for (let i = 0, dep, gd; i < deps.length; i++) {\n      dep = deps[i];\n      gd = gobj[dep];\n      if (gd && gd[name]) {\n        gd[name] = (gd[name] || 1) - 1;\n        gd._count = (gd._count || 1) - 1;\n        if (gd._count === 0) {\n          node.removeEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));\n        }\n      }\n    }\n  }\n  node.removeEventListener(evType, handler);\n}\n\n/**\n * Registers a new gesture event recognizer for adding new custom\n * gesture event types.\n *\n * @param {!GestureRecognizer} recog Gesture recognizer descriptor\n * @return {void}\n */\nexport function register(recog) {\n  recognizers.push(recog);\n  recog.emits.forEach((emit) => {\n    gestures[emit] = recog;\n  });\n}\n\n/**\n * @private\n * @param {string} evName Event name.\n * @return {Object} Returns the gesture for the given event name.\n */\nfunction _findRecognizerByEvent(evName) {\n  for (let i = 0, r; i < recognizers.length; i++) {\n    r = recognizers[i];\n    for (let j = 0, n; j < r.emits.length; j++) {\n      n = r.emits[j];\n      if (n === evName) {\n        return r;\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Sets scrolling direction on node.\n *\n * This value is checked on first move, thus it should be called prior to\n * adding event listeners.\n *\n * @param {!EventTarget} node Node to set touch action setting on\n * @param {string} value Touch action value\n * @return {void}\n */\nexport function setTouchAction(node, value) {\n  if (HAS_NATIVE_TA && node instanceof HTMLElement) {\n    // NOTE: add touchAction async so that events can be added in\n    // custom element constructors. Otherwise we run afoul of custom\n    // elements restriction against settings attributes (style) in the\n    // constructor.\n    microTask.run(() => {\n      node.style.touchAction = value;\n    });\n  }\n  node[TOUCH_ACTION] = value;\n}\n\n/**\n * Dispatches an event on the `target` element of `type` with the given\n * `detail`.\n * @private\n * @param {!EventTarget} target The element on which to fire an event.\n * @param {string} type The type of event to fire.\n * @param {!Object=} detail The detail object to populate on the event.\n * @return {void}\n */\nfunction _fire(target, type, detail) {\n  const ev = new Event(type, { bubbles: true, cancelable: true, composed: true });\n  ev.detail = detail;\n  wrap(/** @type {!Node} */ (target)).dispatchEvent(ev);\n  // Forward `preventDefault` in a clean way\n  if (ev.defaultPrevented) {\n    const preventer = detail.preventer || detail.sourceEvent;\n    if (preventer && preventer.preventDefault) {\n      preventer.preventDefault();\n    }\n  }\n}\n\n/**\n * Prevents the dispatch and default action of the given event name.\n *\n * @param {string} evName Event name.\n * @return {void}\n */\nexport function prevent(evName) {\n  const recognizer = _findRecognizerByEvent(evName);\n  if (recognizer.info) {\n    recognizer.info.prevent = true;\n  }\n}\n\nregister({\n  name: 'downup',\n  deps: ['mousedown', 'touchstart', 'touchend'],\n  flow: {\n    start: ['mousedown', 'touchstart'],\n    end: ['mouseup', 'touchend'],\n  },\n  emits: ['down', 'up'],\n\n  info: {\n    movefn: null,\n    upfn: null,\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @return {void}\n   */\n  reset() {\n    untrackDocument(this.info);\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   * @return {void}\n   */\n  mousedown(e) {\n    if (!hasLeftMouseButton(e)) {\n      return;\n    }\n    const t = _findOriginalTarget(e);\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    const movefn = (e) => {\n      if (!hasLeftMouseButton(e)) {\n        downupFire('up', t, e);\n        untrackDocument(self.info);\n      }\n    };\n    const upfn = (e) => {\n      if (hasLeftMouseButton(e)) {\n        downupFire('up', t, e);\n      }\n      untrackDocument(self.info);\n    };\n    trackDocument(this.info, movefn, upfn);\n    downupFire('down', t, e);\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchstart(e) {\n    downupFire('down', _findOriginalTarget(e), e.changedTouches[0], e);\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchend(e) {\n    downupFire('up', _findOriginalTarget(e), e.changedTouches[0], e);\n  },\n});\n\n/**\n * @param {string} type\n * @param {EventTarget} target\n * @param {Event|Touch} event\n * @param {Event=} preventer\n * @return {void}\n */\nfunction downupFire(type, target, event, preventer) {\n  if (!target) {\n    return;\n  }\n  _fire(target, type, {\n    x: event.clientX,\n    y: event.clientY,\n    sourceEvent: event,\n    preventer,\n    prevent(e) {\n      return prevent(e);\n    },\n  });\n}\n\nregister({\n  name: 'track',\n  touchAction: 'none',\n  deps: ['mousedown', 'touchstart', 'touchmove', 'touchend'],\n  flow: {\n    start: ['mousedown', 'touchstart'],\n    end: ['mouseup', 'touchend'],\n  },\n  emits: ['track'],\n\n  info: {\n    x: 0,\n    y: 0,\n    state: 'start',\n    started: false,\n    moves: [],\n    /** @this {GestureInfo} */\n    addMove(move) {\n      if (this.moves.length > TRACK_LENGTH) {\n        this.moves.shift();\n      }\n      this.moves.push(move);\n    },\n    movefn: null,\n    upfn: null,\n    prevent: false,\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @return {void}\n   */\n  reset() {\n    this.info.state = 'start';\n    this.info.started = false;\n    this.info.moves = [];\n    this.info.x = 0;\n    this.info.y = 0;\n    this.info.prevent = false;\n    untrackDocument(this.info);\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   * @return {void}\n   */\n  mousedown(e) {\n    if (!hasLeftMouseButton(e)) {\n      return;\n    }\n    const t = _findOriginalTarget(e);\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    const movefn = (e) => {\n      const x = e.clientX,\n        y = e.clientY;\n      if (trackHasMovedEnough(self.info, x, y)) {\n        // First move is 'start', subsequent moves are 'move', mouseup is 'end'\n        self.info.state = self.info.started ? (e.type === 'mouseup' ? 'end' : 'track') : 'start';\n        if (self.info.state === 'start') {\n          // If and only if tracking, always prevent tap\n          prevent('tap');\n        }\n        self.info.addMove({ x, y });\n        if (!hasLeftMouseButton(e)) {\n          // Always fire \"end\"\n          self.info.state = 'end';\n          untrackDocument(self.info);\n        }\n        if (t) {\n          trackFire(self.info, t, e);\n        }\n        self.info.started = true;\n      }\n    };\n    const upfn = (e) => {\n      if (self.info.started) {\n        movefn(e);\n      }\n\n      // Remove the temporary listeners\n      untrackDocument(self.info);\n    };\n    // Add temporary document listeners as mouse retargets\n    trackDocument(this.info, movefn, upfn);\n    this.info.x = e.clientX;\n    this.info.y = e.clientY;\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchstart(e) {\n    const ct = e.changedTouches[0];\n    this.info.x = ct.clientX;\n    this.info.y = ct.clientY;\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchmove(e) {\n    const t = _findOriginalTarget(e);\n    const ct = e.changedTouches[0];\n    const x = ct.clientX,\n      y = ct.clientY;\n    if (trackHasMovedEnough(this.info, x, y)) {\n      if (this.info.state === 'start') {\n        // If and only if tracking, always prevent tap\n        prevent('tap');\n      }\n      this.info.addMove({ x, y });\n      trackFire(this.info, t, ct);\n      this.info.state = 'track';\n      this.info.started = true;\n    }\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchend(e) {\n    const t = _findOriginalTarget(e);\n    const ct = e.changedTouches[0];\n    // Only trackend if track was started and not aborted\n    if (this.info.started) {\n      // Reset started state on up\n      this.info.state = 'end';\n      this.info.addMove({ x: ct.clientX, y: ct.clientY });\n      trackFire(this.info, t, ct);\n    }\n  },\n});\n\n/**\n * @param {!GestureInfo} info\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nfunction trackHasMovedEnough(info, x, y) {\n  if (info.prevent) {\n    return false;\n  }\n  if (info.started) {\n    return true;\n  }\n  const dx = Math.abs(info.x - x);\n  const dy = Math.abs(info.y - y);\n  return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;\n}\n\n/**\n * @param {!GestureInfo} info\n * @param {?EventTarget} target\n * @param {Touch} touch\n * @return {void}\n */\nfunction trackFire(info, target, touch) {\n  if (!target) {\n    return;\n  }\n  const secondlast = info.moves[info.moves.length - 2];\n  const lastmove = info.moves[info.moves.length - 1];\n  const dx = lastmove.x - info.x;\n  const dy = lastmove.y - info.y;\n  let ddx,\n    ddy = 0;\n  if (secondlast) {\n    ddx = lastmove.x - secondlast.x;\n    ddy = lastmove.y - secondlast.y;\n  }\n  _fire(target, 'track', {\n    state: info.state,\n    x: touch.clientX,\n    y: touch.clientY,\n    dx,\n    dy,\n    ddx,\n    ddy,\n    sourceEvent: touch,\n    hover() {\n      return deepTargetFind(touch.clientX, touch.clientY);\n    },\n  });\n}\n\nregister({\n  name: 'tap',\n  deps: ['mousedown', 'click', 'touchstart', 'touchend'],\n  flow: {\n    start: ['mousedown', 'touchstart'],\n    end: ['click', 'touchend'],\n  },\n  emits: ['tap'],\n  info: {\n    x: NaN,\n    y: NaN,\n    prevent: false,\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @return {void}\n   */\n  reset() {\n    this.info.x = NaN;\n    this.info.y = NaN;\n    this.info.prevent = false;\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   * @return {void}\n   */\n  mousedown(e) {\n    if (hasLeftMouseButton(e)) {\n      this.info.x = e.clientX;\n      this.info.y = e.clientY;\n    }\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   * @return {void}\n   */\n  click(e) {\n    if (hasLeftMouseButton(e)) {\n      trackForward(this.info, e);\n    }\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchstart(e) {\n    const touch = e.changedTouches[0];\n    this.info.x = touch.clientX;\n    this.info.y = touch.clientY;\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchend(e) {\n    trackForward(this.info, e.changedTouches[0], e);\n  },\n});\n\n/**\n * @param {!GestureInfo} info\n * @param {Event | Touch} e\n * @param {Event=} preventer\n * @return {void}\n */\nfunction trackForward(info, e, preventer) {\n  const dx = Math.abs(e.clientX - info.x);\n  const dy = Math.abs(e.clientY - info.y);\n  // Find original target from `preventer` for TouchEvents, or `e` for MouseEvents\n  const t = _findOriginalTarget(preventer || e);\n  if (!t || (canBeDisabled[/** @type {!HTMLElement} */ (t).localName] && t.hasAttribute('disabled'))) {\n    return;\n  }\n  // Dx,dy can be NaN if `click` has been simulated and there was no `down` for `start`\n  if (isNaN(dx) || isNaN(dy) || (dx <= TAP_DISTANCE && dy <= TAP_DISTANCE) || isSyntheticClick(e)) {\n    // Prevent taps from being generated if an event has canceled them\n    if (!info.prevent) {\n      _fire(t, 'tap', {\n        x: e.clientX,\n        y: e.clientY,\n        sourceEvent: e,\n        preventer,\n      });\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}