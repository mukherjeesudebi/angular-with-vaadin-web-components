{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2021 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n/**\n * Returns an array of ancestor root nodes for the given node.\n *\n * A root node is either a document node or a document fragment node (Shadow Root).\n * The array is collected by a bottom-up DOM traversing that starts with the given node\n * and involves both the light DOM and ancestor shadow DOM trees.\n *\n * @param {Node} node\n * @return {Node[]}\n */\nexport function getAncestorRootNodes(node) {\n  const result = [];\n  while (node) {\n    if (node.nodeType === Node.DOCUMENT_NODE) {\n      result.push(node);\n      break;\n    }\n    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n      result.push(node);\n      node = node.host;\n      continue;\n    }\n    if (node.assignedSlot) {\n      node = node.assignedSlot;\n      continue;\n    }\n    node = node.parentNode;\n  }\n  return result;\n}\n\n/**\n * Returns the list of flattened elements for the given `node`.\n * This list consists of a node's children and, for any children that are\n * `<slot>` elements, the expanded flattened list of `assignedElements`.\n *\n * @param {Node} node\n * @return {Element[]}\n */\nexport function getFlattenedElements(node) {\n  const result = [];\n  let elements;\n  if (node.localName === 'slot') {\n    elements = node.assignedElements();\n  } else {\n    result.push(node);\n    elements = [...node.children];\n  }\n  elements.forEach(elem => result.push(...getFlattenedElements(elem)));\n  return result;\n}\n\n/**\n * Traverses the given node and its parents, including those that are across\n * the shadow root boundaries, until it finds a node that matches the selector.\n *\n * @param {string} selector The CSS selector to match against\n * @param {Node} node The starting node for the traversal\n * @return {Node | null} The closest matching element, or null if no match is found\n */\nexport function getClosestElement(selector, node) {\n  if (!node) {\n    return null;\n  }\n  return node.closest(selector) || getClosestElement(selector, node.getRootNode().host);\n}\n\n/**\n * Takes a string with values separated by space and returns a set the values\n *\n * @param {string} value\n * @return {Set<string>}\n */\nexport function deserializeAttributeValue(value) {\n  if (!value) {\n    return new Set();\n  }\n  return new Set(value.split(' '));\n}\n\n/**\n * Takes a set of string values and returns a string with values separated by space\n *\n * @param {Set<string>} values\n * @return {string}\n */\nexport function serializeAttributeValue(values) {\n  return values ? [...values].join(' ') : '';\n}\n\n/**\n * Adds a value to an attribute containing space-delimited values.\n *\n * @param {HTMLElement} element\n * @param {string} attr\n * @param {string} value\n */\nexport function addValueToAttribute(element, attr, value) {\n  const values = deserializeAttributeValue(element.getAttribute(attr));\n  values.add(value);\n  element.setAttribute(attr, serializeAttributeValue(values));\n}\n\n/**\n * Removes a value from an attribute containing space-delimited values.\n * If the value is the last one, the whole attribute is removed.\n *\n * @param {HTMLElement} element\n * @param {string} attr\n * @param {string} value\n */\nexport function removeValueFromAttribute(element, attr, value) {\n  const values = deserializeAttributeValue(element.getAttribute(attr));\n  values.delete(value);\n  if (values.size === 0) {\n    element.removeAttribute(attr);\n    return;\n  }\n  element.setAttribute(attr, serializeAttributeValue(values));\n}\n\n/**\n * Returns true if the given node is an empty text node, false otherwise.\n *\n * @param {Node} node\n * @return {boolean}\n */\nexport function isEmptyTextNode(node) {\n  return node.nodeType === Node.TEXT_NODE && node.textContent.trim() === '';\n}","map":{"version":3,"names":["getAncestorRootNodes","node","result","nodeType","Node","DOCUMENT_NODE","push","DOCUMENT_FRAGMENT_NODE","host","assignedSlot","parentNode","getFlattenedElements","elements","localName","assignedElements","children","forEach","elem","getClosestElement","selector","closest","getRootNode","deserializeAttributeValue","value","Set","split","serializeAttributeValue","values","join","addValueToAttribute","element","attr","getAttribute","add","setAttribute","removeValueFromAttribute","delete","size","removeAttribute","isEmptyTextNode","TEXT_NODE","textContent","trim"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@vaadin/component-base/src/dom-utils.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2021 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n/**\n * Returns an array of ancestor root nodes for the given node.\n *\n * A root node is either a document node or a document fragment node (Shadow Root).\n * The array is collected by a bottom-up DOM traversing that starts with the given node\n * and involves both the light DOM and ancestor shadow DOM trees.\n *\n * @param {Node} node\n * @return {Node[]}\n */\nexport function getAncestorRootNodes(node) {\n  const result = [];\n\n  while (node) {\n    if (node.nodeType === Node.DOCUMENT_NODE) {\n      result.push(node);\n      break;\n    }\n\n    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n      result.push(node);\n      node = node.host;\n      continue;\n    }\n\n    if (node.assignedSlot) {\n      node = node.assignedSlot;\n      continue;\n    }\n\n    node = node.parentNode;\n  }\n\n  return result;\n}\n\n/**\n * Returns the list of flattened elements for the given `node`.\n * This list consists of a node's children and, for any children that are\n * `<slot>` elements, the expanded flattened list of `assignedElements`.\n *\n * @param {Node} node\n * @return {Element[]}\n */\nexport function getFlattenedElements(node) {\n  const result = [];\n  let elements;\n  if (node.localName === 'slot') {\n    elements = node.assignedElements();\n  } else {\n    result.push(node);\n    elements = [...node.children];\n  }\n  elements.forEach((elem) => result.push(...getFlattenedElements(elem)));\n  return result;\n}\n\n/**\n * Traverses the given node and its parents, including those that are across\n * the shadow root boundaries, until it finds a node that matches the selector.\n *\n * @param {string} selector The CSS selector to match against\n * @param {Node} node The starting node for the traversal\n * @return {Node | null} The closest matching element, or null if no match is found\n */\nexport function getClosestElement(selector, node) {\n  if (!node) {\n    return null;\n  }\n\n  return node.closest(selector) || getClosestElement(selector, node.getRootNode().host);\n}\n\n/**\n * Takes a string with values separated by space and returns a set the values\n *\n * @param {string} value\n * @return {Set<string>}\n */\nexport function deserializeAttributeValue(value) {\n  if (!value) {\n    return new Set();\n  }\n\n  return new Set(value.split(' '));\n}\n\n/**\n * Takes a set of string values and returns a string with values separated by space\n *\n * @param {Set<string>} values\n * @return {string}\n */\nexport function serializeAttributeValue(values) {\n  return values ? [...values].join(' ') : '';\n}\n\n/**\n * Adds a value to an attribute containing space-delimited values.\n *\n * @param {HTMLElement} element\n * @param {string} attr\n * @param {string} value\n */\nexport function addValueToAttribute(element, attr, value) {\n  const values = deserializeAttributeValue(element.getAttribute(attr));\n  values.add(value);\n  element.setAttribute(attr, serializeAttributeValue(values));\n}\n\n/**\n * Removes a value from an attribute containing space-delimited values.\n * If the value is the last one, the whole attribute is removed.\n *\n * @param {HTMLElement} element\n * @param {string} attr\n * @param {string} value\n */\nexport function removeValueFromAttribute(element, attr, value) {\n  const values = deserializeAttributeValue(element.getAttribute(attr));\n  values.delete(value);\n  if (values.size === 0) {\n    element.removeAttribute(attr);\n    return;\n  }\n  element.setAttribute(attr, serializeAttributeValue(values));\n}\n\n/**\n * Returns true if the given node is an empty text node, false otherwise.\n *\n * @param {Node} node\n * @return {boolean}\n */\nexport function isEmptyTextNode(node) {\n  return node.nodeType === Node.TEXT_NODE && node.textContent.trim() === '';\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,oBAAoBA,CAACC,IAAI,EAAE;EACzC,MAAMC,MAAM,GAAG,EAAE;EAEjB,OAAOD,IAAI,EAAE;IACX,IAAIA,IAAI,CAACE,QAAQ,KAAKC,IAAI,CAACC,aAAa,EAAE;MACxCH,MAAM,CAACI,IAAI,CAACL,IAAI,CAAC;MACjB;IACF;IAEA,IAAIA,IAAI,CAACE,QAAQ,KAAKC,IAAI,CAACG,sBAAsB,EAAE;MACjDL,MAAM,CAACI,IAAI,CAACL,IAAI,CAAC;MACjBA,IAAI,GAAGA,IAAI,CAACO,IAAI;MAChB;IACF;IAEA,IAAIP,IAAI,CAACQ,YAAY,EAAE;MACrBR,IAAI,GAAGA,IAAI,CAACQ,YAAY;MACxB;IACF;IAEAR,IAAI,GAAGA,IAAI,CAACS,UAAU;EACxB;EAEA,OAAOR,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASS,oBAAoBA,CAACV,IAAI,EAAE;EACzC,MAAMC,MAAM,GAAG,EAAE;EACjB,IAAIU,QAAQ;EACZ,IAAIX,IAAI,CAACY,SAAS,KAAK,MAAM,EAAE;IAC7BD,QAAQ,GAAGX,IAAI,CAACa,gBAAgB,CAAC,CAAC;EACpC,CAAC,MAAM;IACLZ,MAAM,CAACI,IAAI,CAACL,IAAI,CAAC;IACjBW,QAAQ,GAAG,CAAC,GAAGX,IAAI,CAACc,QAAQ,CAAC;EAC/B;EACAH,QAAQ,CAACI,OAAO,CAAEC,IAAI,IAAKf,MAAM,CAACI,IAAI,CAAC,GAAGK,oBAAoB,CAACM,IAAI,CAAC,CAAC,CAAC;EACtE,OAAOf,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASgB,iBAAiBA,CAACC,QAAQ,EAAElB,IAAI,EAAE;EAChD,IAAI,CAACA,IAAI,EAAE;IACT,OAAO,IAAI;EACb;EAEA,OAAOA,IAAI,CAACmB,OAAO,CAACD,QAAQ,CAAC,IAAID,iBAAiB,CAACC,QAAQ,EAAElB,IAAI,CAACoB,WAAW,CAAC,CAAC,CAACb,IAAI,CAAC;AACvF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASc,yBAAyBA,CAACC,KAAK,EAAE;EAC/C,IAAI,CAACA,KAAK,EAAE;IACV,OAAO,IAAIC,GAAG,CAAC,CAAC;EAClB;EAEA,OAAO,IAAIA,GAAG,CAACD,KAAK,CAACE,KAAK,CAAC,GAAG,CAAC,CAAC;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,uBAAuBA,CAACC,MAAM,EAAE;EAC9C,OAAOA,MAAM,GAAG,CAAC,GAAGA,MAAM,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,mBAAmBA,CAACC,OAAO,EAAEC,IAAI,EAAER,KAAK,EAAE;EACxD,MAAMI,MAAM,GAAGL,yBAAyB,CAACQ,OAAO,CAACE,YAAY,CAACD,IAAI,CAAC,CAAC;EACpEJ,MAAM,CAACM,GAAG,CAACV,KAAK,CAAC;EACjBO,OAAO,CAACI,YAAY,CAACH,IAAI,EAAEL,uBAAuB,CAACC,MAAM,CAAC,CAAC;AAC7D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASQ,wBAAwBA,CAACL,OAAO,EAAEC,IAAI,EAAER,KAAK,EAAE;EAC7D,MAAMI,MAAM,GAAGL,yBAAyB,CAACQ,OAAO,CAACE,YAAY,CAACD,IAAI,CAAC,CAAC;EACpEJ,MAAM,CAACS,MAAM,CAACb,KAAK,CAAC;EACpB,IAAII,MAAM,CAACU,IAAI,KAAK,CAAC,EAAE;IACrBP,OAAO,CAACQ,eAAe,CAACP,IAAI,CAAC;IAC7B;EACF;EACAD,OAAO,CAACI,YAAY,CAACH,IAAI,EAAEL,uBAAuB,CAACC,MAAM,CAAC,CAAC;AAC7D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASY,eAAeA,CAACtC,IAAI,EAAE;EACpC,OAAOA,IAAI,CAACE,QAAQ,KAAKC,IAAI,CAACoC,SAAS,IAAIvC,IAAI,CAACwC,WAAW,CAACC,IAAI,CAAC,CAAC,KAAK,EAAE;AAC3E"},"metadata":{},"sourceType":"module","externalDependencies":[]}