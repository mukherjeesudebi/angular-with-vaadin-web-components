{"ast":null,"code":"/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport { PolymerElement } from '../../polymer-element.js';\nimport { TemplateInstanceBase, templatize, modelForElement } from '../utils/templatize.js'; // eslint-disable-line no-unused-vars\nimport { Debouncer } from '../utils/debounce.js';\nimport { enqueueDebouncer, flush } from '../utils/flush.js';\nimport { OptionalMutableData } from '../mixins/mutable-data.js';\nimport { matches, translate } from '../utils/path.js';\nimport { timeOut, microTask } from '../utils/async.js';\nimport { wrap } from '../utils/wrap.js';\n\n/**\n * @constructor\n * @implements {Polymer_OptionalMutableData}\n * @extends {PolymerElement}\n * @private\n */\nconst domRepeatBase = OptionalMutableData(PolymerElement);\n\n/**\n * The `<dom-repeat>` element will automatically stamp and binds one instance\n * of template content to each object in a user-provided array.\n * `dom-repeat` accepts an `items` property, and one instance of the template\n * is stamped for each item into the DOM at the location of the `dom-repeat`\n * element.  The `item` property will be set on each instance's binding\n * scope, thus templates should bind to sub-properties of `item`.\n *\n * Example:\n *\n * ```html\n * <dom-module id=\"employee-list\">\n *\n *   <template>\n *\n *     <div> Employee list: </div>\n *     <dom-repeat items=\"{{employees}}\">\n *       <template>\n *         <div>First name: <span>{{item.first}}</span></div>\n *         <div>Last name: <span>{{item.last}}</span></div>\n *       </template>\n *     </dom-repeat>\n *\n *   </template>\n *\n * </dom-module>\n * ```\n *\n * With the following custom element definition:\n *\n * ```js\n * class EmployeeList extends PolymerElement {\n *   static get is() { return 'employee-list'; }\n *   static get properties() {\n *     return {\n *       employees: {\n *         value() {\n *           return [\n *             {first: 'Bob', last: 'Smith'},\n *             {first: 'Sally', last: 'Johnson'},\n *             ...\n *           ];\n *         }\n *       }\n *     };\n *   }\n * }\n * ```\n *\n * Notifications for changes to items sub-properties will be forwarded to template\n * instances, which will update via the normal structured data notification system.\n *\n * Mutations to the `items` array itself should be made using the Array\n * mutation API's on the PropertyEffects mixin (`push`, `pop`, `splice`,\n * `shift`, `unshift`), and template instances will be kept in sync with the\n * data in the array.\n *\n * Events caught by event handlers within the `dom-repeat` template will be\n * decorated with a `model` property, which represents the binding scope for\n * each template instance.  The model should be used to manipulate data on the\n * instance, for example `event.model.set('item.checked', true);`.\n *\n * Alternatively, the model for a template instance for an element stamped by\n * a `dom-repeat` can be obtained using the `modelForElement` API on the\n * `dom-repeat` that stamped it, for example\n * `this.$.domRepeat.modelForElement(event.target).set('item.checked', true);`.\n * This may be useful for manipulating instance data of event targets obtained\n * by event handlers on parents of the `dom-repeat` (event delegation).\n *\n * A view-specific filter/sort may be applied to each `dom-repeat` by supplying a\n * `filter` and/or `sort` property.  This may be a string that names a function on\n * the host, or a function may be assigned to the property directly.  The functions\n * should implemented following the standard `Array` filter/sort API.\n *\n * In order to re-run the filter or sort functions based on changes to sub-fields\n * of `items`, the `observe` property may be set as a space-separated list of\n * `item` sub-fields that should cause a re-filter/sort when modified.  If\n * the filter or sort function depends on properties not contained in `items`,\n * the user should observe changes to those properties and call `render` to update\n * the view based on the dependency change.\n *\n * For example, for an `dom-repeat` with a filter of the following:\n *\n * ```js\n * isEngineer(item) {\n *   return item.type == 'engineer' || item.manager.type == 'engineer';\n * }\n * ```\n *\n * Then the `observe` property should be configured as follows:\n *\n * ```html\n * <dom-repeat items=\"{{employees}}\" filter=\"isEngineer\" observe=\"type manager.type\">\n * ```\n *\n * @customElement\n * @polymer\n * @extends {domRepeatBase}\n * @appliesMixin OptionalMutableData\n * @summary Custom element for stamping instance of a template bound to\n *   items in an array.\n */\nexport class DomRepeat extends domRepeatBase {\n  // Not needed to find template; can be removed once the analyzer\n  // can find the tag name from customElements.define call\n  static get is() {\n    return 'dom-repeat';\n  }\n  static get template() {\n    return null;\n  }\n  static get properties() {\n    /**\n     * Fired whenever DOM is added or removed by this template (by\n     * default, rendering occurs lazily).  To force immediate rendering, call\n     * `render`.\n     *\n     * @event dom-change\n     */\n    return {\n      /**\n       * An array containing items determining how many instances of the template\n       * to stamp and that that each template instance should bind to.\n       */\n      items: {\n        type: Array\n      },\n      /**\n       * The name of the variable to add to the binding scope for the array\n       * element associated with a given template instance.\n       */\n      as: {\n        type: String,\n        value: 'item'\n      },\n      /**\n       * The name of the variable to add to the binding scope with the index\n       * of the instance in the sorted and filtered list of rendered items.\n       * Note, for the index in the `this.items` array, use the value of the\n       * `itemsIndexAs` property.\n       */\n      indexAs: {\n        type: String,\n        value: 'index'\n      },\n      /**\n       * The name of the variable to add to the binding scope with the index\n       * of the instance in the `this.items` array. Note, for the index of\n       * this instance in the sorted and filtered list of rendered items,\n       * use the value of the `indexAs` property.\n       */\n      itemsIndexAs: {\n        type: String,\n        value: 'itemsIndex'\n      },\n      /**\n       * A function that should determine the sort order of the items.  This\n       * property should either be provided as a string, indicating a method\n       * name on the element's host, or else be an actual function.  The\n       * function should match the sort function passed to `Array.sort`.\n       * Using a sort function has no effect on the underlying `items` array.\n       */\n      sort: {\n        type: Function,\n        observer: '__sortChanged'\n      },\n      /**\n       * A function that can be used to filter items out of the view.  This\n       * property should either be provided as a string, indicating a method\n       * name on the element's host, or else be an actual function.  The\n       * function should match the sort function passed to `Array.filter`.\n       * Using a filter function has no effect on the underlying `items` array.\n       */\n      filter: {\n        type: Function,\n        observer: '__filterChanged'\n      },\n      /**\n       * When using a `filter` or `sort` function, the `observe` property\n       * should be set to a space-separated list of the names of item\n       * sub-fields that should trigger a re-sort or re-filter when changed.\n       * These should generally be fields of `item` that the sort or filter\n       * function depends on.\n       */\n      observe: {\n        type: String,\n        observer: '__observeChanged'\n      },\n      /**\n       * When using a `filter` or `sort` function, the `delay` property\n       * determines a debounce time in ms after a change to observed item\n       * properties that must pass before the filter or sort is re-run.\n       * This is useful in rate-limiting shuffling of the view when\n       * item changes may be frequent.\n       */\n      delay: Number,\n      /**\n       * Count of currently rendered items after `filter` (if any) has been applied.\n       * If \"chunking mode\" is enabled, `renderedItemCount` is updated each time a\n       * set of template instances is rendered.\n       *\n       */\n      renderedItemCount: {\n        type: Number,\n        notify: true,\n        readOnly: true\n      },\n      /**\n       * Defines an initial count of template instances to render after setting\n       * the `items` array, before the next paint, and puts the `dom-repeat`\n       * into \"chunking mode\".  The remaining items will be created and rendered\n       * incrementally at each animation frame therof until all instances have\n       * been rendered.\n       */\n      initialCount: {\n        type: Number,\n        observer: '__initializeChunking'\n      },\n      /**\n       * When `initialCount` is used, this property defines a frame rate (in\n       * fps) to target by throttling the number of instances rendered each\n       * frame to not exceed the budget for the target frame rate.  The\n       * framerate is effectively the number of `requestAnimationFrame`s that\n       * it tries to allow to actually fire in a given second. It does this\n       * by measuring the time between `rAF`s and continuously adjusting the\n       * number of items created each `rAF` to maintain the target framerate.\n       * Setting this to a higher number allows lower latency and higher\n       * throughput for event handlers and other tasks, but results in a\n       * longer time for the remaining items to complete rendering.\n       */\n      targetFramerate: {\n        type: Number,\n        value: 20\n      },\n      _targetFrameTime: {\n        type: Number,\n        computed: '__computeFrameTime(targetFramerate)'\n      }\n    };\n  }\n  static get observers() {\n    return ['__itemsChanged(items.*)'];\n  }\n  constructor() {\n    super();\n    this.__instances = [];\n    this.__limit = Infinity;\n    this.__pool = [];\n    this.__renderDebouncer = null;\n    this.__itemsIdxToInstIdx = {};\n    this.__chunkCount = null;\n    this.__lastChunkTime = null;\n    this.__sortFn = null;\n    this.__filterFn = null;\n    this.__observePaths = null;\n    /** @type {?function(new:Polymer.TemplateInstanceBase, *)} */\n    this.__ctor = null;\n    this.__isDetached = true;\n    this.template = null;\n  }\n\n  /**\n   * @override\n   * @return {void}\n   */\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this.__isDetached = true;\n    for (let i = 0; i < this.__instances.length; i++) {\n      this.__detachInstance(i);\n    }\n  }\n\n  /**\n   * @override\n   * @return {void}\n   */\n  connectedCallback() {\n    super.connectedCallback();\n    this.style.display = 'none';\n    // only perform attachment if the element was previously detached.\n    if (this.__isDetached) {\n      this.__isDetached = false;\n      let wrappedParent = wrap(wrap(this).parentNode);\n      for (let i = 0; i < this.__instances.length; i++) {\n        this.__attachInstance(i, wrappedParent);\n      }\n    }\n  }\n  __ensureTemplatized() {\n    // Templatizing (generating the instance constructor) needs to wait\n    // until ready, since won't have its template content handed back to\n    // it until then\n    if (!this.__ctor) {\n      let template = this.template = /** @type {HTMLTemplateElement} */this.querySelector('template');\n      if (!template) {\n        // // Wait until childList changes and template should be there by then\n        let observer = new MutationObserver(() => {\n          if (this.querySelector('template')) {\n            observer.disconnect();\n            this.__render();\n          } else {\n            throw new Error('dom-repeat requires a <template> child');\n          }\n        });\n        observer.observe(this, {\n          childList: true\n        });\n        return false;\n      }\n      // Template instance props that should be excluded from forwarding\n      let instanceProps = {};\n      instanceProps[this.as] = true;\n      instanceProps[this.indexAs] = true;\n      instanceProps[this.itemsIndexAs] = true;\n      this.__ctor = templatize(template, this, {\n        mutableData: this.mutableData,\n        parentModel: true,\n        instanceProps: instanceProps,\n        /**\n         * @this {DomRepeat}\n         * @param {string} prop Property to set\n         * @param {*} value Value to set property to\n         */\n        forwardHostProp: function (prop, value) {\n          let i$ = this.__instances;\n          for (let i = 0, inst; i < i$.length && (inst = i$[i]); i++) {\n            inst.forwardHostProp(prop, value);\n          }\n        },\n        /**\n         * @this {DomRepeat}\n         * @param {Object} inst Instance to notify\n         * @param {string} prop Property to notify\n         * @param {*} value Value to notify\n         */\n        notifyInstanceProp: function (inst, prop, value) {\n          if (matches(this.as, prop)) {\n            let idx = inst[this.itemsIndexAs];\n            if (prop == this.as) {\n              this.items[idx] = value;\n            }\n            let path = translate(this.as, `${JSCompiler_renameProperty('items', this)}.${idx}`, prop);\n            this.notifyPath(path, value);\n          }\n        }\n      });\n    }\n    return true;\n  }\n  __getMethodHost() {\n    // Technically this should be the owner of the outermost template.\n    // In shadow dom, this is always getRootNode().host, but we can\n    // approximate this via cooperation with our dataHost always setting\n    // `_methodHost` as long as there were bindings (or id's) on this\n    // instance causing it to get a dataHost.\n    return this.__dataHost._methodHost || this.__dataHost;\n  }\n  __functionFromPropertyValue(functionOrMethodName) {\n    if (typeof functionOrMethodName === 'string') {\n      let methodName = functionOrMethodName;\n      let obj = this.__getMethodHost();\n      return function () {\n        return obj[methodName].apply(obj, arguments);\n      };\n    }\n    return functionOrMethodName;\n  }\n  __sortChanged(sort) {\n    this.__sortFn = this.__functionFromPropertyValue(sort);\n    if (this.items) {\n      this.__debounceRender(this.__render);\n    }\n  }\n  __filterChanged(filter) {\n    this.__filterFn = this.__functionFromPropertyValue(filter);\n    if (this.items) {\n      this.__debounceRender(this.__render);\n    }\n  }\n  __computeFrameTime(rate) {\n    return Math.ceil(1000 / rate);\n  }\n  __initializeChunking() {\n    if (this.initialCount) {\n      this.__limit = this.initialCount;\n      this.__chunkCount = this.initialCount;\n      this.__lastChunkTime = performance.now();\n    }\n  }\n  __tryRenderChunk() {\n    // Debounced so that multiple calls through `_render` between animation\n    // frames only queue one new rAF (e.g. array mutation & chunked render)\n    if (this.items && this.__limit < this.items.length) {\n      this.__debounceRender(this.__requestRenderChunk);\n    }\n  }\n  __requestRenderChunk() {\n    requestAnimationFrame(() => this.__renderChunk());\n  }\n  __renderChunk() {\n    // Simple auto chunkSize throttling algorithm based on feedback loop:\n    // measure actual time between frames and scale chunk count by ratio\n    // of target/actual frame time\n    let currChunkTime = performance.now();\n    let ratio = this._targetFrameTime / (currChunkTime - this.__lastChunkTime);\n    this.__chunkCount = Math.round(this.__chunkCount * ratio) || 1;\n    this.__limit += this.__chunkCount;\n    this.__lastChunkTime = currChunkTime;\n    this.__debounceRender(this.__render);\n  }\n  __observeChanged() {\n    this.__observePaths = this.observe && this.observe.replace('.*', '.').split(' ');\n  }\n  __itemsChanged(change) {\n    if (this.items && !Array.isArray(this.items)) {\n      console.warn('dom-repeat expected array for `items`, found', this.items);\n    }\n    // If path was to an item (e.g. 'items.3' or 'items.3.foo'), forward the\n    // path to that instance synchronously (returns false for non-item paths)\n    if (!this.__handleItemPath(change.path, change.value)) {\n      // Otherwise, the array was reset ('items') or spliced ('items.splices'),\n      // so queue a full refresh\n      this.__initializeChunking();\n      this.__debounceRender(this.__render);\n    }\n  }\n  __handleObservedPaths(path) {\n    // Handle cases where path changes should cause a re-sort/filter\n    if (this.__sortFn || this.__filterFn) {\n      if (!path) {\n        // Always re-render if the item itself changed\n        this.__debounceRender(this.__render, this.delay);\n      } else if (this.__observePaths) {\n        // Otherwise, re-render if the path changed matches an observed path\n        let paths = this.__observePaths;\n        for (let i = 0; i < paths.length; i++) {\n          if (path.indexOf(paths[i]) === 0) {\n            this.__debounceRender(this.__render, this.delay);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {function(this:DomRepeat)} fn Function to debounce.\n   * @param {number=} delay Delay in ms to debounce by.\n   */\n  __debounceRender(fn, delay = 0) {\n    this.__renderDebouncer = Debouncer.debounce(this.__renderDebouncer, delay > 0 ? timeOut.after(delay) : microTask, fn.bind(this));\n    enqueueDebouncer(this.__renderDebouncer);\n  }\n\n  /**\n   * Forces the element to render its content. Normally rendering is\n   * asynchronous to a provoking change. This is done for efficiency so\n   * that multiple changes trigger only a single render. The render method\n   * should be called if, for example, template rendering is required to\n   * validate application state.\n   * @return {void}\n   */\n  render() {\n    // Queue this repeater, then flush all in order\n    this.__debounceRender(this.__render);\n    flush();\n  }\n  __render() {\n    if (!this.__ensureTemplatized()) {\n      // No template found yet\n      return;\n    }\n    this.__applyFullRefresh();\n    // Reset the pool\n    // TODO(kschaaf): Reuse pool across turns and nested templates\n    // Now that objects/arrays are re-evaluated when set, we can safely\n    // reuse pooled instances across turns, however we still need to decide\n    // semantics regarding how long to hold, how many to hold, etc.\n    this.__pool.length = 0;\n    // Set rendered item count\n    this._setRenderedItemCount(this.__instances.length);\n    // Notify users\n    this.dispatchEvent(new CustomEvent('dom-change', {\n      bubbles: true,\n      composed: true\n    }));\n    // Check to see if we need to render more items\n    this.__tryRenderChunk();\n  }\n  __applyFullRefresh() {\n    let items = this.items || [];\n    let isntIdxToItemsIdx = new Array(items.length);\n    for (let i = 0; i < items.length; i++) {\n      isntIdxToItemsIdx[i] = i;\n    }\n    // Apply user filter\n    if (this.__filterFn) {\n      isntIdxToItemsIdx = isntIdxToItemsIdx.filter((i, idx, array) => this.__filterFn(items[i], idx, array));\n    }\n    // Apply user sort\n    if (this.__sortFn) {\n      isntIdxToItemsIdx.sort((a, b) => this.__sortFn(items[a], items[b]));\n    }\n    // items->inst map kept for item path forwarding\n    const itemsIdxToInstIdx = this.__itemsIdxToInstIdx = {};\n    let instIdx = 0;\n    // Generate instances and assign items\n    const limit = Math.min(isntIdxToItemsIdx.length, this.__limit);\n    for (; instIdx < limit; instIdx++) {\n      let inst = this.__instances[instIdx];\n      let itemIdx = isntIdxToItemsIdx[instIdx];\n      let item = items[itemIdx];\n      itemsIdxToInstIdx[itemIdx] = instIdx;\n      if (inst) {\n        inst._setPendingProperty(this.as, item);\n        inst._setPendingProperty(this.indexAs, instIdx);\n        inst._setPendingProperty(this.itemsIndexAs, itemIdx);\n        inst._flushProperties();\n      } else {\n        this.__insertInstance(item, instIdx, itemIdx);\n      }\n    }\n    // Remove any extra instances from previous state\n    for (let i = this.__instances.length - 1; i >= instIdx; i--) {\n      this.__detachAndRemoveInstance(i);\n    }\n  }\n  __detachInstance(idx) {\n    let inst = this.__instances[idx];\n    const wrappedRoot = wrap(inst.root);\n    for (let i = 0; i < inst.children.length; i++) {\n      let el = inst.children[i];\n      wrappedRoot.appendChild(el);\n    }\n    return inst;\n  }\n  __attachInstance(idx, parent) {\n    let inst = this.__instances[idx];\n    // Note, this is pre-wrapped as an optimization\n    parent.insertBefore(inst.root, this);\n  }\n  __detachAndRemoveInstance(idx) {\n    let inst = this.__detachInstance(idx);\n    if (inst) {\n      this.__pool.push(inst);\n    }\n    this.__instances.splice(idx, 1);\n  }\n  __stampInstance(item, instIdx, itemIdx) {\n    let model = {};\n    model[this.as] = item;\n    model[this.indexAs] = instIdx;\n    model[this.itemsIndexAs] = itemIdx;\n    return new this.__ctor(model);\n  }\n  __insertInstance(item, instIdx, itemIdx) {\n    let inst = this.__pool.pop();\n    if (inst) {\n      // TODO(kschaaf): If the pool is shared across turns, hostProps\n      // need to be re-set to reused instances in addition to item\n      inst._setPendingProperty(this.as, item);\n      inst._setPendingProperty(this.indexAs, instIdx);\n      inst._setPendingProperty(this.itemsIndexAs, itemIdx);\n      inst._flushProperties();\n    } else {\n      inst = this.__stampInstance(item, instIdx, itemIdx);\n    }\n    let beforeRow = this.__instances[instIdx + 1];\n    let beforeNode = beforeRow ? beforeRow.children[0] : this;\n    wrap(wrap(this).parentNode).insertBefore(inst.root, beforeNode);\n    this.__instances[instIdx] = inst;\n    return inst;\n  }\n\n  // Implements extension point from Templatize mixin\n  /**\n   * Shows or hides the template instance top level child elements. For\n   * text nodes, `textContent` is removed while \"hidden\" and replaced when\n   * \"shown.\"\n   * @param {boolean} hidden Set to true to hide the children;\n   * set to false to show them.\n   * @return {void}\n   * @protected\n   */\n  _showHideChildren(hidden) {\n    for (let i = 0; i < this.__instances.length; i++) {\n      this.__instances[i]._showHideChildren(hidden);\n    }\n  }\n\n  // Called as a side effect of a host items.<key>.<path> path change,\n  // responsible for notifying item.<path> changes to inst for key\n  __handleItemPath(path, value) {\n    let itemsPath = path.slice(6); // 'items.'.length == 6\n    let dot = itemsPath.indexOf('.');\n    let itemsIdx = dot < 0 ? itemsPath : itemsPath.substring(0, dot);\n    // If path was index into array...\n    if (itemsIdx == parseInt(itemsIdx, 10)) {\n      let itemSubPath = dot < 0 ? '' : itemsPath.substring(dot + 1);\n      // If the path is observed, it will trigger a full refresh\n      this.__handleObservedPaths(itemSubPath);\n      // Note, even if a rull refresh is triggered, always do the path\n      // notification because unless mutableData is used for dom-repeat\n      // and all elements in the instance subtree, a full refresh may\n      // not trigger the proper update.\n      let instIdx = this.__itemsIdxToInstIdx[itemsIdx];\n      let inst = this.__instances[instIdx];\n      if (inst) {\n        let itemPath = this.as + (itemSubPath ? '.' + itemSubPath : '');\n        // This is effectively `notifyPath`, but avoids some of the overhead\n        // of the public API\n        inst._setPendingPropertyOrPath(itemPath, value, false, true);\n        inst._flushProperties();\n      }\n      return true;\n    }\n  }\n\n  /**\n   * Returns the item associated with a given element stamped by\n   * this `dom-repeat`.\n   *\n   * Note, to modify sub-properties of the item,\n   * `modelForElement(el).set('item.<sub-prop>', value)`\n   * should be used.\n   *\n   * @param {!HTMLElement} el Element for which to return the item.\n   * @return {*} Item associated with the element.\n   */\n  itemForElement(el) {\n    let instance = this.modelForElement(el);\n    return instance && instance[this.as];\n  }\n\n  /**\n   * Returns the inst index for a given element stamped by this `dom-repeat`.\n   * If `sort` is provided, the index will reflect the sorted order (rather\n   * than the original array order).\n   *\n   * @param {!HTMLElement} el Element for which to return the index.\n   * @return {?number} Row index associated with the element (note this may\n   *   not correspond to the array index if a user `sort` is applied).\n   */\n  indexForElement(el) {\n    let instance = this.modelForElement(el);\n    return instance && instance[this.indexAs];\n  }\n\n  /**\n   * Returns the template \"model\" associated with a given element, which\n   * serves as the binding scope for the template instance the element is\n   * contained in. A template model\n   * should be used to manipulate data associated with this template instance.\n   *\n   * Example:\n   *\n   *   let model = modelForElement(el);\n   *   if (model.index < 10) {\n   *     model.set('item.checked', true);\n   *   }\n   *\n   * @param {!HTMLElement} el Element for which to return a template model.\n   * @return {TemplateInstanceBase} Model representing the binding scope for\n   *   the element.\n   */\n  modelForElement(el) {\n    return modelForElement(this.template, el);\n  }\n}\ncustomElements.define(DomRepeat.is, DomRepeat);","map":{"version":3,"names":["PolymerElement","TemplateInstanceBase","templatize","modelForElement","Debouncer","enqueueDebouncer","flush","OptionalMutableData","matches","translate","timeOut","microTask","wrap","domRepeatBase","DomRepeat","is","template","properties","items","type","Array","as","String","value","indexAs","itemsIndexAs","sort","Function","observer","filter","observe","delay","Number","renderedItemCount","notify","readOnly","initialCount","targetFramerate","_targetFrameTime","computed","observers","constructor","__instances","__limit","Infinity","__pool","__renderDebouncer","__itemsIdxToInstIdx","__chunkCount","__lastChunkTime","__sortFn","__filterFn","__observePaths","__ctor","__isDetached","disconnectedCallback","i","length","__detachInstance","connectedCallback","style","display","wrappedParent","parentNode","__attachInstance","__ensureTemplatized","querySelector","MutationObserver","disconnect","__render","Error","childList","instanceProps","mutableData","parentModel","forwardHostProp","prop","i$","inst","notifyInstanceProp","idx","path","JSCompiler_renameProperty","notifyPath","__getMethodHost","__dataHost","_methodHost","__functionFromPropertyValue","functionOrMethodName","methodName","obj","apply","arguments","__sortChanged","__debounceRender","__filterChanged","__computeFrameTime","rate","Math","ceil","__initializeChunking","performance","now","__tryRenderChunk","__requestRenderChunk","requestAnimationFrame","__renderChunk","currChunkTime","ratio","round","__observeChanged","replace","split","__itemsChanged","change","isArray","console","warn","__handleItemPath","__handleObservedPaths","paths","indexOf","fn","debounce","after","bind","render","__applyFullRefresh","_setRenderedItemCount","dispatchEvent","CustomEvent","bubbles","composed","isntIdxToItemsIdx","array","a","b","itemsIdxToInstIdx","instIdx","limit","min","itemIdx","item","_setPendingProperty","_flushProperties","__insertInstance","__detachAndRemoveInstance","wrappedRoot","root","children","el","appendChild","parent","insertBefore","push","splice","__stampInstance","model","pop","beforeRow","beforeNode","_showHideChildren","hidden","itemsPath","slice","dot","itemsIdx","substring","parseInt","itemSubPath","itemPath","_setPendingPropertyOrPath","itemForElement","instance","indexForElement","customElements","define"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@polymer/polymer/lib/elements/dom-repeat.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport { PolymerElement } from '../../polymer-element.js';\n\nimport { TemplateInstanceBase, templatize, modelForElement } from '../utils/templatize.js'; // eslint-disable-line no-unused-vars\nimport { Debouncer } from '../utils/debounce.js';\nimport { enqueueDebouncer, flush } from '../utils/flush.js';\nimport { OptionalMutableData } from '../mixins/mutable-data.js';\nimport { matches, translate } from '../utils/path.js';\nimport { timeOut, microTask } from '../utils/async.js';\nimport { wrap } from '../utils/wrap.js';\n\n/**\n * @constructor\n * @implements {Polymer_OptionalMutableData}\n * @extends {PolymerElement}\n * @private\n */\nconst domRepeatBase = OptionalMutableData(PolymerElement);\n\n/**\n * The `<dom-repeat>` element will automatically stamp and binds one instance\n * of template content to each object in a user-provided array.\n * `dom-repeat` accepts an `items` property, and one instance of the template\n * is stamped for each item into the DOM at the location of the `dom-repeat`\n * element.  The `item` property will be set on each instance's binding\n * scope, thus templates should bind to sub-properties of `item`.\n *\n * Example:\n *\n * ```html\n * <dom-module id=\"employee-list\">\n *\n *   <template>\n *\n *     <div> Employee list: </div>\n *     <dom-repeat items=\"{{employees}}\">\n *       <template>\n *         <div>First name: <span>{{item.first}}</span></div>\n *         <div>Last name: <span>{{item.last}}</span></div>\n *       </template>\n *     </dom-repeat>\n *\n *   </template>\n *\n * </dom-module>\n * ```\n *\n * With the following custom element definition:\n *\n * ```js\n * class EmployeeList extends PolymerElement {\n *   static get is() { return 'employee-list'; }\n *   static get properties() {\n *     return {\n *       employees: {\n *         value() {\n *           return [\n *             {first: 'Bob', last: 'Smith'},\n *             {first: 'Sally', last: 'Johnson'},\n *             ...\n *           ];\n *         }\n *       }\n *     };\n *   }\n * }\n * ```\n *\n * Notifications for changes to items sub-properties will be forwarded to template\n * instances, which will update via the normal structured data notification system.\n *\n * Mutations to the `items` array itself should be made using the Array\n * mutation API's on the PropertyEffects mixin (`push`, `pop`, `splice`,\n * `shift`, `unshift`), and template instances will be kept in sync with the\n * data in the array.\n *\n * Events caught by event handlers within the `dom-repeat` template will be\n * decorated with a `model` property, which represents the binding scope for\n * each template instance.  The model should be used to manipulate data on the\n * instance, for example `event.model.set('item.checked', true);`.\n *\n * Alternatively, the model for a template instance for an element stamped by\n * a `dom-repeat` can be obtained using the `modelForElement` API on the\n * `dom-repeat` that stamped it, for example\n * `this.$.domRepeat.modelForElement(event.target).set('item.checked', true);`.\n * This may be useful for manipulating instance data of event targets obtained\n * by event handlers on parents of the `dom-repeat` (event delegation).\n *\n * A view-specific filter/sort may be applied to each `dom-repeat` by supplying a\n * `filter` and/or `sort` property.  This may be a string that names a function on\n * the host, or a function may be assigned to the property directly.  The functions\n * should implemented following the standard `Array` filter/sort API.\n *\n * In order to re-run the filter or sort functions based on changes to sub-fields\n * of `items`, the `observe` property may be set as a space-separated list of\n * `item` sub-fields that should cause a re-filter/sort when modified.  If\n * the filter or sort function depends on properties not contained in `items`,\n * the user should observe changes to those properties and call `render` to update\n * the view based on the dependency change.\n *\n * For example, for an `dom-repeat` with a filter of the following:\n *\n * ```js\n * isEngineer(item) {\n *   return item.type == 'engineer' || item.manager.type == 'engineer';\n * }\n * ```\n *\n * Then the `observe` property should be configured as follows:\n *\n * ```html\n * <dom-repeat items=\"{{employees}}\" filter=\"isEngineer\" observe=\"type manager.type\">\n * ```\n *\n * @customElement\n * @polymer\n * @extends {domRepeatBase}\n * @appliesMixin OptionalMutableData\n * @summary Custom element for stamping instance of a template bound to\n *   items in an array.\n */\nexport class DomRepeat extends domRepeatBase {\n\n  // Not needed to find template; can be removed once the analyzer\n  // can find the tag name from customElements.define call\n  static get is() { return 'dom-repeat'; }\n\n  static get template() { return null; }\n\n  static get properties() {\n\n    /**\n     * Fired whenever DOM is added or removed by this template (by\n     * default, rendering occurs lazily).  To force immediate rendering, call\n     * `render`.\n     *\n     * @event dom-change\n     */\n    return {\n\n      /**\n       * An array containing items determining how many instances of the template\n       * to stamp and that that each template instance should bind to.\n       */\n      items: {\n        type: Array\n      },\n\n      /**\n       * The name of the variable to add to the binding scope for the array\n       * element associated with a given template instance.\n       */\n      as: {\n        type: String,\n        value: 'item'\n      },\n\n      /**\n       * The name of the variable to add to the binding scope with the index\n       * of the instance in the sorted and filtered list of rendered items.\n       * Note, for the index in the `this.items` array, use the value of the\n       * `itemsIndexAs` property.\n       */\n      indexAs: {\n        type: String,\n        value: 'index'\n      },\n\n      /**\n       * The name of the variable to add to the binding scope with the index\n       * of the instance in the `this.items` array. Note, for the index of\n       * this instance in the sorted and filtered list of rendered items,\n       * use the value of the `indexAs` property.\n       */\n      itemsIndexAs: {\n        type: String,\n        value: 'itemsIndex'\n      },\n\n      /**\n       * A function that should determine the sort order of the items.  This\n       * property should either be provided as a string, indicating a method\n       * name on the element's host, or else be an actual function.  The\n       * function should match the sort function passed to `Array.sort`.\n       * Using a sort function has no effect on the underlying `items` array.\n       */\n      sort: {\n        type: Function,\n        observer: '__sortChanged'\n      },\n\n      /**\n       * A function that can be used to filter items out of the view.  This\n       * property should either be provided as a string, indicating a method\n       * name on the element's host, or else be an actual function.  The\n       * function should match the sort function passed to `Array.filter`.\n       * Using a filter function has no effect on the underlying `items` array.\n       */\n      filter: {\n        type: Function,\n        observer: '__filterChanged'\n      },\n\n      /**\n       * When using a `filter` or `sort` function, the `observe` property\n       * should be set to a space-separated list of the names of item\n       * sub-fields that should trigger a re-sort or re-filter when changed.\n       * These should generally be fields of `item` that the sort or filter\n       * function depends on.\n       */\n      observe: {\n        type: String,\n        observer: '__observeChanged'\n      },\n\n      /**\n       * When using a `filter` or `sort` function, the `delay` property\n       * determines a debounce time in ms after a change to observed item\n       * properties that must pass before the filter or sort is re-run.\n       * This is useful in rate-limiting shuffling of the view when\n       * item changes may be frequent.\n       */\n      delay: Number,\n\n      /**\n       * Count of currently rendered items after `filter` (if any) has been applied.\n       * If \"chunking mode\" is enabled, `renderedItemCount` is updated each time a\n       * set of template instances is rendered.\n       *\n       */\n      renderedItemCount: {\n        type: Number,\n        notify: true,\n        readOnly: true\n      },\n\n      /**\n       * Defines an initial count of template instances to render after setting\n       * the `items` array, before the next paint, and puts the `dom-repeat`\n       * into \"chunking mode\".  The remaining items will be created and rendered\n       * incrementally at each animation frame therof until all instances have\n       * been rendered.\n       */\n      initialCount: {\n        type: Number,\n        observer: '__initializeChunking'\n      },\n\n      /**\n       * When `initialCount` is used, this property defines a frame rate (in\n       * fps) to target by throttling the number of instances rendered each\n       * frame to not exceed the budget for the target frame rate.  The\n       * framerate is effectively the number of `requestAnimationFrame`s that\n       * it tries to allow to actually fire in a given second. It does this\n       * by measuring the time between `rAF`s and continuously adjusting the\n       * number of items created each `rAF` to maintain the target framerate.\n       * Setting this to a higher number allows lower latency and higher\n       * throughput for event handlers and other tasks, but results in a\n       * longer time for the remaining items to complete rendering.\n       */\n      targetFramerate: {\n        type: Number,\n        value: 20\n      },\n\n      _targetFrameTime: {\n        type: Number,\n        computed: '__computeFrameTime(targetFramerate)'\n      }\n\n    };\n\n  }\n\n  static get observers() {\n    return [ '__itemsChanged(items.*)' ];\n  }\n\n  constructor() {\n    super();\n    this.__instances = [];\n    this.__limit = Infinity;\n    this.__pool = [];\n    this.__renderDebouncer = null;\n    this.__itemsIdxToInstIdx = {};\n    this.__chunkCount = null;\n    this.__lastChunkTime = null;\n    this.__sortFn = null;\n    this.__filterFn = null;\n    this.__observePaths = null;\n    /** @type {?function(new:Polymer.TemplateInstanceBase, *)} */\n    this.__ctor = null;\n    this.__isDetached = true;\n    this.template = null;\n  }\n\n  /**\n   * @override\n   * @return {void}\n   */\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this.__isDetached = true;\n    for (let i=0; i<this.__instances.length; i++) {\n      this.__detachInstance(i);\n    }\n  }\n\n  /**\n   * @override\n   * @return {void}\n   */\n  connectedCallback() {\n    super.connectedCallback();\n    this.style.display = 'none';\n    // only perform attachment if the element was previously detached.\n    if (this.__isDetached) {\n      this.__isDetached = false;\n      let wrappedParent = wrap(wrap(this).parentNode);\n      for (let i=0; i<this.__instances.length; i++) {\n        this.__attachInstance(i, wrappedParent);\n      }\n    }\n  }\n\n  __ensureTemplatized() {\n    // Templatizing (generating the instance constructor) needs to wait\n    // until ready, since won't have its template content handed back to\n    // it until then\n    if (!this.__ctor) {\n      let template = this.template = /** @type {HTMLTemplateElement} */(this.querySelector('template'));\n      if (!template) {\n        // // Wait until childList changes and template should be there by then\n        let observer = new MutationObserver(() => {\n          if (this.querySelector('template')) {\n            observer.disconnect();\n            this.__render();\n          } else {\n            throw new Error('dom-repeat requires a <template> child');\n          }\n        });\n        observer.observe(this, {childList: true});\n        return false;\n      }\n      // Template instance props that should be excluded from forwarding\n      let instanceProps = {};\n      instanceProps[this.as] = true;\n      instanceProps[this.indexAs] = true;\n      instanceProps[this.itemsIndexAs] = true;\n      this.__ctor = templatize(template, this, {\n        mutableData: this.mutableData,\n        parentModel: true,\n        instanceProps: instanceProps,\n        /**\n         * @this {DomRepeat}\n         * @param {string} prop Property to set\n         * @param {*} value Value to set property to\n         */\n        forwardHostProp: function(prop, value) {\n          let i$ = this.__instances;\n          for (let i=0, inst; (i<i$.length) && (inst=i$[i]); i++) {\n            inst.forwardHostProp(prop, value);\n          }\n        },\n        /**\n         * @this {DomRepeat}\n         * @param {Object} inst Instance to notify\n         * @param {string} prop Property to notify\n         * @param {*} value Value to notify\n         */\n        notifyInstanceProp: function(inst, prop, value) {\n          if (matches(this.as, prop)) {\n            let idx = inst[this.itemsIndexAs];\n            if (prop == this.as) {\n              this.items[idx] = value;\n            }\n            let path = translate(this.as, `${JSCompiler_renameProperty('items', this)}.${idx}`, prop);\n            this.notifyPath(path, value);\n          }\n        }\n      });\n    }\n    return true;\n  }\n\n  __getMethodHost() {\n    // Technically this should be the owner of the outermost template.\n    // In shadow dom, this is always getRootNode().host, but we can\n    // approximate this via cooperation with our dataHost always setting\n    // `_methodHost` as long as there were bindings (or id's) on this\n    // instance causing it to get a dataHost.\n    return this.__dataHost._methodHost || this.__dataHost;\n  }\n\n  __functionFromPropertyValue(functionOrMethodName) {\n    if (typeof functionOrMethodName === 'string') {\n      let methodName = functionOrMethodName;\n      let obj = this.__getMethodHost();\n      return function() { return obj[methodName].apply(obj, arguments); };\n    }\n\n    return functionOrMethodName;\n  }\n\n  __sortChanged(sort) {\n    this.__sortFn = this.__functionFromPropertyValue(sort);\n    if (this.items) { this.__debounceRender(this.__render); }\n  }\n\n  __filterChanged(filter) {\n    this.__filterFn = this.__functionFromPropertyValue(filter);\n    if (this.items) { this.__debounceRender(this.__render); }\n  }\n\n  __computeFrameTime(rate) {\n    return Math.ceil(1000/rate);\n  }\n\n  __initializeChunking() {\n    if (this.initialCount) {\n      this.__limit = this.initialCount;\n      this.__chunkCount = this.initialCount;\n      this.__lastChunkTime = performance.now();\n    }\n  }\n\n  __tryRenderChunk() {\n    // Debounced so that multiple calls through `_render` between animation\n    // frames only queue one new rAF (e.g. array mutation & chunked render)\n    if (this.items && this.__limit < this.items.length) {\n      this.__debounceRender(this.__requestRenderChunk);\n    }\n  }\n\n  __requestRenderChunk() {\n    requestAnimationFrame(()=>this.__renderChunk());\n  }\n\n  __renderChunk() {\n    // Simple auto chunkSize throttling algorithm based on feedback loop:\n    // measure actual time between frames and scale chunk count by ratio\n    // of target/actual frame time\n    let currChunkTime = performance.now();\n    let ratio = this._targetFrameTime / (currChunkTime - this.__lastChunkTime);\n    this.__chunkCount = Math.round(this.__chunkCount * ratio) || 1;\n    this.__limit += this.__chunkCount;\n    this.__lastChunkTime = currChunkTime;\n    this.__debounceRender(this.__render);\n  }\n\n  __observeChanged() {\n    this.__observePaths = this.observe &&\n      this.observe.replace('.*', '.').split(' ');\n  }\n\n  __itemsChanged(change) {\n    if (this.items && !Array.isArray(this.items)) {\n      console.warn('dom-repeat expected array for `items`, found', this.items);\n    }\n    // If path was to an item (e.g. 'items.3' or 'items.3.foo'), forward the\n    // path to that instance synchronously (returns false for non-item paths)\n    if (!this.__handleItemPath(change.path, change.value)) {\n      // Otherwise, the array was reset ('items') or spliced ('items.splices'),\n      // so queue a full refresh\n      this.__initializeChunking();\n      this.__debounceRender(this.__render);\n    }\n  }\n\n  __handleObservedPaths(path) {\n    // Handle cases where path changes should cause a re-sort/filter\n    if (this.__sortFn || this.__filterFn) {\n      if (!path) {\n        // Always re-render if the item itself changed\n        this.__debounceRender(this.__render, this.delay);\n      } else if (this.__observePaths) {\n        // Otherwise, re-render if the path changed matches an observed path\n        let paths = this.__observePaths;\n        for (let i=0; i<paths.length; i++) {\n          if (path.indexOf(paths[i]) === 0) {\n            this.__debounceRender(this.__render, this.delay);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {function(this:DomRepeat)} fn Function to debounce.\n   * @param {number=} delay Delay in ms to debounce by.\n   */\n  __debounceRender(fn, delay = 0) {\n    this.__renderDebouncer = Debouncer.debounce(\n          this.__renderDebouncer\n        , delay > 0 ? timeOut.after(delay) : microTask\n        , fn.bind(this));\n    enqueueDebouncer(this.__renderDebouncer);\n  }\n\n  /**\n   * Forces the element to render its content. Normally rendering is\n   * asynchronous to a provoking change. This is done for efficiency so\n   * that multiple changes trigger only a single render. The render method\n   * should be called if, for example, template rendering is required to\n   * validate application state.\n   * @return {void}\n   */\n  render() {\n    // Queue this repeater, then flush all in order\n    this.__debounceRender(this.__render);\n    flush();\n  }\n\n  __render() {\n    if (!this.__ensureTemplatized()) {\n      // No template found yet\n      return;\n    }\n    this.__applyFullRefresh();\n    // Reset the pool\n    // TODO(kschaaf): Reuse pool across turns and nested templates\n    // Now that objects/arrays are re-evaluated when set, we can safely\n    // reuse pooled instances across turns, however we still need to decide\n    // semantics regarding how long to hold, how many to hold, etc.\n    this.__pool.length = 0;\n    // Set rendered item count\n    this._setRenderedItemCount(this.__instances.length);\n    // Notify users\n    this.dispatchEvent(new CustomEvent('dom-change', {\n      bubbles: true,\n      composed: true\n    }));\n    // Check to see if we need to render more items\n    this.__tryRenderChunk();\n  }\n\n  __applyFullRefresh() {\n    let items = this.items || [];\n    let isntIdxToItemsIdx = new Array(items.length);\n    for (let i=0; i<items.length; i++) {\n      isntIdxToItemsIdx[i] = i;\n    }\n    // Apply user filter\n    if (this.__filterFn) {\n      isntIdxToItemsIdx = isntIdxToItemsIdx.filter((i, idx, array) =>\n        this.__filterFn(items[i], idx, array));\n    }\n    // Apply user sort\n    if (this.__sortFn) {\n      isntIdxToItemsIdx.sort((a, b) => this.__sortFn(items[a], items[b]));\n    }\n    // items->inst map kept for item path forwarding\n    const itemsIdxToInstIdx = this.__itemsIdxToInstIdx = {};\n    let instIdx = 0;\n    // Generate instances and assign items\n    const limit = Math.min(isntIdxToItemsIdx.length, this.__limit);\n    for (; instIdx<limit; instIdx++) {\n      let inst = this.__instances[instIdx];\n      let itemIdx = isntIdxToItemsIdx[instIdx];\n      let item = items[itemIdx];\n      itemsIdxToInstIdx[itemIdx] = instIdx;\n      if (inst) {\n        inst._setPendingProperty(this.as, item);\n        inst._setPendingProperty(this.indexAs, instIdx);\n        inst._setPendingProperty(this.itemsIndexAs, itemIdx);\n        inst._flushProperties();\n      } else {\n        this.__insertInstance(item, instIdx, itemIdx);\n      }\n    }\n    // Remove any extra instances from previous state\n    for (let i=this.__instances.length-1; i>=instIdx; i--) {\n      this.__detachAndRemoveInstance(i);\n    }\n  }\n\n  __detachInstance(idx) {\n    let inst = this.__instances[idx];\n    const wrappedRoot = wrap(inst.root);\n    for (let i=0; i<inst.children.length; i++) {\n      let el = inst.children[i];\n      wrappedRoot.appendChild(el);\n    }\n    return inst;\n  }\n\n  __attachInstance(idx, parent) {\n    let inst = this.__instances[idx];\n    // Note, this is pre-wrapped as an optimization\n    parent.insertBefore(inst.root, this);\n  }\n\n  __detachAndRemoveInstance(idx) {\n    let inst = this.__detachInstance(idx);\n    if (inst) {\n      this.__pool.push(inst);\n    }\n    this.__instances.splice(idx, 1);\n  }\n\n  __stampInstance(item, instIdx, itemIdx) {\n    let model = {};\n    model[this.as] = item;\n    model[this.indexAs] = instIdx;\n    model[this.itemsIndexAs] = itemIdx;\n    return new this.__ctor(model);\n  }\n\n  __insertInstance(item, instIdx, itemIdx) {\n    let inst = this.__pool.pop();\n    if (inst) {\n      // TODO(kschaaf): If the pool is shared across turns, hostProps\n      // need to be re-set to reused instances in addition to item\n      inst._setPendingProperty(this.as, item);\n      inst._setPendingProperty(this.indexAs, instIdx);\n      inst._setPendingProperty(this.itemsIndexAs, itemIdx);\n      inst._flushProperties();\n    } else {\n      inst = this.__stampInstance(item, instIdx, itemIdx);\n    }\n    let beforeRow = this.__instances[instIdx + 1];\n    let beforeNode = beforeRow ? beforeRow.children[0] : this;\n    wrap(wrap(this).parentNode).insertBefore(inst.root, beforeNode);\n    this.__instances[instIdx] = inst;\n    return inst;\n  }\n\n  // Implements extension point from Templatize mixin\n  /**\n   * Shows or hides the template instance top level child elements. For\n   * text nodes, `textContent` is removed while \"hidden\" and replaced when\n   * \"shown.\"\n   * @param {boolean} hidden Set to true to hide the children;\n   * set to false to show them.\n   * @return {void}\n   * @protected\n   */\n  _showHideChildren(hidden) {\n    for (let i=0; i<this.__instances.length; i++) {\n      this.__instances[i]._showHideChildren(hidden);\n    }\n  }\n\n  // Called as a side effect of a host items.<key>.<path> path change,\n  // responsible for notifying item.<path> changes to inst for key\n  __handleItemPath(path, value) {\n    let itemsPath = path.slice(6); // 'items.'.length == 6\n    let dot = itemsPath.indexOf('.');\n    let itemsIdx = dot < 0 ? itemsPath : itemsPath.substring(0, dot);\n    // If path was index into array...\n    if (itemsIdx == parseInt(itemsIdx, 10)) {\n      let itemSubPath = dot < 0 ? '' : itemsPath.substring(dot+1);\n      // If the path is observed, it will trigger a full refresh\n      this.__handleObservedPaths(itemSubPath);\n      // Note, even if a rull refresh is triggered, always do the path\n      // notification because unless mutableData is used for dom-repeat\n      // and all elements in the instance subtree, a full refresh may\n      // not trigger the proper update.\n      let instIdx = this.__itemsIdxToInstIdx[itemsIdx];\n      let inst = this.__instances[instIdx];\n      if (inst) {\n        let itemPath = this.as + (itemSubPath ? '.' + itemSubPath : '');\n        // This is effectively `notifyPath`, but avoids some of the overhead\n        // of the public API\n        inst._setPendingPropertyOrPath(itemPath, value, false, true);\n        inst._flushProperties();\n      }\n      return true;\n    }\n  }\n\n  /**\n   * Returns the item associated with a given element stamped by\n   * this `dom-repeat`.\n   *\n   * Note, to modify sub-properties of the item,\n   * `modelForElement(el).set('item.<sub-prop>', value)`\n   * should be used.\n   *\n   * @param {!HTMLElement} el Element for which to return the item.\n   * @return {*} Item associated with the element.\n   */\n  itemForElement(el) {\n    let instance = this.modelForElement(el);\n    return instance && instance[this.as];\n  }\n\n  /**\n   * Returns the inst index for a given element stamped by this `dom-repeat`.\n   * If `sort` is provided, the index will reflect the sorted order (rather\n   * than the original array order).\n   *\n   * @param {!HTMLElement} el Element for which to return the index.\n   * @return {?number} Row index associated with the element (note this may\n   *   not correspond to the array index if a user `sort` is applied).\n   */\n  indexForElement(el) {\n    let instance = this.modelForElement(el);\n    return instance && instance[this.indexAs];\n  }\n\n  /**\n   * Returns the template \"model\" associated with a given element, which\n   * serves as the binding scope for the template instance the element is\n   * contained in. A template model\n   * should be used to manipulate data associated with this template instance.\n   *\n   * Example:\n   *\n   *   let model = modelForElement(el);\n   *   if (model.index < 10) {\n   *     model.set('item.checked', true);\n   *   }\n   *\n   * @param {!HTMLElement} el Element for which to return a template model.\n   * @return {TemplateInstanceBase} Model representing the binding scope for\n   *   the element.\n   */\n  modelForElement(el) {\n    return modelForElement(this.template, el);\n  }\n\n}\n\ncustomElements.define(DomRepeat.is, DomRepeat);\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,cAAc,QAAQ,0BAA0B;AAEzD,SAASC,oBAAoB,EAAEC,UAAU,EAAEC,eAAe,QAAQ,wBAAwB,CAAC,CAAC;AAC5F,SAASC,SAAS,QAAQ,sBAAsB;AAChD,SAASC,gBAAgB,EAAEC,KAAK,QAAQ,mBAAmB;AAC3D,SAASC,mBAAmB,QAAQ,2BAA2B;AAC/D,SAASC,OAAO,EAAEC,SAAS,QAAQ,kBAAkB;AACrD,SAASC,OAAO,EAAEC,SAAS,QAAQ,mBAAmB;AACtD,SAASC,IAAI,QAAQ,kBAAkB;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,aAAa,GAAGN,mBAAmB,CAACP,cAAc,CAAC;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMc,SAAS,SAASD,aAAa,CAAC;EAE3C;EACA;EACA,WAAWE,EAAEA,CAAA,EAAG;IAAE,OAAO,YAAY;EAAE;EAEvC,WAAWC,QAAQA,CAAA,EAAG;IAAE,OAAO,IAAI;EAAE;EAErC,WAAWC,UAAUA,CAAA,EAAG;IAEtB;AACJ;AACA;AACA;AACA;AACA;AACA;IACI,OAAO;MAEL;AACN;AACA;AACA;MACMC,KAAK,EAAE;QACLC,IAAI,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"},"metadata":{},"sourceType":"module","externalDependencies":[]}