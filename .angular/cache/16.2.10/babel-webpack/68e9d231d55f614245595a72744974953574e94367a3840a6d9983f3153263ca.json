{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2016 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { iterateChildren, iterateRowCells, updatePart } from './vaadin-grid-helpers.js';\n\n/**\n * @polymerMixin\n */\nexport const StylingMixin = superClass => class StylingMixin extends superClass {\n  static get properties() {\n    return {\n      /**\n       * A function that allows generating CSS class names for grid cells\n       * based on their row and column. The return value should be the generated\n       * class name as a string, or multiple class names separated by whitespace\n       * characters.\n       *\n       * Receives two arguments:\n       * - `column` The `<vaadin-grid-column>` element (`undefined` for details-cell).\n       * - `model` The object with the properties related with\n       *   the rendered item, contains:\n       *   - `model.index` The index of the item.\n       *   - `model.item` The item.\n       *   - `model.expanded` Sublevel toggle state.\n       *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.\n       *   - `model.selected` Selected state.\n       *\n       * @type {GridCellClassNameGenerator | null | undefined}\n       * @deprecated Use `cellPartNameGenerator` instead.\n       */\n      cellClassNameGenerator: Function,\n      /**\n       * A function that allows generating CSS `part` names for grid cells in Shadow DOM based\n       * on their row and column, for styling from outside using the `::part()` selector.\n       *\n       * The return value should be the generated part name as a string, or multiple part names\n       * separated by whitespace characters.\n       *\n       * Receives two arguments:\n       * - `column` The `<vaadin-grid-column>` element (`undefined` for details-cell).\n       * - `model` The object with the properties related with\n       *   the rendered item, contains:\n       *   - `model.index` The index of the item.\n       *   - `model.item` The item.\n       *   - `model.expanded` Sublevel toggle state.\n       *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.\n       *   - `model.selected` Selected state.\n       *\n       * @type {GridCellPartNameGenerator | null | undefined}\n       */\n      cellPartNameGenerator: Function\n    };\n  }\n  static get observers() {\n    return ['__cellClassNameGeneratorChanged(cellClassNameGenerator)', '__cellPartNameGeneratorChanged(cellPartNameGenerator)'];\n  }\n\n  /** @private */\n  __cellClassNameGeneratorChanged() {\n    this.generateCellClassNames();\n  }\n\n  /** @private */\n  __cellPartNameGeneratorChanged() {\n    this.generateCellPartNames();\n  }\n\n  /**\n   * Runs the `cellClassNameGenerator` for the visible cells.\n   * If the generator depends on varying conditions, you need to\n   * call this function manually in order to update the styles when\n   * the conditions change.\n   *\n   * @deprecated Use `cellPartNameGenerator` and `generateCellPartNames()` instead.\n   */\n  generateCellClassNames() {\n    iterateChildren(this.$.items, row => {\n      if (!row.hidden && !row.hasAttribute('loading')) {\n        this._generateCellClassNames(row, this.__getRowModel(row));\n      }\n    });\n  }\n\n  /**\n   * Runs the `cellPartNameGenerator` for the visible cells.\n   * If the generator depends on varying conditions, you need to\n   * call this function manually in order to update the styles when\n   * the conditions change.\n   */\n  generateCellPartNames() {\n    iterateChildren(this.$.items, row => {\n      if (!row.hidden && !row.hasAttribute('loading')) {\n        this._generateCellPartNames(row, this.__getRowModel(row));\n      }\n    });\n  }\n\n  /** @private */\n  _generateCellClassNames(row, model) {\n    iterateRowCells(row, cell => {\n      if (cell.__generatedClasses) {\n        cell.__generatedClasses.forEach(className => cell.classList.remove(className));\n      }\n      if (this.cellClassNameGenerator) {\n        const result = this.cellClassNameGenerator(cell._column, model);\n        cell.__generatedClasses = result && result.split(' ').filter(className => className.length > 0);\n        if (cell.__generatedClasses) {\n          cell.__generatedClasses.forEach(className => cell.classList.add(className));\n        }\n      }\n    });\n  }\n\n  /** @private */\n  _generateCellPartNames(row, model) {\n    iterateRowCells(row, cell => {\n      if (cell.__generatedParts) {\n        cell.__generatedParts.forEach(partName => {\n          // Remove previously generated part names\n          updatePart(cell, null, partName);\n        });\n      }\n      if (this.cellPartNameGenerator) {\n        const result = this.cellPartNameGenerator(cell._column, model);\n        cell.__generatedParts = result && result.split(' ').filter(partName => partName.length > 0);\n        if (cell.__generatedParts) {\n          cell.__generatedParts.forEach(partName => {\n            // Add the newly generated names to part\n            updatePart(cell, true, partName);\n          });\n        }\n      }\n    });\n  }\n};","map":{"version":3,"names":["iterateChildren","iterateRowCells","updatePart","StylingMixin","superClass","properties","cellClassNameGenerator","Function","cellPartNameGenerator","observers","__cellClassNameGeneratorChanged","generateCellClassNames","__cellPartNameGeneratorChanged","generateCellPartNames","$","items","row","hidden","hasAttribute","_generateCellClassNames","__getRowModel","_generateCellPartNames","model","cell","__generatedClasses","forEach","className","classList","remove","result","_column","split","filter","length","add","__generatedParts","partName"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@vaadin/grid/src/vaadin-grid-styling-mixin.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2016 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { iterateChildren, iterateRowCells, updatePart } from './vaadin-grid-helpers.js';\n\n/**\n * @polymerMixin\n */\nexport const StylingMixin = (superClass) =>\n  class StylingMixin extends superClass {\n    static get properties() {\n      return {\n        /**\n         * A function that allows generating CSS class names for grid cells\n         * based on their row and column. The return value should be the generated\n         * class name as a string, or multiple class names separated by whitespace\n         * characters.\n         *\n         * Receives two arguments:\n         * - `column` The `<vaadin-grid-column>` element (`undefined` for details-cell).\n         * - `model` The object with the properties related with\n         *   the rendered item, contains:\n         *   - `model.index` The index of the item.\n         *   - `model.item` The item.\n         *   - `model.expanded` Sublevel toggle state.\n         *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.\n         *   - `model.selected` Selected state.\n         *\n         * @type {GridCellClassNameGenerator | null | undefined}\n         * @deprecated Use `cellPartNameGenerator` instead.\n         */\n        cellClassNameGenerator: Function,\n\n        /**\n         * A function that allows generating CSS `part` names for grid cells in Shadow DOM based\n         * on their row and column, for styling from outside using the `::part()` selector.\n         *\n         * The return value should be the generated part name as a string, or multiple part names\n         * separated by whitespace characters.\n         *\n         * Receives two arguments:\n         * - `column` The `<vaadin-grid-column>` element (`undefined` for details-cell).\n         * - `model` The object with the properties related with\n         *   the rendered item, contains:\n         *   - `model.index` The index of the item.\n         *   - `model.item` The item.\n         *   - `model.expanded` Sublevel toggle state.\n         *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.\n         *   - `model.selected` Selected state.\n         *\n         * @type {GridCellPartNameGenerator | null | undefined}\n         */\n        cellPartNameGenerator: Function,\n      };\n    }\n\n    static get observers() {\n      return [\n        '__cellClassNameGeneratorChanged(cellClassNameGenerator)',\n        '__cellPartNameGeneratorChanged(cellPartNameGenerator)',\n      ];\n    }\n\n    /** @private */\n    __cellClassNameGeneratorChanged() {\n      this.generateCellClassNames();\n    }\n\n    /** @private */\n    __cellPartNameGeneratorChanged() {\n      this.generateCellPartNames();\n    }\n\n    /**\n     * Runs the `cellClassNameGenerator` for the visible cells.\n     * If the generator depends on varying conditions, you need to\n     * call this function manually in order to update the styles when\n     * the conditions change.\n     *\n     * @deprecated Use `cellPartNameGenerator` and `generateCellPartNames()` instead.\n     */\n    generateCellClassNames() {\n      iterateChildren(this.$.items, (row) => {\n        if (!row.hidden && !row.hasAttribute('loading')) {\n          this._generateCellClassNames(row, this.__getRowModel(row));\n        }\n      });\n    }\n\n    /**\n     * Runs the `cellPartNameGenerator` for the visible cells.\n     * If the generator depends on varying conditions, you need to\n     * call this function manually in order to update the styles when\n     * the conditions change.\n     */\n    generateCellPartNames() {\n      iterateChildren(this.$.items, (row) => {\n        if (!row.hidden && !row.hasAttribute('loading')) {\n          this._generateCellPartNames(row, this.__getRowModel(row));\n        }\n      });\n    }\n\n    /** @private */\n    _generateCellClassNames(row, model) {\n      iterateRowCells(row, (cell) => {\n        if (cell.__generatedClasses) {\n          cell.__generatedClasses.forEach((className) => cell.classList.remove(className));\n        }\n        if (this.cellClassNameGenerator) {\n          const result = this.cellClassNameGenerator(cell._column, model);\n          cell.__generatedClasses = result && result.split(' ').filter((className) => className.length > 0);\n          if (cell.__generatedClasses) {\n            cell.__generatedClasses.forEach((className) => cell.classList.add(className));\n          }\n        }\n      });\n    }\n\n    /** @private */\n    _generateCellPartNames(row, model) {\n      iterateRowCells(row, (cell) => {\n        if (cell.__generatedParts) {\n          cell.__generatedParts.forEach((partName) => {\n            // Remove previously generated part names\n            updatePart(cell, null, partName);\n          });\n        }\n        if (this.cellPartNameGenerator) {\n          const result = this.cellPartNameGenerator(cell._column, model);\n          cell.__generatedParts = result && result.split(' ').filter((partName) => partName.length > 0);\n          if (cell.__generatedParts) {\n            cell.__generatedParts.forEach((partName) => {\n              // Add the newly generated names to part\n              updatePart(cell, true, partName);\n            });\n          }\n        }\n      });\n    }\n  };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}