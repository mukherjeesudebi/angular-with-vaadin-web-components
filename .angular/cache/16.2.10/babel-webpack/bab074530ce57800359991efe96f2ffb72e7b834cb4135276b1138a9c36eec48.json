{"ast":null,"code":"/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport { PolymerElement } from '../../polymer-element.js';\nimport { templatize } from '../utils/templatize.js';\nimport { Debouncer } from '../utils/debounce.js';\nimport { enqueueDebouncer, flush } from '../utils/flush.js';\nimport { microTask } from '../utils/async.js';\nimport { root } from '../utils/path.js';\nimport { wrap } from '../utils/wrap.js';\n\n/**\n * The `<dom-if>` element will stamp a light-dom `<template>` child when\n * the `if` property becomes truthy, and the template can use Polymer\n * data-binding and declarative event features when used in the context of\n * a Polymer element's template.\n *\n * When `if` becomes falsy, the stamped content is hidden but not\n * removed from dom. When `if` subsequently becomes truthy again, the content\n * is simply re-shown. This approach is used due to its favorable performance\n * characteristics: the expense of creating template content is paid only\n * once and lazily.\n *\n * Set the `restamp` property to true to force the stamped content to be\n * created / destroyed when the `if` condition changes.\n *\n * @customElement\n * @polymer\n * @extends PolymerElement\n * @summary Custom element that conditionally stamps and hides or removes\n *   template content based on a boolean flag.\n */\nexport class DomIf extends PolymerElement {\n  // Not needed to find template; can be removed once the analyzer\n  // can find the tag name from customElements.define call\n  static get is() {\n    return 'dom-if';\n  }\n  static get template() {\n    return null;\n  }\n  static get properties() {\n    return {\n      /**\n       * Fired whenever DOM is added or removed/hidden by this template (by\n       * default, rendering occurs lazily).  To force immediate rendering, call\n       * `render`.\n       *\n       * @event dom-change\n       */\n\n      /**\n       * A boolean indicating whether this template should stamp.\n       */\n      if: {\n        type: Boolean,\n        observer: '__debounceRender'\n      },\n      /**\n       * When true, elements will be removed from DOM and discarded when `if`\n       * becomes false and re-created and added back to the DOM when `if`\n       * becomes true.  By default, stamped elements will be hidden but left\n       * in the DOM when `if` becomes false, which is generally results\n       * in better performance.\n       */\n      restamp: {\n        type: Boolean,\n        observer: '__debounceRender'\n      }\n    };\n  }\n  constructor() {\n    super();\n    this.__renderDebouncer = null;\n    this.__invalidProps = null;\n    this.__instance = null;\n    this._lastIf = false;\n    this.__ctor = null;\n    this.__hideTemplateChildren__ = false;\n  }\n  __debounceRender() {\n    // Render is async for 2 reasons:\n    // 1. To eliminate dom creation trashing if user code thrashes `if` in the\n    //    same turn. This was more common in 1.x where a compound computed\n    //    property could result in the result changing multiple times, but is\n    //    mitigated to a large extent by batched property processing in 2.x.\n    // 2. To avoid double object propagation when a bag including values bound\n    //    to the `if` property as well as one or more hostProps could enqueue\n    //    the <dom-if> to flush before the <template>'s host property\n    //    forwarding. In that scenario creating an instance would result in\n    //    the host props being set once, and then the enqueued changes on the\n    //    template would set properties a second time, potentially causing an\n    //    object to be set to an instance more than once.  Creating the\n    //    instance async from flushing data ensures this doesn't happen. If\n    //    we wanted a sync option in the future, simply having <dom-if> flush\n    //    (or clear) its template's pending host properties before creating\n    //    the instance would also avoid the problem.\n    this.__renderDebouncer = Debouncer.debounce(this.__renderDebouncer, microTask, () => this.__render());\n    enqueueDebouncer(this.__renderDebouncer);\n  }\n\n  /**\n   * @override\n   * @return {void}\n   */\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    const parent = wrap(this).parentNode;\n    if (!parent || parent.nodeType == Node.DOCUMENT_FRAGMENT_NODE && !wrap(parent).host) {\n      this.__teardownInstance();\n    }\n  }\n\n  /**\n   * @override\n   * @return {void}\n   */\n  connectedCallback() {\n    super.connectedCallback();\n    this.style.display = 'none';\n    if (this.if) {\n      this.__debounceRender();\n    }\n  }\n\n  /**\n   * Forces the element to render its content. Normally rendering is\n   * asynchronous to a provoking change. This is done for efficiency so\n   * that multiple changes trigger only a single render. The render method\n   * should be called if, for example, template rendering is required to\n   * validate application state.\n   * @return {void}\n   */\n  render() {\n    flush();\n  }\n  __render() {\n    if (this.if) {\n      if (!this.__ensureInstance()) {\n        // No template found yet\n        return;\n      }\n      this._showHideChildren();\n    } else if (this.restamp) {\n      this.__teardownInstance();\n    }\n    if (!this.restamp && this.__instance) {\n      this._showHideChildren();\n    }\n    if (this.if != this._lastIf) {\n      this.dispatchEvent(new CustomEvent('dom-change', {\n        bubbles: true,\n        composed: true\n      }));\n      this._lastIf = this.if;\n    }\n  }\n  __ensureInstance() {\n    let parentNode = wrap(this).parentNode;\n    // Guard against element being detached while render was queued\n    if (parentNode) {\n      if (!this.__ctor) {\n        let template = /** @type {HTMLTemplateElement} */wrap(this).querySelector('template');\n        if (!template) {\n          // Wait until childList changes and template should be there by then\n          let observer = new MutationObserver(() => {\n            if (wrap(this).querySelector('template')) {\n              observer.disconnect();\n              this.__render();\n            } else {\n              throw new Error('dom-if requires a <template> child');\n            }\n          });\n          observer.observe(this, {\n            childList: true\n          });\n          return false;\n        }\n        this.__ctor = templatize(template, this, {\n          // dom-if templatizer instances require `mutable: true`, as\n          // `__syncHostProperties` relies on that behavior to sync objects\n          mutableData: true,\n          /**\n           * @param {string} prop Property to forward\n           * @param {*} value Value of property\n           * @this {DomIf}\n           */\n          forwardHostProp: function (prop, value) {\n            if (this.__instance) {\n              if (this.if) {\n                this.__instance.forwardHostProp(prop, value);\n              } else {\n                // If we have an instance but are squelching host property\n                // forwarding due to if being false, note the invalidated\n                // properties so `__syncHostProperties` can sync them the next\n                // time `if` becomes true\n                this.__invalidProps = this.__invalidProps || Object.create(null);\n                this.__invalidProps[root(prop)] = true;\n              }\n            }\n          }\n        });\n      }\n      if (!this.__instance) {\n        this.__instance = new this.__ctor();\n        wrap(parentNode).insertBefore(this.__instance.root, this);\n      } else {\n        this.__syncHostProperties();\n        let c$ = this.__instance.children;\n        if (c$ && c$.length) {\n          // Detect case where dom-if was re-attached in new position\n          let lastChild = wrap(this).previousSibling;\n          if (lastChild !== c$[c$.length - 1]) {\n            for (let i = 0, n; i < c$.length && (n = c$[i]); i++) {\n              wrap(parentNode).insertBefore(n, this);\n            }\n          }\n        }\n      }\n    }\n    return true;\n  }\n  __syncHostProperties() {\n    let props = this.__invalidProps;\n    if (props) {\n      for (let prop in props) {\n        this.__instance._setPendingProperty(prop, this.__dataHost[prop]);\n      }\n      this.__invalidProps = null;\n      this.__instance._flushProperties();\n    }\n  }\n  __teardownInstance() {\n    if (this.__instance) {\n      let c$ = this.__instance.children;\n      if (c$ && c$.length) {\n        // use first child parent, for case when dom-if may have been detached\n        let parent = wrap(c$[0]).parentNode;\n        // Instance children may be disconnected from parents when dom-if\n        // detaches if a tree was innerHTML'ed\n        if (parent) {\n          parent = wrap(parent);\n          for (let i = 0, n; i < c$.length && (n = c$[i]); i++) {\n            parent.removeChild(n);\n          }\n        }\n      }\n      this.__instance = null;\n      this.__invalidProps = null;\n    }\n  }\n\n  /**\n   * Shows or hides the template instance top level child elements. For\n   * text nodes, `textContent` is removed while \"hidden\" and replaced when\n   * \"shown.\"\n   * @return {void}\n   * @protected\n   * @suppress {visibility}\n   */\n  _showHideChildren() {\n    let hidden = this.__hideTemplateChildren__ || !this.if;\n    if (this.__instance) {\n      this.__instance._showHideChildren(hidden);\n    }\n  }\n}\ncustomElements.define(DomIf.is, DomIf);","map":{"version":3,"names":["PolymerElement","templatize","Debouncer","enqueueDebouncer","flush","microTask","root","wrap","DomIf","is","template","properties","if","type","Boolean","observer","restamp","constructor","__renderDebouncer","__invalidProps","__instance","_lastIf","__ctor","__hideTemplateChildren__","__debounceRender","debounce","__render","disconnectedCallback","parent","parentNode","nodeType","Node","DOCUMENT_FRAGMENT_NODE","host","__teardownInstance","connectedCallback","style","display","render","__ensureInstance","_showHideChildren","dispatchEvent","CustomEvent","bubbles","composed","querySelector","MutationObserver","disconnect","Error","observe","childList","mutableData","forwardHostProp","prop","value","Object","create","insertBefore","__syncHostProperties","c$","children","length","lastChild","previousSibling","i","n","props","_setPendingProperty","__dataHost","_flushProperties","removeChild","hidden","customElements","define"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@polymer/polymer/lib/elements/dom-if.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport { PolymerElement } from '../../polymer-element.js';\n\nimport { templatize } from '../utils/templatize.js';\nimport { Debouncer } from '../utils/debounce.js';\nimport { enqueueDebouncer, flush } from '../utils/flush.js';\nimport { microTask } from '../utils/async.js';\nimport { root } from '../utils/path.js';\nimport { wrap } from '../utils/wrap.js';\n\n/**\n * The `<dom-if>` element will stamp a light-dom `<template>` child when\n * the `if` property becomes truthy, and the template can use Polymer\n * data-binding and declarative event features when used in the context of\n * a Polymer element's template.\n *\n * When `if` becomes falsy, the stamped content is hidden but not\n * removed from dom. When `if` subsequently becomes truthy again, the content\n * is simply re-shown. This approach is used due to its favorable performance\n * characteristics: the expense of creating template content is paid only\n * once and lazily.\n *\n * Set the `restamp` property to true to force the stamped content to be\n * created / destroyed when the `if` condition changes.\n *\n * @customElement\n * @polymer\n * @extends PolymerElement\n * @summary Custom element that conditionally stamps and hides or removes\n *   template content based on a boolean flag.\n */\nexport class DomIf extends PolymerElement {\n\n  // Not needed to find template; can be removed once the analyzer\n  // can find the tag name from customElements.define call\n  static get is() { return 'dom-if'; }\n\n  static get template() { return null; }\n\n  static get properties() {\n\n    return {\n\n      /**\n       * Fired whenever DOM is added or removed/hidden by this template (by\n       * default, rendering occurs lazily).  To force immediate rendering, call\n       * `render`.\n       *\n       * @event dom-change\n       */\n\n      /**\n       * A boolean indicating whether this template should stamp.\n       */\n      if: {\n        type: Boolean,\n        observer: '__debounceRender'\n      },\n\n      /**\n       * When true, elements will be removed from DOM and discarded when `if`\n       * becomes false and re-created and added back to the DOM when `if`\n       * becomes true.  By default, stamped elements will be hidden but left\n       * in the DOM when `if` becomes false, which is generally results\n       * in better performance.\n       */\n      restamp: {\n        type: Boolean,\n        observer: '__debounceRender'\n      }\n\n    };\n\n  }\n\n  constructor() {\n    super();\n    this.__renderDebouncer = null;\n    this.__invalidProps = null;\n    this.__instance = null;\n    this._lastIf = false;\n    this.__ctor = null;\n    this.__hideTemplateChildren__ = false;\n  }\n\n  __debounceRender() {\n    // Render is async for 2 reasons:\n    // 1. To eliminate dom creation trashing if user code thrashes `if` in the\n    //    same turn. This was more common in 1.x where a compound computed\n    //    property could result in the result changing multiple times, but is\n    //    mitigated to a large extent by batched property processing in 2.x.\n    // 2. To avoid double object propagation when a bag including values bound\n    //    to the `if` property as well as one or more hostProps could enqueue\n    //    the <dom-if> to flush before the <template>'s host property\n    //    forwarding. In that scenario creating an instance would result in\n    //    the host props being set once, and then the enqueued changes on the\n    //    template would set properties a second time, potentially causing an\n    //    object to be set to an instance more than once.  Creating the\n    //    instance async from flushing data ensures this doesn't happen. If\n    //    we wanted a sync option in the future, simply having <dom-if> flush\n    //    (or clear) its template's pending host properties before creating\n    //    the instance would also avoid the problem.\n    this.__renderDebouncer = Debouncer.debounce(\n          this.__renderDebouncer\n        , microTask\n        , () => this.__render());\n    enqueueDebouncer(this.__renderDebouncer);\n  }\n\n  /**\n   * @override\n   * @return {void}\n   */\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    const parent = wrap(this).parentNode;\n    if (!parent || (parent.nodeType == Node.DOCUMENT_FRAGMENT_NODE &&\n        !wrap(parent).host)) {\n      this.__teardownInstance();\n    }\n  }\n\n  /**\n   * @override\n   * @return {void}\n   */\n  connectedCallback() {\n    super.connectedCallback();\n    this.style.display = 'none';\n    if (this.if) {\n      this.__debounceRender();\n    }\n  }\n\n  /**\n   * Forces the element to render its content. Normally rendering is\n   * asynchronous to a provoking change. This is done for efficiency so\n   * that multiple changes trigger only a single render. The render method\n   * should be called if, for example, template rendering is required to\n   * validate application state.\n   * @return {void}\n   */\n  render() {\n    flush();\n  }\n\n  __render() {\n    if (this.if) {\n      if (!this.__ensureInstance()) {\n        // No template found yet\n        return;\n      }\n      this._showHideChildren();\n    } else if (this.restamp) {\n      this.__teardownInstance();\n    }\n    if (!this.restamp && this.__instance) {\n      this._showHideChildren();\n    }\n    if (this.if != this._lastIf) {\n      this.dispatchEvent(new CustomEvent('dom-change', {\n        bubbles: true,\n        composed: true\n      }));\n      this._lastIf = this.if;\n    }\n  }\n\n  __ensureInstance() {\n    let parentNode = wrap(this).parentNode;\n    // Guard against element being detached while render was queued\n    if (parentNode) {\n      if (!this.__ctor) {\n        let template = /** @type {HTMLTemplateElement} */(wrap(this).querySelector('template'));\n        if (!template) {\n          // Wait until childList changes and template should be there by then\n          let observer = new MutationObserver(() => {\n            if (wrap(this).querySelector('template')) {\n              observer.disconnect();\n              this.__render();\n            } else {\n              throw new Error('dom-if requires a <template> child');\n            }\n          });\n          observer.observe(this, {childList: true});\n          return false;\n        }\n        this.__ctor = templatize(template, this, {\n          // dom-if templatizer instances require `mutable: true`, as\n          // `__syncHostProperties` relies on that behavior to sync objects\n          mutableData: true,\n          /**\n           * @param {string} prop Property to forward\n           * @param {*} value Value of property\n           * @this {DomIf}\n           */\n          forwardHostProp: function(prop, value) {\n            if (this.__instance) {\n              if (this.if) {\n                this.__instance.forwardHostProp(prop, value);\n              } else {\n                // If we have an instance but are squelching host property\n                // forwarding due to if being false, note the invalidated\n                // properties so `__syncHostProperties` can sync them the next\n                // time `if` becomes true\n                this.__invalidProps = this.__invalidProps || Object.create(null);\n                this.__invalidProps[root(prop)] = true;\n              }\n            }\n          }\n        });\n      }\n      if (!this.__instance) {\n        this.__instance = new this.__ctor();\n        wrap(parentNode).insertBefore(this.__instance.root, this);\n      } else {\n        this.__syncHostProperties();\n        let c$ = this.__instance.children;\n        if (c$ && c$.length) {\n          // Detect case where dom-if was re-attached in new position\n          let lastChild = wrap(this).previousSibling;\n          if (lastChild !== c$[c$.length-1]) {\n            for (let i=0, n; (i<c$.length) && (n=c$[i]); i++) {\n              wrap(parentNode).insertBefore(n, this);\n            }\n          }\n        }\n      }\n    }\n    return true;\n  }\n\n  __syncHostProperties() {\n    let props = this.__invalidProps;\n    if (props) {\n      for (let prop in props) {\n        this.__instance._setPendingProperty(prop, this.__dataHost[prop]);\n      }\n      this.__invalidProps = null;\n      this.__instance._flushProperties();\n    }\n  }\n\n  __teardownInstance() {\n    if (this.__instance) {\n      let c$ = this.__instance.children;\n      if (c$ && c$.length) {\n        // use first child parent, for case when dom-if may have been detached\n        let parent = wrap(c$[0]).parentNode;\n        // Instance children may be disconnected from parents when dom-if\n        // detaches if a tree was innerHTML'ed\n        if (parent) {\n          parent = wrap(parent);\n          for (let i=0, n; (i<c$.length) && (n=c$[i]); i++) {\n            parent.removeChild(n);\n          }\n        }\n      }\n      this.__instance = null;\n      this.__invalidProps = null;\n    }\n  }\n\n  /**\n   * Shows or hides the template instance top level child elements. For\n   * text nodes, `textContent` is removed while \"hidden\" and replaced when\n   * \"shown.\"\n   * @return {void}\n   * @protected\n   * @suppress {visibility}\n   */\n  _showHideChildren() {\n    let hidden = this.__hideTemplateChildren__ || !this.if;\n    if (this.__instance) {\n      this.__instance._showHideChildren(hidden);\n    }\n  }\n\n}\n\ncustomElements.define(DomIf.is, DomIf);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}