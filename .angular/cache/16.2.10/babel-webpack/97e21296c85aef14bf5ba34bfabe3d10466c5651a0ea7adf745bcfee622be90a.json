{"ast":null,"code":"/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\nimport templateMap from './template-map.js';\nimport { StyleNode } from './css-parse.js'; // eslint-disable-line no-unused-vars\n\n/*\n * Utilities for handling invalidating apply-shim mixins for a given template.\n *\n * The invalidation strategy involves keeping track of the \"current\" version of a template's mixins, and updating that count when a mixin is invalidated.\n * The template\n */\n\n/** @const {string} */\nconst CURRENT_VERSION = '_applyShimCurrentVersion';\n\n/** @const {string} */\nconst NEXT_VERSION = '_applyShimNextVersion';\n\n/** @const {string} */\nconst VALIDATING_VERSION = '_applyShimValidatingVersion';\n\n/**\n * @const {Promise<void>}\n */\nconst promise = Promise.resolve();\n\n/**\n * @param {string} elementName\n */\nexport function invalidate(elementName) {\n  let template = templateMap[elementName];\n  if (template) {\n    invalidateTemplate(template);\n  }\n}\n\n/**\n * This function can be called multiple times to mark a template invalid\n * and signal that the style inside must be regenerated.\n *\n * Use `startValidatingTemplate` to begin an asynchronous validation cycle.\n * During that cycle, call `templateIsValidating` to see if the template must\n * be revalidated\n * @param {HTMLTemplateElement} template\n */\nexport function invalidateTemplate(template) {\n  // default the current version to 0\n  template[CURRENT_VERSION] = template[CURRENT_VERSION] || 0;\n  // ensure the \"validating for\" flag exists\n  template[VALIDATING_VERSION] = template[VALIDATING_VERSION] || 0;\n  // increment the next version\n  template[NEXT_VERSION] = (template[NEXT_VERSION] || 0) + 1;\n}\n\n/**\n * @param {string} elementName\n * @return {boolean}\n */\nexport function isValid(elementName) {\n  let template = templateMap[elementName];\n  if (template) {\n    return templateIsValid(template);\n  }\n  return true;\n}\n\n/**\n * @param {HTMLTemplateElement} template\n * @return {boolean}\n */\nexport function templateIsValid(template) {\n  return template[CURRENT_VERSION] === template[NEXT_VERSION];\n}\n\n/**\n * @param {string} elementName\n * @return {boolean}\n */\nexport function isValidating(elementName) {\n  let template = templateMap[elementName];\n  if (template) {\n    return templateIsValidating(template);\n  }\n  return false;\n}\n\n/**\n * Returns true if the template is currently invalid and `startValidating` has been called since the last invalidation.\n * If false, the template must be validated.\n * @param {HTMLTemplateElement} template\n * @return {boolean}\n */\nexport function templateIsValidating(template) {\n  return !templateIsValid(template) && template[VALIDATING_VERSION] === template[NEXT_VERSION];\n}\n\n/**\n * the template is marked as `validating` for one microtask so that all instances\n * found in the tree crawl of `applyStyle` will update themselves,\n * but the template will only be updated once.\n * @param {string} elementName\n*/\nexport function startValidating(elementName) {\n  let template = templateMap[elementName];\n  startValidatingTemplate(template);\n}\n\n/**\n * Begin an asynchronous invalidation cycle.\n * This should be called after every validation of a template\n *\n * After one microtask, the template will be marked as valid until the next call to `invalidateTemplate`\n * @param {HTMLTemplateElement} template\n */\nexport function startValidatingTemplate(template) {\n  // remember that the current \"next version\" is the reason for this validation cycle\n  template[VALIDATING_VERSION] = template[NEXT_VERSION];\n  // however, there only needs to be one async task to clear the counters\n  if (!template._validating) {\n    template._validating = true;\n    promise.then(function () {\n      // sync the current version to let future invalidations cause a refresh cycle\n      template[CURRENT_VERSION] = template[NEXT_VERSION];\n      template._validating = false;\n    });\n  }\n}\n\n/**\n * @return {boolean}\n */\nexport function elementsAreInvalid() {\n  for (let elementName in templateMap) {\n    let template = templateMap[elementName];\n    if (!templateIsValid(template)) {\n      return true;\n    }\n  }\n  return false;\n}","map":{"version":3,"names":["templateMap","StyleNode","CURRENT_VERSION","NEXT_VERSION","VALIDATING_VERSION","promise","Promise","resolve","invalidate","elementName","template","invalidateTemplate","isValid","templateIsValid","isValidating","templateIsValidating","startValidating","startValidatingTemplate","_validating","then","elementsAreInvalid"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@webcomponents/shadycss/src/apply-shim-utils.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\nimport templateMap from './template-map.js';\nimport {StyleNode} from './css-parse.js'; // eslint-disable-line no-unused-vars\n\n/*\n * Utilities for handling invalidating apply-shim mixins for a given template.\n *\n * The invalidation strategy involves keeping track of the \"current\" version of a template's mixins, and updating that count when a mixin is invalidated.\n * The template\n */\n\n/** @const {string} */\nconst CURRENT_VERSION = '_applyShimCurrentVersion';\n\n/** @const {string} */\nconst NEXT_VERSION = '_applyShimNextVersion';\n\n/** @const {string} */\nconst VALIDATING_VERSION = '_applyShimValidatingVersion';\n\n/**\n * @const {Promise<void>}\n */\nconst promise = Promise.resolve();\n\n/**\n * @param {string} elementName\n */\nexport function invalidate(elementName){\n  let template = templateMap[elementName];\n  if (template) {\n    invalidateTemplate(template);\n  }\n}\n\n/**\n * This function can be called multiple times to mark a template invalid\n * and signal that the style inside must be regenerated.\n *\n * Use `startValidatingTemplate` to begin an asynchronous validation cycle.\n * During that cycle, call `templateIsValidating` to see if the template must\n * be revalidated\n * @param {HTMLTemplateElement} template\n */\nexport function invalidateTemplate(template) {\n  // default the current version to 0\n  template[CURRENT_VERSION] = template[CURRENT_VERSION] || 0;\n  // ensure the \"validating for\" flag exists\n  template[VALIDATING_VERSION] = template[VALIDATING_VERSION] || 0;\n  // increment the next version\n  template[NEXT_VERSION] = (template[NEXT_VERSION] || 0) + 1;\n}\n\n/**\n * @param {string} elementName\n * @return {boolean}\n */\nexport function isValid(elementName) {\n  let template = templateMap[elementName];\n  if (template) {\n    return templateIsValid(template);\n  }\n  return true;\n}\n\n/**\n * @param {HTMLTemplateElement} template\n * @return {boolean}\n */\nexport function templateIsValid(template) {\n  return template[CURRENT_VERSION] === template[NEXT_VERSION];\n}\n\n/**\n * @param {string} elementName\n * @return {boolean}\n */\nexport function isValidating(elementName) {\n  let template = templateMap[elementName];\n  if (template) {\n    return templateIsValidating(template);\n  }\n  return false;\n}\n\n/**\n * Returns true if the template is currently invalid and `startValidating` has been called since the last invalidation.\n * If false, the template must be validated.\n * @param {HTMLTemplateElement} template\n * @return {boolean}\n */\nexport function templateIsValidating(template) {\n  return !templateIsValid(template) && template[VALIDATING_VERSION] === template[NEXT_VERSION];\n}\n\n/**\n * the template is marked as `validating` for one microtask so that all instances\n * found in the tree crawl of `applyStyle` will update themselves,\n * but the template will only be updated once.\n * @param {string} elementName\n*/\nexport function startValidating(elementName) {\n  let template = templateMap[elementName];\n  startValidatingTemplate(template);\n}\n\n/**\n * Begin an asynchronous invalidation cycle.\n * This should be called after every validation of a template\n *\n * After one microtask, the template will be marked as valid until the next call to `invalidateTemplate`\n * @param {HTMLTemplateElement} template\n */\nexport function startValidatingTemplate(template) {\n  // remember that the current \"next version\" is the reason for this validation cycle\n  template[VALIDATING_VERSION] = template[NEXT_VERSION];\n  // however, there only needs to be one async task to clear the counters\n  if (!template._validating) {\n    template._validating = true;\n    promise.then(function() {\n      // sync the current version to let future invalidations cause a refresh cycle\n      template[CURRENT_VERSION] = template[NEXT_VERSION];\n      template._validating = false;\n    });\n  }\n}\n\n/**\n * @return {boolean}\n */\nexport function elementsAreInvalid() {\n  for (let elementName in templateMap) {\n    let template = templateMap[elementName];\n    if (!templateIsValid(template)) {\n      return true;\n    }\n  }\n  return false;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}