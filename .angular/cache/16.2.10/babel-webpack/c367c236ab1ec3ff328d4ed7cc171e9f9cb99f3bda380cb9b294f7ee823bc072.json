{"ast":null,"code":"/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport './boot.js';\nimport './mixin.js';\nimport './async.js';\n\n/**\n * @summary Collapse multiple callbacks into one invocation after a timer.\n */\nexport class Debouncer {\n  constructor() {\n    this._asyncModule = null;\n    this._callback = null;\n    this._timer = null;\n  }\n  /**\n   * Sets the scheduler; that is, a module with the Async interface,\n   * a callback and optional arguments to be passed to the run function\n   * from the async module.\n   *\n   * @param {!AsyncInterface} asyncModule Object with Async interface.\n   * @param {function()} callback Callback to run.\n   * @return {void}\n   */\n  setConfig(asyncModule, callback) {\n    this._asyncModule = asyncModule;\n    this._callback = callback;\n    this._timer = this._asyncModule.run(() => {\n      this._timer = null;\n      debouncerQueue.delete(this);\n      this._callback();\n    });\n  }\n  /**\n   * Cancels an active debouncer and returns a reference to itself.\n   *\n   * @return {void}\n   */\n  cancel() {\n    if (this.isActive()) {\n      this._cancelAsync();\n      // Canceling a debouncer removes its spot from the flush queue,\n      // so if a debouncer is manually canceled and re-debounced, it\n      // will reset its flush order (this is a very minor difference from 1.x)\n      // Re-debouncing via the `debounce` API retains the 1.x FIFO flush order\n      debouncerQueue.delete(this);\n    }\n  }\n  /**\n   * Cancels a debouncer's async callback.\n   *\n   * @return {void}\n   */\n  _cancelAsync() {\n    if (this.isActive()) {\n      this._asyncModule.cancel( /** @type {number} */this._timer);\n      this._timer = null;\n    }\n  }\n  /**\n   * Flushes an active debouncer and returns a reference to itself.\n   *\n   * @return {void}\n   */\n  flush() {\n    if (this.isActive()) {\n      this.cancel();\n      this._callback();\n    }\n  }\n  /**\n   * Returns true if the debouncer is active.\n   *\n   * @return {boolean} True if active.\n   */\n  isActive() {\n    return this._timer != null;\n  }\n  /**\n   * Creates a debouncer if no debouncer is passed as a parameter\n   * or it cancels an active debouncer otherwise. The following\n   * example shows how a debouncer can be called multiple times within a\n   * microtask and \"debounced\" such that the provided callback function is\n   * called once. Add this method to a custom element:\n   *\n   * ```js\n   * import {microTask} from '@polymer/polymer/lib/utils/async.js';\n   * import {Debouncer} from '@polymer/polymer/lib/utils/debounce.js';\n   * // ...\n   *\n   * _debounceWork() {\n   *   this._debounceJob = Debouncer.debounce(this._debounceJob,\n   *       microTask, () => this._doWork());\n   * }\n   * ```\n   *\n   * If the `_debounceWork` method is called multiple times within the same\n   * microtask, the `_doWork` function will be called only once at the next\n   * microtask checkpoint.\n   *\n   * Note: In testing it is often convenient to avoid asynchrony. To accomplish\n   * this with a debouncer, you can use `enqueueDebouncer` and\n   * `flush`. For example, extend the above example by adding\n   * `enqueueDebouncer(this._debounceJob)` at the end of the\n   * `_debounceWork` method. Then in a test, call `flush` to ensure\n   * the debouncer has completed.\n   *\n   * @param {Debouncer?} debouncer Debouncer object.\n   * @param {!AsyncInterface} asyncModule Object with Async interface\n   * @param {function()} callback Callback to run.\n   * @return {!Debouncer} Returns a debouncer object.\n   */\n  static debounce(debouncer, asyncModule, callback) {\n    if (debouncer instanceof Debouncer) {\n      // Cancel the async callback, but leave in debouncerQueue if it was\n      // enqueued, to maintain 1.x flush order\n      debouncer._cancelAsync();\n    } else {\n      debouncer = new Debouncer();\n    }\n    debouncer.setConfig(asyncModule, callback);\n    return debouncer;\n  }\n}\nlet debouncerQueue = new Set();\n\n/**\n * Adds a `Debouncer` to a list of globally flushable tasks.\n *\n * @param {!Debouncer} debouncer Debouncer to enqueue\n * @return {void}\n */\nexport const enqueueDebouncer = function (debouncer) {\n  debouncerQueue.add(debouncer);\n};\n\n/**\n * Flushes any enqueued debouncers\n *\n * @return {boolean} Returns whether any debouncers were flushed\n */\nexport const flushDebouncers = function () {\n  const didFlush = Boolean(debouncerQueue.size);\n  // If new debouncers are added while flushing, Set.forEach will ensure\n  // newly added ones are also flushed\n  debouncerQueue.forEach(debouncer => {\n    try {\n      debouncer.flush();\n    } catch (e) {\n      setTimeout(() => {\n        throw e;\n      });\n    }\n  });\n  return didFlush;\n};","map":{"version":3,"names":["Debouncer","constructor","_asyncModule","_callback","_timer","setConfig","asyncModule","callback","run","debouncerQueue","delete","cancel","isActive","_cancelAsync","flush","debounce","debouncer","Set","enqueueDebouncer","add","flushDebouncers","didFlush","Boolean","size","forEach","e","setTimeout"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@polymer/polymer/lib/utils/debounce.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport './boot.js';\n\nimport './mixin.js';\nimport './async.js';\n\n/**\n * @summary Collapse multiple callbacks into one invocation after a timer.\n */\nexport class Debouncer {\n  constructor() {\n    this._asyncModule = null;\n    this._callback = null;\n    this._timer = null;\n  }\n  /**\n   * Sets the scheduler; that is, a module with the Async interface,\n   * a callback and optional arguments to be passed to the run function\n   * from the async module.\n   *\n   * @param {!AsyncInterface} asyncModule Object with Async interface.\n   * @param {function()} callback Callback to run.\n   * @return {void}\n   */\n  setConfig(asyncModule, callback) {\n    this._asyncModule = asyncModule;\n    this._callback = callback;\n    this._timer = this._asyncModule.run(() => {\n      this._timer = null;\n      debouncerQueue.delete(this);\n      this._callback();\n    });\n  }\n  /**\n   * Cancels an active debouncer and returns a reference to itself.\n   *\n   * @return {void}\n   */\n  cancel() {\n    if (this.isActive()) {\n      this._cancelAsync();\n      // Canceling a debouncer removes its spot from the flush queue,\n      // so if a debouncer is manually canceled and re-debounced, it\n      // will reset its flush order (this is a very minor difference from 1.x)\n      // Re-debouncing via the `debounce` API retains the 1.x FIFO flush order\n      debouncerQueue.delete(this);\n    }\n  }\n  /**\n   * Cancels a debouncer's async callback.\n   *\n   * @return {void}\n   */\n  _cancelAsync() {\n    if (this.isActive()) {\n      this._asyncModule.cancel(/** @type {number} */(this._timer));\n      this._timer = null;\n    }\n  }\n  /**\n   * Flushes an active debouncer and returns a reference to itself.\n   *\n   * @return {void}\n   */\n  flush() {\n    if (this.isActive()) {\n      this.cancel();\n      this._callback();\n    }\n  }\n  /**\n   * Returns true if the debouncer is active.\n   *\n   * @return {boolean} True if active.\n   */\n  isActive() {\n    return this._timer != null;\n  }\n  /**\n   * Creates a debouncer if no debouncer is passed as a parameter\n   * or it cancels an active debouncer otherwise. The following\n   * example shows how a debouncer can be called multiple times within a\n   * microtask and \"debounced\" such that the provided callback function is\n   * called once. Add this method to a custom element:\n   *\n   * ```js\n   * import {microTask} from '@polymer/polymer/lib/utils/async.js';\n   * import {Debouncer} from '@polymer/polymer/lib/utils/debounce.js';\n   * // ...\n   *\n   * _debounceWork() {\n   *   this._debounceJob = Debouncer.debounce(this._debounceJob,\n   *       microTask, () => this._doWork());\n   * }\n   * ```\n   *\n   * If the `_debounceWork` method is called multiple times within the same\n   * microtask, the `_doWork` function will be called only once at the next\n   * microtask checkpoint.\n   *\n   * Note: In testing it is often convenient to avoid asynchrony. To accomplish\n   * this with a debouncer, you can use `enqueueDebouncer` and\n   * `flush`. For example, extend the above example by adding\n   * `enqueueDebouncer(this._debounceJob)` at the end of the\n   * `_debounceWork` method. Then in a test, call `flush` to ensure\n   * the debouncer has completed.\n   *\n   * @param {Debouncer?} debouncer Debouncer object.\n   * @param {!AsyncInterface} asyncModule Object with Async interface\n   * @param {function()} callback Callback to run.\n   * @return {!Debouncer} Returns a debouncer object.\n   */\n  static debounce(debouncer, asyncModule, callback) {\n    if (debouncer instanceof Debouncer) {\n      // Cancel the async callback, but leave in debouncerQueue if it was\n      // enqueued, to maintain 1.x flush order\n      debouncer._cancelAsync();\n    } else {\n      debouncer = new Debouncer();\n    }\n    debouncer.setConfig(asyncModule, callback);\n    return debouncer;\n  }\n}\n\nlet debouncerQueue = new Set();\n\n/**\n * Adds a `Debouncer` to a list of globally flushable tasks.\n *\n * @param {!Debouncer} debouncer Debouncer to enqueue\n * @return {void}\n */\nexport const enqueueDebouncer = function(debouncer) {\n  debouncerQueue.add(debouncer);\n};\n\n/**\n * Flushes any enqueued debouncers\n *\n * @return {boolean} Returns whether any debouncers were flushed\n */\nexport const flushDebouncers = function() {\n  const didFlush = Boolean(debouncerQueue.size);\n  // If new debouncers are added while flushing, Set.forEach will ensure\n  // newly added ones are also flushed\n  debouncerQueue.forEach(debouncer => {\n    try {\n      debouncer.flush();\n    } catch(e) {\n      setTimeout(() => {\n        throw e;\n      });\n    }\n  });\n  return didFlush;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}