{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2022 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { isElementFocused, isElementHidden } from './focus-utils.js';\nimport { KeyboardMixin } from './keyboard-mixin.js';\n\n/**\n * A mixin for navigating items with keyboard.\n *\n * @polymerMixin\n * @mixes KeyboardMixin\n */\nexport const KeyboardDirectionMixin = superclass => class KeyboardDirectionMixinClass extends KeyboardMixin(superclass) {\n  /**\n   * @return {Element | null}\n   * @protected\n   */\n  get focused() {\n    return (this._getItems() || []).find(isElementFocused);\n  }\n\n  /**\n   * @return {boolean}\n   * @protected\n   */\n  get _vertical() {\n    return true;\n  }\n\n  /** @protected */\n  focus() {\n    const items = this._getItems();\n    if (Array.isArray(items)) {\n      const idx = this._getAvailableIndex(items, 0, null, item => !isElementHidden(item));\n      if (idx >= 0) {\n        items[idx].focus();\n      }\n    }\n  }\n\n  /**\n   * Get the list of items participating in keyboard navigation.\n   * By default, it treats all the light DOM children as items.\n   * Override this method to provide custom list of elements.\n   *\n   * @return {Element[]}\n   * @protected\n   */\n  _getItems() {\n    return Array.from(this.children);\n  }\n\n  /**\n   * Override an event listener from `KeyboardMixin`.\n   *\n   * @param {!KeyboardEvent} event\n   * @protected\n   * @override\n   */\n  _onKeyDown(event) {\n    super._onKeyDown(event);\n    if (event.metaKey || event.ctrlKey) {\n      return;\n    }\n    const {\n      key\n    } = event;\n    const items = this._getItems() || [];\n    const currentIdx = items.indexOf(this.focused);\n    let idx;\n    let increment;\n    const isRTL = !this._vertical && this.getAttribute('dir') === 'rtl';\n    const dirIncrement = isRTL ? -1 : 1;\n    if (this.__isPrevKey(key)) {\n      increment = -dirIncrement;\n      idx = currentIdx - dirIncrement;\n    } else if (this.__isNextKey(key)) {\n      increment = dirIncrement;\n      idx = currentIdx + dirIncrement;\n    } else if (key === 'Home') {\n      increment = 1;\n      idx = 0;\n    } else if (key === 'End') {\n      increment = -1;\n      idx = items.length - 1;\n    }\n    idx = this._getAvailableIndex(items, idx, increment, item => !isElementHidden(item));\n    if (idx >= 0) {\n      event.preventDefault();\n      this._focus(idx, true);\n    }\n  }\n\n  /**\n   * @param {string} key\n   * @return {boolean}\n   * @private\n   */\n  __isPrevKey(key) {\n    return this._vertical ? key === 'ArrowUp' : key === 'ArrowLeft';\n  }\n\n  /**\n   * @param {string} key\n   * @return {boolean}\n   * @private\n   */\n  __isNextKey(key) {\n    return this._vertical ? key === 'ArrowDown' : key === 'ArrowRight';\n  }\n\n  /**\n   * Focus the item at given index. Override this method to add custom logic.\n   *\n   * @param {number} index\n   * @param {boolean} navigating\n   * @protected\n   */\n  _focus(index, navigating = false) {\n    const items = this._getItems();\n    this._focusItem(items[index], navigating);\n  }\n\n  /**\n   * Focus the given item. Override this method to add custom logic.\n   *\n   * @param {Element} item\n   * @param {boolean} navigating\n   * @protected\n   */\n  _focusItem(item) {\n    if (item) {\n      item.focus();\n\n      // Generally, the items are expected to implement `FocusMixin`\n      // that would set this attribute based on the `keydown` event.\n      // We set it manually to handle programmatic focus() calls.\n      item.setAttribute('focus-ring', '');\n    }\n  }\n\n  /**\n   * Returns index of the next item that satisfies the given condition,\n   * based on the index of the current item and a numeric increment.\n   *\n   * @param {Element[]} items - array of items to iterate over\n   * @param {number} index - index of the current item\n   * @param {number} increment - numeric increment, can be either 1 or -1\n   * @param {Function} condition - function used to check the item\n   * @return {number}\n   * @protected\n   */\n  _getAvailableIndex(items, index, increment, condition) {\n    const totalItems = items.length;\n    let idx = index;\n    for (let i = 0; typeof idx === 'number' && i < totalItems; i += 1, idx += increment || 1) {\n      if (idx < 0) {\n        idx = totalItems - 1;\n      } else if (idx >= totalItems) {\n        idx = 0;\n      }\n      const item = items[idx];\n      if (!item.hasAttribute('disabled') && this.__isMatchingItem(item, condition)) {\n        return idx;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Returns true if the item matches condition.\n   *\n   * @param {Element} item - item to check\n   * @param {Function} condition - function used to check the item\n   * @return {number}\n   * @private\n   */\n  __isMatchingItem(item, condition) {\n    return typeof condition === 'function' ? condition(item) : true;\n  }\n};","map":{"version":3,"names":["isElementFocused","isElementHidden","KeyboardMixin","KeyboardDirectionMixin","superclass","KeyboardDirectionMixinClass","focused","_getItems","find","_vertical","focus","items","Array","isArray","idx","_getAvailableIndex","item","from","children","_onKeyDown","event","metaKey","ctrlKey","key","currentIdx","indexOf","increment","isRTL","getAttribute","dirIncrement","__isPrevKey","__isNextKey","length","preventDefault","_focus","index","navigating","_focusItem","setAttribute","condition","totalItems","i","hasAttribute","__isMatchingItem"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@vaadin/a11y-base/src/keyboard-direction-mixin.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2022 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { isElementFocused, isElementHidden } from './focus-utils.js';\nimport { KeyboardMixin } from './keyboard-mixin.js';\n\n/**\n * A mixin for navigating items with keyboard.\n *\n * @polymerMixin\n * @mixes KeyboardMixin\n */\nexport const KeyboardDirectionMixin = (superclass) =>\n  class KeyboardDirectionMixinClass extends KeyboardMixin(superclass) {\n    /**\n     * @return {Element | null}\n     * @protected\n     */\n    get focused() {\n      return (this._getItems() || []).find(isElementFocused);\n    }\n\n    /**\n     * @return {boolean}\n     * @protected\n     */\n    get _vertical() {\n      return true;\n    }\n\n    /** @protected */\n    focus() {\n      const items = this._getItems();\n      if (Array.isArray(items)) {\n        const idx = this._getAvailableIndex(items, 0, null, (item) => !isElementHidden(item));\n        if (idx >= 0) {\n          items[idx].focus();\n        }\n      }\n    }\n\n    /**\n     * Get the list of items participating in keyboard navigation.\n     * By default, it treats all the light DOM children as items.\n     * Override this method to provide custom list of elements.\n     *\n     * @return {Element[]}\n     * @protected\n     */\n    _getItems() {\n      return Array.from(this.children);\n    }\n\n    /**\n     * Override an event listener from `KeyboardMixin`.\n     *\n     * @param {!KeyboardEvent} event\n     * @protected\n     * @override\n     */\n    _onKeyDown(event) {\n      super._onKeyDown(event);\n\n      if (event.metaKey || event.ctrlKey) {\n        return;\n      }\n\n      const { key } = event;\n      const items = this._getItems() || [];\n      const currentIdx = items.indexOf(this.focused);\n\n      let idx;\n      let increment;\n\n      const isRTL = !this._vertical && this.getAttribute('dir') === 'rtl';\n      const dirIncrement = isRTL ? -1 : 1;\n\n      if (this.__isPrevKey(key)) {\n        increment = -dirIncrement;\n        idx = currentIdx - dirIncrement;\n      } else if (this.__isNextKey(key)) {\n        increment = dirIncrement;\n        idx = currentIdx + dirIncrement;\n      } else if (key === 'Home') {\n        increment = 1;\n        idx = 0;\n      } else if (key === 'End') {\n        increment = -1;\n        idx = items.length - 1;\n      }\n\n      idx = this._getAvailableIndex(items, idx, increment, (item) => !isElementHidden(item));\n\n      if (idx >= 0) {\n        event.preventDefault();\n        this._focus(idx, true);\n      }\n    }\n\n    /**\n     * @param {string} key\n     * @return {boolean}\n     * @private\n     */\n    __isPrevKey(key) {\n      return this._vertical ? key === 'ArrowUp' : key === 'ArrowLeft';\n    }\n\n    /**\n     * @param {string} key\n     * @return {boolean}\n     * @private\n     */\n    __isNextKey(key) {\n      return this._vertical ? key === 'ArrowDown' : key === 'ArrowRight';\n    }\n\n    /**\n     * Focus the item at given index. Override this method to add custom logic.\n     *\n     * @param {number} index\n     * @param {boolean} navigating\n     * @protected\n     */\n    _focus(index, navigating = false) {\n      const items = this._getItems();\n\n      this._focusItem(items[index], navigating);\n    }\n\n    /**\n     * Focus the given item. Override this method to add custom logic.\n     *\n     * @param {Element} item\n     * @param {boolean} navigating\n     * @protected\n     */\n    _focusItem(item) {\n      if (item) {\n        item.focus();\n\n        // Generally, the items are expected to implement `FocusMixin`\n        // that would set this attribute based on the `keydown` event.\n        // We set it manually to handle programmatic focus() calls.\n        item.setAttribute('focus-ring', '');\n      }\n    }\n\n    /**\n     * Returns index of the next item that satisfies the given condition,\n     * based on the index of the current item and a numeric increment.\n     *\n     * @param {Element[]} items - array of items to iterate over\n     * @param {number} index - index of the current item\n     * @param {number} increment - numeric increment, can be either 1 or -1\n     * @param {Function} condition - function used to check the item\n     * @return {number}\n     * @protected\n     */\n    _getAvailableIndex(items, index, increment, condition) {\n      const totalItems = items.length;\n      let idx = index;\n      for (let i = 0; typeof idx === 'number' && i < totalItems; i += 1, idx += increment || 1) {\n        if (idx < 0) {\n          idx = totalItems - 1;\n        } else if (idx >= totalItems) {\n          idx = 0;\n        }\n\n        const item = items[idx];\n\n        if (!item.hasAttribute('disabled') && this.__isMatchingItem(item, condition)) {\n          return idx;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Returns true if the item matches condition.\n     *\n     * @param {Element} item - item to check\n     * @param {Function} condition - function used to check the item\n     * @return {number}\n     * @private\n     */\n    __isMatchingItem(item, condition) {\n      return typeof condition === 'function' ? condition(item) : true;\n    }\n  };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}