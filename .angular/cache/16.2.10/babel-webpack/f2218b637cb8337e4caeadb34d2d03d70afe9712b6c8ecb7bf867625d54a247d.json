{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { addValueToAttribute, deserializeAttributeValue, removeValueFromAttribute, serializeAttributeValue } from '@vaadin/component-base/src/dom-utils.js';\nconst attributeToTargets = new Map();\n\n/**\n * Gets or creates a Set with the stored values for each element controlled by this helper\n *\n * @param {string} attr the attribute name used as key in the map\n *\n * @returns {WeakMap<HTMLElement, Set<string>} a weak map with the stored values for the elements being controlled by the helper\n */\nfunction getAttrMap(attr) {\n  if (!attributeToTargets.has(attr)) {\n    attributeToTargets.set(attr, new WeakMap());\n  }\n  return attributeToTargets.get(attr);\n}\n\n/**\n * Cleans the values set on the attribute to the given element.\n * It also stores the current values in the map, if `storeValue` is `true`.\n *\n * @param {HTMLElement} target\n * @param {string} attr the attribute to be cleared\n * @param {boolean} storeValue whether or not the current value of the attribute should be stored on the map\n * @returns\n */\nfunction cleanAriaIDReference(target, attr) {\n  if (!target) {\n    return;\n  }\n  target.removeAttribute(attr);\n}\n\n/**\n * Storing values of the accessible attributes in a Set inside of the WeakMap.\n *\n * @param {HTMLElement} target\n * @param {string} attr the attribute to be stored\n */\nfunction storeAriaIDReference(target, attr) {\n  if (!target || !attr) {\n    return;\n  }\n  const attributeMap = getAttrMap(attr);\n  if (attributeMap.has(target)) {\n    return;\n  }\n  const values = deserializeAttributeValue(target.getAttribute(attr));\n  attributeMap.set(target, new Set(values));\n}\n\n/**\n * Restores the generated values of the attribute to the given element.\n *\n * @param {HTMLElement} target\n * @param {string} attr\n */\nexport function restoreGeneratedAriaIDReference(target, attr) {\n  if (!target || !attr) {\n    return;\n  }\n  const attributeMap = getAttrMap(attr);\n  const values = attributeMap.get(target);\n  if (!values || values.size === 0) {\n    target.removeAttribute(attr);\n  } else {\n    addValueToAttribute(target, attr, serializeAttributeValue(values));\n  }\n  attributeMap.delete(target);\n}\n\n/**\n * Sets a new ID reference for a target element and an ARIA attribute.\n *\n * @typedef {Object} AriaIdReferenceConfig\n * @property {string | null | undefined} newId\n * @property {string | null | undefined} oldId\n * @property {boolean | null | undefined} fromUser\n * @param {HTMLElement} target\n * @param {string} attr\n * @param {AriaIdReferenceConfig | null | undefined} config\n * @param config.newId The new ARIA ID reference to set. If `null`, the attribute is removed,\n * and `config.fromUser` is true, any stored values are restored. If there are stored values\n * and `config.fromUser` is `false`, then `config.newId` is added to the stored values set.\n * @param config.oldId The ARIA ID reference to be removed from the attribute. If there are\n * stored values and `config.fromUser` is `false`, then `config.oldId` is removed from the\n * stored values set.\n * @param config.fromUser Indicates whether the function is called by the user or internally.\n * When `config.fromUser` is called with `true` for the first time, the function will clear\n * and store the attribute value for the given element.\n */\nexport function setAriaIDReference(target, attr, config = {\n  newId: null,\n  oldId: null,\n  fromUser: false\n}) {\n  if (!target || !attr) {\n    return;\n  }\n  const {\n    newId,\n    oldId,\n    fromUser\n  } = config;\n  const attributeMap = getAttrMap(attr);\n  const storedValues = attributeMap.get(target);\n  if (!fromUser && !!storedValues) {\n    // If there's any stored values, it means the attribute is being handled by the user\n    // Replace the \"oldId\" with \"newId\" on the stored values set and leave\n    oldId && storedValues.delete(oldId);\n    newId && storedValues.add(newId);\n    return;\n  }\n  if (fromUser) {\n    if (!storedValues) {\n      // If it's called from user and there's no stored values for the attribute,\n      // then store the current value\n      storeAriaIDReference(target, attr);\n    } else if (!newId) {\n      // If called from user with newId == null, it means the attribute will no longer\n      // be in control of the user and the stored values should be restored\n      // Removing the entry on the map for this target\n      attributeMap.delete(target);\n    }\n\n    // If it's from user, then clear the attribute value before setting newId\n    cleanAriaIDReference(target, attr);\n  }\n  removeValueFromAttribute(target, attr, oldId);\n  const attributeValue = !newId ? serializeAttributeValue(storedValues) : newId;\n  if (attributeValue) {\n    addValueToAttribute(target, attr, attributeValue);\n  }\n}\n\n/**\n * Removes the {@link attr | attribute} value of the given {@link target} element.\n * It also stores the current value, if no stored values are present.\n *\n * @param {HTMLElement} target\n * @param {string} attr\n */\nexport function removeAriaIDReference(target, attr) {\n  storeAriaIDReference(target, attr);\n  cleanAriaIDReference(target, attr);\n}","map":{"version":3,"names":["addValueToAttribute","deserializeAttributeValue","removeValueFromAttribute","serializeAttributeValue","attributeToTargets","Map","getAttrMap","attr","has","set","WeakMap","get","cleanAriaIDReference","target","removeAttribute","storeAriaIDReference","attributeMap","values","getAttribute","Set","restoreGeneratedAriaIDReference","size","delete","setAriaIDReference","config","newId","oldId","fromUser","storedValues","add","attributeValue","removeAriaIDReference"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@vaadin/a11y-base/src/aria-id-reference.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport {\n  addValueToAttribute,\n  deserializeAttributeValue,\n  removeValueFromAttribute,\n  serializeAttributeValue,\n} from '@vaadin/component-base/src/dom-utils.js';\n\nconst attributeToTargets = new Map();\n\n/**\n * Gets or creates a Set with the stored values for each element controlled by this helper\n *\n * @param {string} attr the attribute name used as key in the map\n *\n * @returns {WeakMap<HTMLElement, Set<string>} a weak map with the stored values for the elements being controlled by the helper\n */\nfunction getAttrMap(attr) {\n  if (!attributeToTargets.has(attr)) {\n    attributeToTargets.set(attr, new WeakMap());\n  }\n  return attributeToTargets.get(attr);\n}\n\n/**\n * Cleans the values set on the attribute to the given element.\n * It also stores the current values in the map, if `storeValue` is `true`.\n *\n * @param {HTMLElement} target\n * @param {string} attr the attribute to be cleared\n * @param {boolean} storeValue whether or not the current value of the attribute should be stored on the map\n * @returns\n */\nfunction cleanAriaIDReference(target, attr) {\n  if (!target) {\n    return;\n  }\n\n  target.removeAttribute(attr);\n}\n\n/**\n * Storing values of the accessible attributes in a Set inside of the WeakMap.\n *\n * @param {HTMLElement} target\n * @param {string} attr the attribute to be stored\n */\nfunction storeAriaIDReference(target, attr) {\n  if (!target || !attr) {\n    return;\n  }\n  const attributeMap = getAttrMap(attr);\n  if (attributeMap.has(target)) {\n    return;\n  }\n  const values = deserializeAttributeValue(target.getAttribute(attr));\n  attributeMap.set(target, new Set(values));\n}\n\n/**\n * Restores the generated values of the attribute to the given element.\n *\n * @param {HTMLElement} target\n * @param {string} attr\n */\nexport function restoreGeneratedAriaIDReference(target, attr) {\n  if (!target || !attr) {\n    return;\n  }\n  const attributeMap = getAttrMap(attr);\n  const values = attributeMap.get(target);\n  if (!values || values.size === 0) {\n    target.removeAttribute(attr);\n  } else {\n    addValueToAttribute(target, attr, serializeAttributeValue(values));\n  }\n  attributeMap.delete(target);\n}\n\n/**\n * Sets a new ID reference for a target element and an ARIA attribute.\n *\n * @typedef {Object} AriaIdReferenceConfig\n * @property {string | null | undefined} newId\n * @property {string | null | undefined} oldId\n * @property {boolean | null | undefined} fromUser\n * @param {HTMLElement} target\n * @param {string} attr\n * @param {AriaIdReferenceConfig | null | undefined} config\n * @param config.newId The new ARIA ID reference to set. If `null`, the attribute is removed,\n * and `config.fromUser` is true, any stored values are restored. If there are stored values\n * and `config.fromUser` is `false`, then `config.newId` is added to the stored values set.\n * @param config.oldId The ARIA ID reference to be removed from the attribute. If there are\n * stored values and `config.fromUser` is `false`, then `config.oldId` is removed from the\n * stored values set.\n * @param config.fromUser Indicates whether the function is called by the user or internally.\n * When `config.fromUser` is called with `true` for the first time, the function will clear\n * and store the attribute value for the given element.\n */\nexport function setAriaIDReference(target, attr, config = { newId: null, oldId: null, fromUser: false }) {\n  if (!target || !attr) {\n    return;\n  }\n\n  const { newId, oldId, fromUser } = config;\n\n  const attributeMap = getAttrMap(attr);\n  const storedValues = attributeMap.get(target);\n\n  if (!fromUser && !!storedValues) {\n    // If there's any stored values, it means the attribute is being handled by the user\n    // Replace the \"oldId\" with \"newId\" on the stored values set and leave\n    oldId && storedValues.delete(oldId);\n    newId && storedValues.add(newId);\n    return;\n  }\n\n  if (fromUser) {\n    if (!storedValues) {\n      // If it's called from user and there's no stored values for the attribute,\n      // then store the current value\n      storeAriaIDReference(target, attr);\n    } else if (!newId) {\n      // If called from user with newId == null, it means the attribute will no longer\n      // be in control of the user and the stored values should be restored\n      // Removing the entry on the map for this target\n      attributeMap.delete(target);\n    }\n\n    // If it's from user, then clear the attribute value before setting newId\n    cleanAriaIDReference(target, attr);\n  }\n\n  removeValueFromAttribute(target, attr, oldId);\n\n  const attributeValue = !newId ? serializeAttributeValue(storedValues) : newId;\n  if (attributeValue) {\n    addValueToAttribute(target, attr, attributeValue);\n  }\n}\n\n/**\n * Removes the {@link attr | attribute} value of the given {@link target} element.\n * It also stores the current value, if no stored values are present.\n *\n * @param {HTMLElement} target\n * @param {string} attr\n */\nexport function removeAriaIDReference(target, attr) {\n  storeAriaIDReference(target, attr);\n  cleanAriaIDReference(target, attr);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}