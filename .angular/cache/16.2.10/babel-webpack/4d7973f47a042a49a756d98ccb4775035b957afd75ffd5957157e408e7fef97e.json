{"ast":null,"code":"/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { GestureEventListeners } from '@polymer/polymer/lib/mixins/gesture-event-listeners.js';\nimport { addListener } from '@polymer/polymer/lib/utils/gestures.js';\nimport { dom } from '@polymer/polymer/lib/legacy/polymer.dom.js';\nimport { useShadow } from '@polymer/polymer/lib/utils/settings.js';\n\n/**\n * @polymerMixin\n */\nexport const ColumnReorderingMixin = superClass => class ColumnReorderingMixin extends GestureEventListeners(superClass) {\n  static get properties() {\n    return {\n      /**\n       * Set to true to allow column reordering.\n       */\n      columnReorderingAllowed: {\n        type: Boolean,\n        value: false\n      },\n      _orderBaseScope: {\n        type: Number,\n        value: 10000000\n      }\n    };\n  }\n  static get observers() {\n    return ['_updateOrders(_columnTree, _columnTree.*)'];\n  }\n  ready() {\n    super.ready();\n    addListener(this, 'track', this._onTrackEvent);\n    this._reorderGhost = this.shadowRoot.querySelector('[part=\"reorder-ghost\"]');\n    this.addEventListener('touchstart', this._onTouchStart.bind(this));\n    this.addEventListener('touchmove', this._onTouchMove.bind(this));\n    this.addEventListener('touchend', this._onTouchEnd.bind(this));\n    this.addEventListener('contextmenu', this._onContextMenu.bind(this));\n  }\n  _onContextMenu(e) {\n    if (this.hasAttribute('reordering')) {\n      e.preventDefault();\n    }\n  }\n  _onTouchStart(e) {\n    // Touch event, delay activation by 100ms\n    this._startTouchReorderTimeout = setTimeout(() => {\n      this._onTrackStart({\n        detail: {\n          x: e.touches[0].clientX,\n          y: e.touches[0].clientY\n        }\n      });\n    }, 100);\n  }\n  _onTouchMove(e) {\n    if (this._draggedColumn) {\n      e.preventDefault();\n    }\n    clearTimeout(this._startTouchReorderTimeout);\n  }\n  _onTouchEnd() {\n    clearTimeout(this._startTouchReorderTimeout);\n    this._onTrackEnd();\n  }\n  _onTrackEvent(e) {\n    if (e.detail.state === 'start') {\n      const path = e.composedPath();\n      const headerCell = path[path.indexOf(this.$.header) - 2];\n      if (!headerCell || !headerCell._content) {\n        // Not a header column\n        return;\n      }\n      const activeElement = this.getRootNode().activeElement;\n      if (headerCell._content.contains(this.getRootNode().activeElement) && (!this._ie || !this._isFocusable(activeElement))) {\n        // Something was focused inside the cell\n        return;\n      }\n      if (this.$.scroller.hasAttribute('column-resizing')) {\n        // Resizing is in progress\n        return;\n      }\n      if (!this._touchDevice) {\n        // Not a touch device\n        this._onTrackStart(e);\n      }\n    } else if (e.detail.state === 'track') {\n      this._onTrack(e);\n    } else if (e.detail.state === 'end') {\n      this._onTrackEnd(e);\n    }\n  }\n  _onTrackStart(e) {\n    if (!this.columnReorderingAllowed) {\n      return;\n    }\n\n    // Cancel reordering if there are draggable nodes on the event path\n    const path = e.path || dom(e).path;\n    if (path && path.filter(node => node.hasAttribute && node.hasAttribute('draggable'))[0]) {\n      return;\n    }\n    const headerCell = this._cellFromPoint(e.detail.x, e.detail.y);\n    if (!headerCell || headerCell.getAttribute('part').indexOf('header-cell') === -1) {\n      return;\n    }\n    this._toggleAttribute('reordering', true, this);\n    this._draggedColumn = headerCell._column;\n    while (this._draggedColumn.parentElement.childElementCount === 1) {\n      // This is the only column in the group, drag the whole group instead\n      this._draggedColumn = this._draggedColumn.parentElement;\n    }\n    this._setSiblingsReorderStatus(this._draggedColumn, 'allowed');\n    this._draggedColumn._reorderStatus = 'dragging';\n    this._updateGhost(headerCell);\n    this._reorderGhost.style.visibility = 'visible';\n    this._updateGhostPosition(e.detail.x, this._touchDevice ? e.detail.y - 50 : e.detail.y);\n    this._autoScroller();\n  }\n  _onTrack(e) {\n    if (!this._draggedColumn) {\n      // Reordering didn’t start. Skip this event.\n      return;\n    }\n    const targetCell = this._cellFromPoint(e.detail.x, e.detail.y);\n    if (!targetCell) {\n      return;\n    }\n    const targetColumn = this._getTargetColumn(targetCell, this._draggedColumn);\n    if (this._isSwapAllowed(this._draggedColumn, targetColumn) && this._isSwappableByPosition(targetColumn, e.detail.x)) {\n      this._swapColumnOrders(this._draggedColumn, targetColumn);\n    }\n    this._updateGhostPosition(e.detail.x, this._touchDevice ? e.detail.y - 50 : e.detail.y);\n    this._lastDragClientX = e.detail.x;\n  }\n  _onTrackEnd() {\n    if (!this._draggedColumn) {\n      // Reordering didn’t start. Skip this event.\n      return;\n    }\n    this._toggleAttribute('reordering', false, this);\n    this._draggedColumn._reorderStatus = '';\n    this._setSiblingsReorderStatus(this._draggedColumn, '');\n    this._draggedColumn = null;\n    this._lastDragClientX = null;\n    this._reorderGhost.style.visibility = 'hidden';\n    this.dispatchEvent(new CustomEvent('column-reorder', {\n      detail: {\n        columns: this._getColumnsInOrder()\n      }\n    }));\n  }\n  _getColumnsInOrder() {\n    return this._columnTree.slice(0).pop().filter(c => !c.hidden).sort((b, a) => b._order - a._order);\n  }\n  _cellFromPoint(x, y) {\n    x = x || 0;\n    y = y || 0;\n    if (!this._draggedColumn) {\n      this._toggleAttribute('no-content-pointer-events', true, this.$.scroller);\n    }\n    let cell;\n    if (useShadow) {\n      cell = this.shadowRoot.elementFromPoint(x, y);\n    } else {\n      cell = document.elementFromPoint(x, y);\n\n      // Workaround a FF58 bug\n      if (cell.localName === 'vaadin-grid-cell-content') {\n        cell = cell.assignedSlot.parentNode;\n      }\n    }\n    this._toggleAttribute('no-content-pointer-events', false, this.$.scroller);\n\n    // Make sure the element is actually a cell\n    if (cell && cell._column) {\n      return cell;\n    }\n  }\n  _updateGhostPosition(eventClientX, eventClientY) {\n    const ghostRect = this._reorderGhost.getBoundingClientRect();\n    // // This is where we want to position the ghost\n    const targetLeft = eventClientX - ghostRect.width / 2;\n    const targetTop = eventClientY - ghostRect.height / 2;\n    // Current position\n    const _left = parseInt(this._reorderGhost._left || 0);\n    const _top = parseInt(this._reorderGhost._top || 0);\n    // Reposition the ghost\n    this._reorderGhost._left = _left - (ghostRect.left - targetLeft);\n    this._reorderGhost._top = _top - (ghostRect.top - targetTop);\n    this._reorderGhost.style.transform = `translate(${this._reorderGhost._left}px, ${this._reorderGhost._top}px)`;\n  }\n  _getInnerText(e) {\n    if (e.localName) {\n      // Custom implementation needed since IE11 doesn't respect the spec in case of hidden elements\n      if (getComputedStyle(e).display === 'none') {\n        return '';\n      } else {\n        return Array.from(e.childNodes).map(n => this._getInnerText(n)).join('');\n      }\n    } else {\n      return e.textContent;\n    }\n  }\n  _updateGhost(cell) {\n    const ghost = this._reorderGhost;\n    ghost.textContent = this._getInnerText(cell._content);\n    const style = window.getComputedStyle(cell);\n    ['boxSizing', 'display', 'width', 'height', 'background', 'alignItems', 'padding', 'border', 'flex-direction', 'overflow'].forEach(propertyName => ghost.style[propertyName] = style[propertyName]);\n    return ghost;\n  }\n  _updateOrders(columnTree, splices) {\n    if (columnTree === undefined || splices === undefined) {\n      return;\n    }\n\n    // Set order numbers to top-level columns\n    columnTree[0].forEach((column, index) => column._order = (index + 1) * this._orderBaseScope);\n  }\n  _setSiblingsReorderStatus(column, status) {\n    Array.from(column.parentNode.children).filter(child => /column/.test(child.localName) && this._isSwapAllowed(child, column)).forEach(sibling => sibling._reorderStatus = status);\n  }\n  _autoScroller() {\n    if (this._lastDragClientX) {\n      const rightDiff = this._lastDragClientX - this.getBoundingClientRect().right + 50;\n      const leftDiff = this.getBoundingClientRect().left - this._lastDragClientX + 50;\n      if (rightDiff > 0) {\n        this.$.table.scrollLeft += rightDiff / 10;\n      } else if (leftDiff > 0) {\n        this.$.table.scrollLeft -= leftDiff / 10;\n      }\n      this._scrollHandler();\n    }\n    if (this._draggedColumn) {\n      this.async(this._autoScroller, 10);\n    }\n  }\n  _isSwapAllowed(column1, column2) {\n    if (column1 && column2) {\n      const differentColumns = column1 !== column2;\n      const sameParent = column1.parentElement === column2.parentElement;\n      const sameFrozen = column1.frozen === column2.frozen;\n      return differentColumns && sameParent && sameFrozen;\n    }\n  }\n  _isSwappableByPosition(targetColumn, clientX) {\n    const targetCell = Array.from(this.$.header.querySelectorAll('tr:not([hidden]) [part~=\"cell\"]')).filter(cell => targetColumn.contains(cell._column))[0];\n    const sourceCellRect = this.$.header.querySelector('tr:not([hidden]) [reorder-status=dragging]').getBoundingClientRect();\n    const targetRect = targetCell.getBoundingClientRect();\n    if (targetRect.left > sourceCellRect.left) {\n      return clientX > targetRect.right - sourceCellRect.width;\n    } else {\n      return clientX < targetRect.left + sourceCellRect.width;\n    }\n  }\n  _swapColumnOrders(column1, column2) {\n    const _order = column1._order;\n    column1._order = column2._order;\n    column2._order = _order;\n    this._updateLastFrozen();\n    this._updateFirstAndLastColumn();\n  }\n  _getTargetColumn(targetCell, draggedColumn) {\n    if (targetCell && draggedColumn) {\n      let candidate = targetCell._column;\n      while (candidate.parentElement !== draggedColumn.parentElement && candidate !== this) {\n        candidate = candidate.parentElement;\n      }\n      if (candidate.parentElement === draggedColumn.parentElement) {\n        return candidate;\n      } else {\n        return targetCell._column;\n      }\n    }\n  }\n};","map":{"version":3,"names":["GestureEventListeners","addListener","dom","useShadow","ColumnReorderingMixin","superClass","properties","columnReorderingAllowed","type","Boolean","value","_orderBaseScope","Number","observers","ready","_onTrackEvent","_reorderGhost","shadowRoot","querySelector","addEventListener","_onTouchStart","bind","_onTouchMove","_onTouchEnd","_onContextMenu","e","hasAttribute","preventDefault","_startTouchReorderTimeout","setTimeout","_onTrackStart","detail","x","touches","clientX","y","clientY","_draggedColumn","clearTimeout","_onTrackEnd","state","path","composedPath","headerCell","indexOf","$","header","_content","activeElement","getRootNode","contains","_ie","_isFocusable","scroller","_touchDevice","_onTrack","filter","node","_cellFromPoint","getAttribute","_toggleAttribute","_column","parentElement","childElementCount","_setSiblingsReorderStatus","_reorderStatus","_updateGhost","style","visibility","_updateGhostPosition","_autoScroller","targetCell","targetColumn","_getTargetColumn","_isSwapAllowed","_isSwappableByPosition","_swapColumnOrders","_lastDragClientX","dispatchEvent","CustomEvent","columns","_getColumnsInOrder","_columnTree","slice","pop","c","hidden","sort","b","a","_order","cell","elementFromPoint","document","localName","assignedSlot","parentNode","eventClientX","eventClientY","ghostRect","getBoundingClientRect","targetLeft","width","targetTop","height","_left","parseInt","_top","left","top","transform","_getInnerText","getComputedStyle","display","Array","from","childNodes","map","n","join","textContent","ghost","window","forEach","propertyName","_updateOrders","columnTree","splices","undefined","column","index","status","children","child","test","sibling","rightDiff","right","leftDiff","table","scrollLeft","_scrollHandler","async","column1","column2","differentColumns","sameParent","sameFrozen","frozen","querySelectorAll","sourceCellRect","targetRect","_updateLastFrozen","_updateFirstAndLastColumn","draggedColumn","candidate"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@vaadin/vaadin-grid/src/vaadin-grid-column-reordering-mixin.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { GestureEventListeners } from '@polymer/polymer/lib/mixins/gesture-event-listeners.js';\n\nimport { addListener } from '@polymer/polymer/lib/utils/gestures.js';\nimport { dom } from '@polymer/polymer/lib/legacy/polymer.dom.js';\nimport { useShadow } from '@polymer/polymer/lib/utils/settings.js';\n\n/**\n * @polymerMixin\n */\nexport const ColumnReorderingMixin = superClass => class ColumnReorderingMixin extends GestureEventListeners(superClass) {\n\n  static get properties() {\n    return {\n      /**\n       * Set to true to allow column reordering.\n       */\n      columnReorderingAllowed: {\n        type: Boolean,\n        value: false\n      },\n\n      _orderBaseScope: {\n        type: Number,\n        value: 10000000\n      }\n    };\n  }\n\n  static get observers() {\n    return [\n      '_updateOrders(_columnTree, _columnTree.*)'\n    ];\n  }\n\n  ready() {\n    super.ready();\n    addListener(this, 'track', this._onTrackEvent);\n    this._reorderGhost = this.shadowRoot.querySelector('[part=\"reorder-ghost\"]');\n\n    this.addEventListener('touchstart', this._onTouchStart.bind(this));\n    this.addEventListener('touchmove', this._onTouchMove.bind(this));\n    this.addEventListener('touchend', this._onTouchEnd.bind(this));\n    this.addEventListener('contextmenu', this._onContextMenu.bind(this));\n  }\n\n  _onContextMenu(e) {\n    if (this.hasAttribute('reordering')) {\n      e.preventDefault();\n    }\n  }\n\n  _onTouchStart(e) {\n    // Touch event, delay activation by 100ms\n    this._startTouchReorderTimeout = setTimeout(() => {\n      this._onTrackStart({\n        detail: {\n          x: e.touches[0].clientX,\n          y: e.touches[0].clientY\n        }\n      });\n    }, 100);\n  }\n\n  _onTouchMove(e) {\n    if (this._draggedColumn) {\n      e.preventDefault();\n    }\n    clearTimeout(this._startTouchReorderTimeout);\n  }\n\n  _onTouchEnd() {\n    clearTimeout(this._startTouchReorderTimeout);\n    this._onTrackEnd();\n  }\n\n  _onTrackEvent(e) {\n    if (e.detail.state === 'start') {\n      const path = e.composedPath();\n      const headerCell = path[path.indexOf(this.$.header) - 2];\n      if (!headerCell || !headerCell._content) {\n        // Not a header column\n        return;\n      }\n\n      const activeElement = this.getRootNode().activeElement;\n      if (headerCell._content.contains(this.getRootNode().activeElement)\n          && (!this._ie || !this._isFocusable(activeElement))) {\n        // Something was focused inside the cell\n        return;\n      }\n\n      if (this.$.scroller.hasAttribute('column-resizing')) {\n        // Resizing is in progress\n        return;\n      }\n\n      if (!this._touchDevice) {\n        // Not a touch device\n        this._onTrackStart(e);\n      }\n    } else if (e.detail.state === 'track') {\n      this._onTrack(e);\n    } else if (e.detail.state === 'end') {\n      this._onTrackEnd(e);\n    }\n  }\n\n  _onTrackStart(e) {\n    if (!this.columnReorderingAllowed) {\n      return;\n    }\n\n    // Cancel reordering if there are draggable nodes on the event path\n    const path = e.path || dom(e).path;\n    if (path && path.filter(node => node.hasAttribute && node.hasAttribute('draggable'))[0]) {\n      return;\n    }\n\n    const headerCell = this._cellFromPoint(e.detail.x, e.detail.y);\n    if (!headerCell || headerCell.getAttribute('part').indexOf('header-cell') === -1) {\n      return;\n    }\n\n    this._toggleAttribute('reordering', true, this);\n    this._draggedColumn = headerCell._column;\n    while (this._draggedColumn.parentElement.childElementCount === 1) {\n      // This is the only column in the group, drag the whole group instead\n      this._draggedColumn = this._draggedColumn.parentElement;\n    }\n    this._setSiblingsReorderStatus(this._draggedColumn, 'allowed');\n    this._draggedColumn._reorderStatus = 'dragging';\n\n    this._updateGhost(headerCell);\n    this._reorderGhost.style.visibility = 'visible';\n    this._updateGhostPosition(e.detail.x, this._touchDevice ? e.detail.y - 50 : e.detail.y);\n    this._autoScroller();\n  }\n\n  _onTrack(e) {\n    if (!this._draggedColumn) {\n      // Reordering didn’t start. Skip this event.\n      return;\n    }\n\n    const targetCell = this._cellFromPoint(e.detail.x, e.detail.y);\n    if (!targetCell) {\n      return;\n    }\n\n    const targetColumn = this._getTargetColumn(targetCell, this._draggedColumn);\n    if (this._isSwapAllowed(this._draggedColumn, targetColumn) &&\n      this._isSwappableByPosition(targetColumn, e.detail.x)) {\n      this._swapColumnOrders(this._draggedColumn, targetColumn);\n    }\n\n    this._updateGhostPosition(e.detail.x, this._touchDevice ? e.detail.y - 50 : e.detail.y);\n    this._lastDragClientX = e.detail.x;\n  }\n\n  _onTrackEnd() {\n    if (!this._draggedColumn) {\n      // Reordering didn’t start. Skip this event.\n      return;\n    }\n\n    this._toggleAttribute('reordering', false, this);\n    this._draggedColumn._reorderStatus = '';\n    this._setSiblingsReorderStatus(this._draggedColumn, '');\n    this._draggedColumn = null;\n    this._lastDragClientX = null;\n    this._reorderGhost.style.visibility = 'hidden';\n\n    this.dispatchEvent(new CustomEvent('column-reorder', {detail: {\n      columns: this._getColumnsInOrder()\n    }}));\n  }\n\n  _getColumnsInOrder() {\n    return this._columnTree.slice(0).pop()\n      .filter(c => !c.hidden)\n      .sort((b, a) => (b._order - a._order));\n  }\n\n  _cellFromPoint(x, y) {\n    x = x || 0;\n    y = y || 0;\n    if (!this._draggedColumn) {\n      this._toggleAttribute('no-content-pointer-events', true, this.$.scroller);\n    }\n    let cell;\n    if (useShadow) {\n      cell = this.shadowRoot.elementFromPoint(x, y);\n    } else {\n      cell = document.elementFromPoint(x, y);\n\n      // Workaround a FF58 bug\n      if (cell.localName === 'vaadin-grid-cell-content') {\n        cell = cell.assignedSlot.parentNode;\n      }\n\n    }\n    this._toggleAttribute('no-content-pointer-events', false, this.$.scroller);\n\n    // Make sure the element is actually a cell\n    if (cell && cell._column) {\n      return cell;\n    }\n  }\n\n  _updateGhostPosition(eventClientX, eventClientY) {\n    const ghostRect = this._reorderGhost.getBoundingClientRect();\n    // // This is where we want to position the ghost\n    const targetLeft = eventClientX - ghostRect.width / 2;\n    const targetTop = eventClientY - ghostRect.height / 2;\n    // Current position\n    const _left = parseInt(this._reorderGhost._left || 0);\n    const _top = parseInt(this._reorderGhost._top || 0);\n    // Reposition the ghost\n    this._reorderGhost._left = _left - (ghostRect.left - targetLeft);\n    this._reorderGhost._top = _top - (ghostRect.top - targetTop);\n    this._reorderGhost.style.transform = `translate(${this._reorderGhost._left}px, ${this._reorderGhost._top}px)`;\n  }\n\n  _getInnerText(e) {\n    if (e.localName) {\n      // Custom implementation needed since IE11 doesn't respect the spec in case of hidden elements\n      if (getComputedStyle(e).display === 'none') {\n        return '';\n      } else {\n        return Array.from(e.childNodes).map(n => this._getInnerText(n)).join('');\n      }\n    } else {\n      return e.textContent;\n    }\n  }\n\n  _updateGhost(cell) {\n    const ghost = this._reorderGhost;\n    ghost.textContent = this._getInnerText(cell._content);\n    const style = window.getComputedStyle(cell);\n    ['boxSizing', 'display', 'width', 'height', 'background', 'alignItems', 'padding', 'border', 'flex-direction', 'overflow']\n      .forEach(propertyName => ghost.style[propertyName] = style[propertyName]);\n    return ghost;\n  }\n\n  _updateOrders(columnTree, splices) {\n    if (columnTree === undefined || splices === undefined) {\n      return;\n    }\n\n    // Set order numbers to top-level columns\n    columnTree[0].forEach((column, index) => column._order = (index + 1) * this._orderBaseScope);\n  }\n\n  _setSiblingsReorderStatus(column, status) {\n    Array.from(column.parentNode.children)\n      .filter(child => /column/.test(child.localName) && this._isSwapAllowed(child, column))\n      .forEach(sibling => sibling._reorderStatus = status);\n  }\n\n  _autoScroller() {\n    if (this._lastDragClientX) {\n      const rightDiff = this._lastDragClientX - this.getBoundingClientRect().right + 50;\n      const leftDiff = this.getBoundingClientRect().left - this._lastDragClientX + 50;\n\n      if (rightDiff > 0) {\n        this.$.table.scrollLeft += rightDiff / 10;\n      } else if (leftDiff > 0) {\n        this.$.table.scrollLeft -= leftDiff / 10;\n      }\n      this._scrollHandler();\n    }\n\n    if (this._draggedColumn) {\n      this.async(this._autoScroller, 10);\n    }\n  }\n\n  _isSwapAllowed(column1, column2) {\n    if (column1 && column2) {\n      const differentColumns = column1 !== column2;\n      const sameParent = column1.parentElement === column2.parentElement;\n      const sameFrozen = column1.frozen === column2.frozen;\n      return differentColumns && sameParent && sameFrozen;\n    }\n  }\n\n  _isSwappableByPosition(targetColumn, clientX) {\n    const targetCell =\n      Array.from(this.$.header.querySelectorAll('tr:not([hidden]) [part~=\"cell\"]')).filter(cell => targetColumn.contains(cell._column))[0];\n    const sourceCellRect = this.$.header.querySelector('tr:not([hidden]) [reorder-status=dragging]').getBoundingClientRect();\n    const targetRect = targetCell.getBoundingClientRect();\n    if (targetRect.left > sourceCellRect.left) {\n      return clientX > targetRect.right - sourceCellRect.width;\n    } else {\n      return clientX < targetRect.left + sourceCellRect.width;\n    }\n  }\n\n  _swapColumnOrders(column1, column2) {\n    const _order = column1._order;\n    column1._order = column2._order;\n    column2._order = _order;\n    this._updateLastFrozen();\n    this._updateFirstAndLastColumn();\n  }\n\n  _getTargetColumn(targetCell, draggedColumn) {\n    if (targetCell && draggedColumn) {\n      let candidate = targetCell._column;\n      while (candidate.parentElement !== draggedColumn.parentElement && candidate !== this) {\n        candidate = candidate.parentElement;\n      }\n      if (candidate.parentElement === draggedColumn.parentElement) {\n        return candidate;\n      } else {\n        return targetCell._column;\n      }\n    }\n  }\n\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}