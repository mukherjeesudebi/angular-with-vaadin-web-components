{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2016 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { addValueToAttribute, removeValueFromAttribute } from '@vaadin/component-base/src/dom-utils.js';\n\n/**\n * Returns the cells of the given row, excluding the details cell.\n *\n * @param {HTMLTableRowElement} row the table row\n * @return {HTMLTableCellElement[]} array of cells\n */\nexport function getBodyRowCells(row) {\n  // If available, return the cached cells. Otherwise, query the cells directly from the row.\n  return row.__cells || Array.from(row.querySelectorAll('[part~=\"cell\"]:not([part~=\"details-cell\"])'));\n}\n\n/**\n * @param {HTMLElement} container the DOM element with children\n * @param {Function} callback function to call on each child\n */\nexport function iterateChildren(container, callback) {\n  [...container.children].forEach(callback);\n}\n\n/**\n * Iterates over the cells of a row. This includes the details cell if\n * present and any other cell that may be physically detached from the row\n * due to lazy column reordering.\n *\n * @param {HTMLTableRowElement} row the table row\n * @param {Function} callback function to call on each cell\n */\nexport function iterateRowCells(row, callback) {\n  getBodyRowCells(row).forEach(callback);\n  if (row.__detailsCell) {\n    callback(row.__detailsCell);\n  }\n}\n\n/**\n * @param {Array<Object>} columns array of columns to be modified\n * @param {number} scope multiplier added to base order for each column\n * @param {number} baseOrder base number used for order\n */\nexport function updateColumnOrders(columns, scope, baseOrder) {\n  let c = 1;\n  columns.forEach(column => {\n    // Avoid multiples of 10 because they introduce and extra zero and\n    // causes the underlying calculations for child order goes wrong\n    if (c % 10 === 0) {\n      c += 1;\n    }\n    column._order = baseOrder + c * scope;\n    c += 1;\n  });\n}\n\n/**\n * @param {!HTMLElement} element\n * @param {string} attribute\n * @param {boolean | string | null | undefined} value\n */\nexport function updateState(element, attribute, value) {\n  switch (typeof value) {\n    case 'boolean':\n      element.toggleAttribute(attribute, value);\n      break;\n    case 'string':\n      element.setAttribute(attribute, value);\n      break;\n    default:\n      // Value set to null / undefined\n      element.removeAttribute(attribute);\n      break;\n  }\n}\n\n/**\n * @param {!HTMLElement} element\n * @param {boolean | string | null | undefined} value\n * @param {string} part\n */\nexport function updatePart(element, value, part) {\n  if (value || value === '') {\n    addValueToAttribute(element, 'part', part);\n  } else {\n    removeValueFromAttribute(element, 'part', part);\n  }\n}\n\n/**\n * @param {HTMLTableCellElement[]} cells\n * @param {string} part\n * @param {boolean | string | null | undefined} value\n */\nexport function updateCellsPart(cells, part, value) {\n  cells.forEach(cell => {\n    updatePart(cell, value, part);\n  });\n}\n\n/**\n * @param {!HTMLElement} row\n * @param {Object} states\n */\nexport function updateBooleanRowStates(row, states) {\n  const cells = getBodyRowCells(row);\n  Object.entries(states).forEach(([state, value]) => {\n    // Row state attribute\n    updateState(row, state, value);\n    const rowPart = `${state}-row`;\n\n    // Row part attribute\n    updatePart(row, value, rowPart);\n\n    // Cells part attribute\n    updateCellsPart(cells, `${rowPart}-cell`, value);\n  });\n}\n\n/**\n * @param {!HTMLElement} row\n * @param {Object} states\n */\nexport function updateStringRowStates(row, states) {\n  const cells = getBodyRowCells(row);\n  Object.entries(states).forEach(([state, value]) => {\n    const prevValue = row.getAttribute(state);\n\n    // Row state attribute\n    updateState(row, state, value);\n\n    // remove previous part from row and cells if there was any\n    if (prevValue) {\n      const prevRowPart = `${state}-${prevValue}-row`;\n      updatePart(row, false, prevRowPart);\n      updateCellsPart(cells, `${prevRowPart}-cell`, false);\n    }\n\n    // set new part to rows and cells if there is a value\n    if (value) {\n      const rowPart = `${state}-${value}-row`;\n      updatePart(row, value, rowPart);\n      updateCellsPart(cells, `${rowPart}-cell`, value);\n    }\n  });\n}\n\n/**\n * @param {!HTMLElement} cell\n * @param {string} attribute\n * @param {boolean | string | null | undefined} value\n * @param {string} part\n * @param {?string} oldPart\n */\nexport function updateCellState(cell, attribute, value, part, oldPart) {\n  // Toggle state attribute on the cell\n  updateState(cell, attribute, value);\n\n  // Remove old part from the attribute\n  if (oldPart) {\n    updatePart(cell, false, oldPart);\n  }\n\n  // Add new part to the cell attribute\n  updatePart(cell, value, part || `${attribute}-cell`);\n}","map":{"version":3,"names":["addValueToAttribute","removeValueFromAttribute","getBodyRowCells","row","__cells","Array","from","querySelectorAll","iterateChildren","container","callback","children","forEach","iterateRowCells","__detailsCell","updateColumnOrders","columns","scope","baseOrder","c","column","_order","updateState","element","attribute","value","toggleAttribute","setAttribute","removeAttribute","updatePart","part","updateCellsPart","cells","cell","updateBooleanRowStates","states","Object","entries","state","rowPart","updateStringRowStates","prevValue","getAttribute","prevRowPart","updateCellState","oldPart"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@vaadin/grid/src/vaadin-grid-helpers.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2016 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { addValueToAttribute, removeValueFromAttribute } from '@vaadin/component-base/src/dom-utils.js';\n\n/**\n * Returns the cells of the given row, excluding the details cell.\n *\n * @param {HTMLTableRowElement} row the table row\n * @return {HTMLTableCellElement[]} array of cells\n */\nexport function getBodyRowCells(row) {\n  // If available, return the cached cells. Otherwise, query the cells directly from the row.\n  return row.__cells || Array.from(row.querySelectorAll('[part~=\"cell\"]:not([part~=\"details-cell\"])'));\n}\n\n/**\n * @param {HTMLElement} container the DOM element with children\n * @param {Function} callback function to call on each child\n */\nexport function iterateChildren(container, callback) {\n  [...container.children].forEach(callback);\n}\n\n/**\n * Iterates over the cells of a row. This includes the details cell if\n * present and any other cell that may be physically detached from the row\n * due to lazy column reordering.\n *\n * @param {HTMLTableRowElement} row the table row\n * @param {Function} callback function to call on each cell\n */\nexport function iterateRowCells(row, callback) {\n  getBodyRowCells(row).forEach(callback);\n  if (row.__detailsCell) {\n    callback(row.__detailsCell);\n  }\n}\n\n/**\n * @param {Array<Object>} columns array of columns to be modified\n * @param {number} scope multiplier added to base order for each column\n * @param {number} baseOrder base number used for order\n */\nexport function updateColumnOrders(columns, scope, baseOrder) {\n  let c = 1;\n  columns.forEach((column) => {\n    // Avoid multiples of 10 because they introduce and extra zero and\n    // causes the underlying calculations for child order goes wrong\n    if (c % 10 === 0) {\n      c += 1;\n    }\n    column._order = baseOrder + c * scope;\n    c += 1;\n  });\n}\n\n/**\n * @param {!HTMLElement} element\n * @param {string} attribute\n * @param {boolean | string | null | undefined} value\n */\nexport function updateState(element, attribute, value) {\n  switch (typeof value) {\n    case 'boolean':\n      element.toggleAttribute(attribute, value);\n      break;\n    case 'string':\n      element.setAttribute(attribute, value);\n      break;\n    default:\n      // Value set to null / undefined\n      element.removeAttribute(attribute);\n      break;\n  }\n}\n\n/**\n * @param {!HTMLElement} element\n * @param {boolean | string | null | undefined} value\n * @param {string} part\n */\nexport function updatePart(element, value, part) {\n  if (value || value === '') {\n    addValueToAttribute(element, 'part', part);\n  } else {\n    removeValueFromAttribute(element, 'part', part);\n  }\n}\n\n/**\n * @param {HTMLTableCellElement[]} cells\n * @param {string} part\n * @param {boolean | string | null | undefined} value\n */\nexport function updateCellsPart(cells, part, value) {\n  cells.forEach((cell) => {\n    updatePart(cell, value, part);\n  });\n}\n\n/**\n * @param {!HTMLElement} row\n * @param {Object} states\n */\nexport function updateBooleanRowStates(row, states) {\n  const cells = getBodyRowCells(row);\n\n  Object.entries(states).forEach(([state, value]) => {\n    // Row state attribute\n    updateState(row, state, value);\n\n    const rowPart = `${state}-row`;\n\n    // Row part attribute\n    updatePart(row, value, rowPart);\n\n    // Cells part attribute\n    updateCellsPart(cells, `${rowPart}-cell`, value);\n  });\n}\n\n/**\n * @param {!HTMLElement} row\n * @param {Object} states\n */\nexport function updateStringRowStates(row, states) {\n  const cells = getBodyRowCells(row);\n\n  Object.entries(states).forEach(([state, value]) => {\n    const prevValue = row.getAttribute(state);\n\n    // Row state attribute\n    updateState(row, state, value);\n\n    // remove previous part from row and cells if there was any\n    if (prevValue) {\n      const prevRowPart = `${state}-${prevValue}-row`;\n      updatePart(row, false, prevRowPart);\n      updateCellsPart(cells, `${prevRowPart}-cell`, false);\n    }\n\n    // set new part to rows and cells if there is a value\n    if (value) {\n      const rowPart = `${state}-${value}-row`;\n      updatePart(row, value, rowPart);\n      updateCellsPart(cells, `${rowPart}-cell`, value);\n    }\n  });\n}\n\n/**\n * @param {!HTMLElement} cell\n * @param {string} attribute\n * @param {boolean | string | null | undefined} value\n * @param {string} part\n * @param {?string} oldPart\n */\nexport function updateCellState(cell, attribute, value, part, oldPart) {\n  // Toggle state attribute on the cell\n  updateState(cell, attribute, value);\n\n  // Remove old part from the attribute\n  if (oldPart) {\n    updatePart(cell, false, oldPart);\n  }\n\n  // Add new part to the cell attribute\n  updatePart(cell, value, part || `${attribute}-cell`);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}