{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2016 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { isTouch } from '@vaadin/component-base/src/browser-utils.js';\nimport { addListener } from '@vaadin/component-base/src/gestures.js';\nimport { iterateChildren, updateColumnOrders } from './vaadin-grid-helpers.js';\n\n/**\n * @polymerMixin\n */\nexport const ColumnReorderingMixin = superClass => class ColumnReorderingMixin extends superClass {\n  static get properties() {\n    return {\n      /**\n       * Set to true to allow column reordering.\n       * @attr {boolean} column-reordering-allowed\n       * @type {boolean}\n       */\n      columnReorderingAllowed: {\n        type: Boolean,\n        value: false\n      },\n      /** @private */\n      _orderBaseScope: {\n        type: Number,\n        value: 10000000\n      }\n    };\n  }\n  static get observers() {\n    return ['_updateOrders(_columnTree)'];\n  }\n\n  /** @protected */\n  ready() {\n    super.ready();\n    addListener(this, 'track', this._onTrackEvent);\n    this._reorderGhost = this.shadowRoot.querySelector('[part=\"reorder-ghost\"]');\n    this.addEventListener('touchstart', this._onTouchStart.bind(this));\n    this.addEventListener('touchmove', this._onTouchMove.bind(this));\n    this.addEventListener('touchend', this._onTouchEnd.bind(this));\n    this.addEventListener('contextmenu', this._onContextMenu.bind(this));\n  }\n\n  /** @private */\n  _onContextMenu(e) {\n    if (this.hasAttribute('reordering')) {\n      e.preventDefault();\n\n      // A contextmenu event is fired on mobile Chrome on long-press\n      // (which should start reordering). Don't end the reorder on touch devices.\n      if (!isTouch) {\n        // Context menu cancels the track gesture on desktop without firing an end event.\n        // End the reorder manually.\n        this._onTrackEnd();\n      }\n    }\n  }\n\n  /** @private */\n  _onTouchStart(e) {\n    // Touch event, delay activation by 100ms\n    this._startTouchReorderTimeout = setTimeout(() => {\n      this._onTrackStart({\n        detail: {\n          x: e.touches[0].clientX,\n          y: e.touches[0].clientY\n        }\n      });\n    }, 100);\n  }\n\n  /** @private */\n  _onTouchMove(e) {\n    if (this._draggedColumn) {\n      e.preventDefault();\n    }\n    clearTimeout(this._startTouchReorderTimeout);\n  }\n\n  /** @private */\n  _onTouchEnd() {\n    clearTimeout(this._startTouchReorderTimeout);\n    this._onTrackEnd();\n  }\n\n  /** @private */\n  _onTrackEvent(e) {\n    if (e.detail.state === 'start') {\n      const path = e.composedPath();\n      const headerCell = path[path.indexOf(this.$.header) - 2];\n      if (!headerCell || !headerCell._content) {\n        // Not a header column\n        return;\n      }\n      if (headerCell._content.contains(this.getRootNode().activeElement)) {\n        // Something was focused inside the cell\n        return;\n      }\n      if (this.$.scroller.hasAttribute('column-resizing')) {\n        // Resizing is in progress\n        return;\n      }\n      if (!this._touchDevice) {\n        // Not a touch device\n        this._onTrackStart(e);\n      }\n    } else if (e.detail.state === 'track') {\n      this._onTrack(e);\n    } else if (e.detail.state === 'end') {\n      this._onTrackEnd(e);\n    }\n  }\n\n  /** @private */\n  _onTrackStart(e) {\n    if (!this.columnReorderingAllowed) {\n      return;\n    }\n\n    // Cancel reordering if there are draggable nodes on the event path\n    const path = e.composedPath && e.composedPath();\n    if (path && path.some(node => node.hasAttribute && node.hasAttribute('draggable'))) {\n      return;\n    }\n    const headerCell = this._cellFromPoint(e.detail.x, e.detail.y);\n    if (!headerCell || !headerCell.getAttribute('part').includes('header-cell')) {\n      return;\n    }\n    this.toggleAttribute('reordering', true);\n    this._draggedColumn = headerCell._column;\n    while (this._draggedColumn.parentElement.childElementCount === 1) {\n      // This is the only column in the group, drag the whole group instead\n      this._draggedColumn = this._draggedColumn.parentElement;\n    }\n    this._setSiblingsReorderStatus(this._draggedColumn, 'allowed');\n    this._draggedColumn._reorderStatus = 'dragging';\n    this._updateGhost(headerCell);\n    this._reorderGhost.style.visibility = 'visible';\n    this._updateGhostPosition(e.detail.x, this._touchDevice ? e.detail.y - 50 : e.detail.y);\n    this._autoScroller();\n  }\n\n  /** @private */\n  _onTrack(e) {\n    if (!this._draggedColumn) {\n      // Reordering didn't start. Skip this event.\n      return;\n    }\n    const targetCell = this._cellFromPoint(e.detail.x, e.detail.y);\n    if (!targetCell) {\n      return;\n    }\n    const targetColumn = this._getTargetColumn(targetCell, this._draggedColumn);\n    if (this._isSwapAllowed(this._draggedColumn, targetColumn) && this._isSwappableByPosition(targetColumn, e.detail.x)) {\n      // Get the header level of the target column (and the dragged column)\n      const columnTreeLevel = this._columnTree.findIndex(level => level.includes(targetColumn));\n      // Get the columns on that level in visual order\n      const levelColumnsInOrder = this._getColumnsInOrder(columnTreeLevel);\n\n      // Index of the column being dragged\n      const startIndex = levelColumnsInOrder.indexOf(this._draggedColumn);\n      // Index of the column being dragged over\n      const endIndex = levelColumnsInOrder.indexOf(targetColumn);\n\n      // Direction of iteration\n      const direction = startIndex < endIndex ? 1 : -1;\n\n      // Iteratively swap all the columns from the dragged column to the target column\n      for (let i = startIndex; i !== endIndex; i += direction) {\n        this._swapColumnOrders(this._draggedColumn, levelColumnsInOrder[i + direction]);\n      }\n    }\n    this._updateGhostPosition(e.detail.x, this._touchDevice ? e.detail.y - 50 : e.detail.y);\n    this._lastDragClientX = e.detail.x;\n  }\n\n  /** @private */\n  _onTrackEnd() {\n    if (!this._draggedColumn) {\n      // Reordering didn't start. Skip this event.\n      return;\n    }\n    this.toggleAttribute('reordering', false);\n    this._draggedColumn._reorderStatus = '';\n    this._setSiblingsReorderStatus(this._draggedColumn, '');\n    this._draggedColumn = null;\n    this._lastDragClientX = null;\n    this._reorderGhost.style.visibility = 'hidden';\n    this.dispatchEvent(new CustomEvent('column-reorder', {\n      detail: {\n        columns: this._getColumnsInOrder()\n      }\n    }));\n  }\n\n  /**\n   * Returns the columns (or column groups) on the specified header level in visual order.\n   * By default, the bottom level is used.\n   *\n   * @return {!Array<!GridColumn>}\n   * @protected\n   */\n  _getColumnsInOrder(headerLevel = this._columnTree.length - 1) {\n    return this._columnTree[headerLevel].filter(c => !c.hidden).sort((b, a) => b._order - a._order);\n  }\n\n  /**\n   * @param {number} x\n   * @param {number} y\n   * @return {HTMLElement | undefined}\n   * @protected\n   */\n  _cellFromPoint(x = 0, y = 0) {\n    if (!this._draggedColumn) {\n      this.$.scroller.toggleAttribute('no-content-pointer-events', true);\n    }\n    const cell = this.shadowRoot.elementFromPoint(x, y);\n    this.$.scroller.toggleAttribute('no-content-pointer-events', false);\n\n    // Make sure the element is actually a cell\n    if (cell && cell._column) {\n      return cell;\n    }\n  }\n\n  /**\n   * @param {number} eventClientX\n   * @param {number} eventClientY\n   * @protected\n   */\n  _updateGhostPosition(eventClientX, eventClientY) {\n    const ghostRect = this._reorderGhost.getBoundingClientRect();\n    // // This is where we want to position the ghost\n    const targetLeft = eventClientX - ghostRect.width / 2;\n    const targetTop = eventClientY - ghostRect.height / 2;\n    // Current position\n    const _left = parseInt(this._reorderGhost._left || 0);\n    const _top = parseInt(this._reorderGhost._top || 0);\n    // Reposition the ghost\n    this._reorderGhost._left = _left - (ghostRect.left - targetLeft);\n    this._reorderGhost._top = _top - (ghostRect.top - targetTop);\n    this._reorderGhost.style.transform = `translate(${this._reorderGhost._left}px, ${this._reorderGhost._top}px)`;\n  }\n\n  /**\n   * @param {!HTMLElement} cell\n   * @return {!HTMLElement}\n   * @protected\n   */\n  _updateGhost(cell) {\n    const ghost = this._reorderGhost;\n    ghost.textContent = cell._content.innerText;\n    const style = window.getComputedStyle(cell);\n    ['boxSizing', 'display', 'width', 'height', 'background', 'alignItems', 'padding', 'border', 'flex-direction', 'overflow'].forEach(propertyName => {\n      ghost.style[propertyName] = style[propertyName];\n    });\n    return ghost;\n  }\n\n  /** @private */\n  _updateOrders(columnTree) {\n    if (columnTree === undefined) {\n      return;\n    }\n\n    // Reset all column orders\n    columnTree[0].forEach(column => {\n      column._order = 0;\n    });\n    // Set order numbers to top-level columns\n    updateColumnOrders(columnTree[0], this._orderBaseScope, 0);\n  }\n\n  /**\n   * @param {!GridColumn} column\n   * @param {string} status\n   * @protected\n   */\n  _setSiblingsReorderStatus(column, status) {\n    iterateChildren(column.parentNode, sibling => {\n      if (/column/u.test(sibling.localName) && this._isSwapAllowed(sibling, column)) {\n        sibling._reorderStatus = status;\n      }\n    });\n  }\n\n  /** @protected */\n  _autoScroller() {\n    if (this._lastDragClientX) {\n      const rightDiff = this._lastDragClientX - this.getBoundingClientRect().right + 50;\n      const leftDiff = this.getBoundingClientRect().left - this._lastDragClientX + 50;\n      if (rightDiff > 0) {\n        this.$.table.scrollLeft += rightDiff / 10;\n      } else if (leftDiff > 0) {\n        this.$.table.scrollLeft -= leftDiff / 10;\n      }\n    }\n    if (this._draggedColumn) {\n      setTimeout(() => this._autoScroller(), 10);\n    }\n  }\n\n  /**\n   * @param {GridColumn | undefined} column1\n   * @param {GridColumn | undefined} column2\n   * @return {boolean | undefined}\n   * @protected\n   */\n  _isSwapAllowed(column1, column2) {\n    if (column1 && column2) {\n      const differentColumns = column1 !== column2;\n      const sameParent = column1.parentElement === column2.parentElement;\n      const sameFrozen = column1.frozen && column2.frozen ||\n      // Both columns are frozen\n      column1.frozenToEnd && column2.frozenToEnd ||\n      // Both columns are frozen to end\n      !column1.frozen && !column1.frozenToEnd && !column2.frozen && !column2.frozenToEnd;\n      return differentColumns && sameParent && sameFrozen;\n    }\n  }\n\n  /**\n   * @param {!GridColumn} targetColumn\n   * @param {number} clientX\n   * @return {boolean}\n   * @protected\n   */\n  _isSwappableByPosition(targetColumn, clientX) {\n    const targetCell = Array.from(this.$.header.querySelectorAll('tr:not([hidden]) [part~=\"cell\"]')).find(cell => targetColumn.contains(cell._column));\n    const sourceCellRect = this.$.header.querySelector('tr:not([hidden]) [reorder-status=dragging]').getBoundingClientRect();\n    const targetRect = targetCell.getBoundingClientRect();\n    if (targetRect.left > sourceCellRect.left) {\n      return clientX > targetRect.right - sourceCellRect.width;\n    }\n    return clientX < targetRect.left + sourceCellRect.width;\n  }\n\n  /**\n   * @param {!GridColumn} column1\n   * @param {!GridColumn} column2\n   * @protected\n   */\n  _swapColumnOrders(column1, column2) {\n    [column1._order, column2._order] = [column2._order, column1._order];\n    this._debounceUpdateFrozenColumn();\n    this._updateFirstAndLastColumn();\n  }\n\n  /**\n   * @param {HTMLElement | undefined} targetCell\n   * @param {GridColumn} draggedColumn\n   * @return {GridColumn | undefined}\n   * @protected\n   */\n  _getTargetColumn(targetCell, draggedColumn) {\n    if (targetCell && draggedColumn) {\n      let candidate = targetCell._column;\n      while (candidate.parentElement !== draggedColumn.parentElement && candidate !== this) {\n        candidate = candidate.parentElement;\n      }\n      if (candidate.parentElement === draggedColumn.parentElement) {\n        return candidate;\n      }\n      return targetCell._column;\n    }\n  }\n\n  /**\n   * Fired when the columns in the grid are reordered.\n   *\n   * @event column-reorder\n   * @param {Object} detail\n   * @param {Object} detail.columns the columns in the new order\n   */\n};","map":{"version":3,"names":["isTouch","addListener","iterateChildren","updateColumnOrders","ColumnReorderingMixin","superClass","properties","columnReorderingAllowed","type","Boolean","value","_orderBaseScope","Number","observers","ready","_onTrackEvent","_reorderGhost","shadowRoot","querySelector","addEventListener","_onTouchStart","bind","_onTouchMove","_onTouchEnd","_onContextMenu","e","hasAttribute","preventDefault","_onTrackEnd","_startTouchReorderTimeout","setTimeout","_onTrackStart","detail","x","touches","clientX","y","clientY","_draggedColumn","clearTimeout","state","path","composedPath","headerCell","indexOf","$","header","_content","contains","getRootNode","activeElement","scroller","_touchDevice","_onTrack","some","node","_cellFromPoint","getAttribute","includes","toggleAttribute","_column","parentElement","childElementCount","_setSiblingsReorderStatus","_reorderStatus","_updateGhost","style","visibility","_updateGhostPosition","_autoScroller","targetCell","targetColumn","_getTargetColumn","_isSwapAllowed","_isSwappableByPosition","columnTreeLevel","_columnTree","findIndex","level","levelColumnsInOrder","_getColumnsInOrder","startIndex","endIndex","direction","i","_swapColumnOrders","_lastDragClientX","dispatchEvent","CustomEvent","columns","headerLevel","length","filter","c","hidden","sort","b","a","_order","cell","elementFromPoint","eventClientX","eventClientY","ghostRect","getBoundingClientRect","targetLeft","width","targetTop","height","_left","parseInt","_top","left","top","transform","ghost","textContent","innerText","window","getComputedStyle","forEach","propertyName","_updateOrders","columnTree","undefined","column","status","parentNode","sibling","test","localName","rightDiff","right","leftDiff","table","scrollLeft","column1","column2","differentColumns","sameParent","sameFrozen","frozen","frozenToEnd","Array","from","querySelectorAll","find","sourceCellRect","targetRect","_debounceUpdateFrozenColumn","_updateFirstAndLastColumn","draggedColumn","candidate"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@vaadin/grid/src/vaadin-grid-column-reordering-mixin.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2016 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { isTouch } from '@vaadin/component-base/src/browser-utils.js';\nimport { addListener } from '@vaadin/component-base/src/gestures.js';\nimport { iterateChildren, updateColumnOrders } from './vaadin-grid-helpers.js';\n\n/**\n * @polymerMixin\n */\nexport const ColumnReorderingMixin = (superClass) =>\n  class ColumnReorderingMixin extends superClass {\n    static get properties() {\n      return {\n        /**\n         * Set to true to allow column reordering.\n         * @attr {boolean} column-reordering-allowed\n         * @type {boolean}\n         */\n        columnReorderingAllowed: {\n          type: Boolean,\n          value: false,\n        },\n\n        /** @private */\n        _orderBaseScope: {\n          type: Number,\n          value: 10000000,\n        },\n      };\n    }\n\n    static get observers() {\n      return ['_updateOrders(_columnTree)'];\n    }\n\n    /** @protected */\n    ready() {\n      super.ready();\n      addListener(this, 'track', this._onTrackEvent);\n      this._reorderGhost = this.shadowRoot.querySelector('[part=\"reorder-ghost\"]');\n\n      this.addEventListener('touchstart', this._onTouchStart.bind(this));\n      this.addEventListener('touchmove', this._onTouchMove.bind(this));\n      this.addEventListener('touchend', this._onTouchEnd.bind(this));\n      this.addEventListener('contextmenu', this._onContextMenu.bind(this));\n    }\n\n    /** @private */\n    _onContextMenu(e) {\n      if (this.hasAttribute('reordering')) {\n        e.preventDefault();\n\n        // A contextmenu event is fired on mobile Chrome on long-press\n        // (which should start reordering). Don't end the reorder on touch devices.\n        if (!isTouch) {\n          // Context menu cancels the track gesture on desktop without firing an end event.\n          // End the reorder manually.\n          this._onTrackEnd();\n        }\n      }\n    }\n\n    /** @private */\n    _onTouchStart(e) {\n      // Touch event, delay activation by 100ms\n      this._startTouchReorderTimeout = setTimeout(() => {\n        this._onTrackStart({\n          detail: {\n            x: e.touches[0].clientX,\n            y: e.touches[0].clientY,\n          },\n        });\n      }, 100);\n    }\n\n    /** @private */\n    _onTouchMove(e) {\n      if (this._draggedColumn) {\n        e.preventDefault();\n      }\n      clearTimeout(this._startTouchReorderTimeout);\n    }\n\n    /** @private */\n    _onTouchEnd() {\n      clearTimeout(this._startTouchReorderTimeout);\n      this._onTrackEnd();\n    }\n\n    /** @private */\n    _onTrackEvent(e) {\n      if (e.detail.state === 'start') {\n        const path = e.composedPath();\n        const headerCell = path[path.indexOf(this.$.header) - 2];\n        if (!headerCell || !headerCell._content) {\n          // Not a header column\n          return;\n        }\n\n        if (headerCell._content.contains(this.getRootNode().activeElement)) {\n          // Something was focused inside the cell\n          return;\n        }\n\n        if (this.$.scroller.hasAttribute('column-resizing')) {\n          // Resizing is in progress\n          return;\n        }\n\n        if (!this._touchDevice) {\n          // Not a touch device\n          this._onTrackStart(e);\n        }\n      } else if (e.detail.state === 'track') {\n        this._onTrack(e);\n      } else if (e.detail.state === 'end') {\n        this._onTrackEnd(e);\n      }\n    }\n\n    /** @private */\n    _onTrackStart(e) {\n      if (!this.columnReorderingAllowed) {\n        return;\n      }\n\n      // Cancel reordering if there are draggable nodes on the event path\n      const path = e.composedPath && e.composedPath();\n      if (path && path.some((node) => node.hasAttribute && node.hasAttribute('draggable'))) {\n        return;\n      }\n\n      const headerCell = this._cellFromPoint(e.detail.x, e.detail.y);\n      if (!headerCell || !headerCell.getAttribute('part').includes('header-cell')) {\n        return;\n      }\n\n      this.toggleAttribute('reordering', true);\n      this._draggedColumn = headerCell._column;\n      while (this._draggedColumn.parentElement.childElementCount === 1) {\n        // This is the only column in the group, drag the whole group instead\n        this._draggedColumn = this._draggedColumn.parentElement;\n      }\n      this._setSiblingsReorderStatus(this._draggedColumn, 'allowed');\n      this._draggedColumn._reorderStatus = 'dragging';\n\n      this._updateGhost(headerCell);\n      this._reorderGhost.style.visibility = 'visible';\n      this._updateGhostPosition(e.detail.x, this._touchDevice ? e.detail.y - 50 : e.detail.y);\n      this._autoScroller();\n    }\n\n    /** @private */\n    _onTrack(e) {\n      if (!this._draggedColumn) {\n        // Reordering didn't start. Skip this event.\n        return;\n      }\n\n      const targetCell = this._cellFromPoint(e.detail.x, e.detail.y);\n      if (!targetCell) {\n        return;\n      }\n\n      const targetColumn = this._getTargetColumn(targetCell, this._draggedColumn);\n      if (\n        this._isSwapAllowed(this._draggedColumn, targetColumn) &&\n        this._isSwappableByPosition(targetColumn, e.detail.x)\n      ) {\n        // Get the header level of the target column (and the dragged column)\n        const columnTreeLevel = this._columnTree.findIndex((level) => level.includes(targetColumn));\n        // Get the columns on that level in visual order\n        const levelColumnsInOrder = this._getColumnsInOrder(columnTreeLevel);\n\n        // Index of the column being dragged\n        const startIndex = levelColumnsInOrder.indexOf(this._draggedColumn);\n        // Index of the column being dragged over\n        const endIndex = levelColumnsInOrder.indexOf(targetColumn);\n\n        // Direction of iteration\n        const direction = startIndex < endIndex ? 1 : -1;\n\n        // Iteratively swap all the columns from the dragged column to the target column\n        for (let i = startIndex; i !== endIndex; i += direction) {\n          this._swapColumnOrders(this._draggedColumn, levelColumnsInOrder[i + direction]);\n        }\n      }\n\n      this._updateGhostPosition(e.detail.x, this._touchDevice ? e.detail.y - 50 : e.detail.y);\n      this._lastDragClientX = e.detail.x;\n    }\n\n    /** @private */\n    _onTrackEnd() {\n      if (!this._draggedColumn) {\n        // Reordering didn't start. Skip this event.\n        return;\n      }\n\n      this.toggleAttribute('reordering', false);\n      this._draggedColumn._reorderStatus = '';\n      this._setSiblingsReorderStatus(this._draggedColumn, '');\n      this._draggedColumn = null;\n      this._lastDragClientX = null;\n      this._reorderGhost.style.visibility = 'hidden';\n\n      this.dispatchEvent(\n        new CustomEvent('column-reorder', {\n          detail: {\n            columns: this._getColumnsInOrder(),\n          },\n        }),\n      );\n    }\n\n    /**\n     * Returns the columns (or column groups) on the specified header level in visual order.\n     * By default, the bottom level is used.\n     *\n     * @return {!Array<!GridColumn>}\n     * @protected\n     */\n    _getColumnsInOrder(headerLevel = this._columnTree.length - 1) {\n      return this._columnTree[headerLevel].filter((c) => !c.hidden).sort((b, a) => b._order - a._order);\n    }\n\n    /**\n     * @param {number} x\n     * @param {number} y\n     * @return {HTMLElement | undefined}\n     * @protected\n     */\n    _cellFromPoint(x = 0, y = 0) {\n      if (!this._draggedColumn) {\n        this.$.scroller.toggleAttribute('no-content-pointer-events', true);\n      }\n      const cell = this.shadowRoot.elementFromPoint(x, y);\n      this.$.scroller.toggleAttribute('no-content-pointer-events', false);\n\n      // Make sure the element is actually a cell\n      if (cell && cell._column) {\n        return cell;\n      }\n    }\n\n    /**\n     * @param {number} eventClientX\n     * @param {number} eventClientY\n     * @protected\n     */\n    _updateGhostPosition(eventClientX, eventClientY) {\n      const ghostRect = this._reorderGhost.getBoundingClientRect();\n      // // This is where we want to position the ghost\n      const targetLeft = eventClientX - ghostRect.width / 2;\n      const targetTop = eventClientY - ghostRect.height / 2;\n      // Current position\n      const _left = parseInt(this._reorderGhost._left || 0);\n      const _top = parseInt(this._reorderGhost._top || 0);\n      // Reposition the ghost\n      this._reorderGhost._left = _left - (ghostRect.left - targetLeft);\n      this._reorderGhost._top = _top - (ghostRect.top - targetTop);\n      this._reorderGhost.style.transform = `translate(${this._reorderGhost._left}px, ${this._reorderGhost._top}px)`;\n    }\n\n    /**\n     * @param {!HTMLElement} cell\n     * @return {!HTMLElement}\n     * @protected\n     */\n    _updateGhost(cell) {\n      const ghost = this._reorderGhost;\n      ghost.textContent = cell._content.innerText;\n      const style = window.getComputedStyle(cell);\n      [\n        'boxSizing',\n        'display',\n        'width',\n        'height',\n        'background',\n        'alignItems',\n        'padding',\n        'border',\n        'flex-direction',\n        'overflow',\n      ].forEach((propertyName) => {\n        ghost.style[propertyName] = style[propertyName];\n      });\n      return ghost;\n    }\n\n    /** @private */\n    _updateOrders(columnTree) {\n      if (columnTree === undefined) {\n        return;\n      }\n\n      // Reset all column orders\n      columnTree[0].forEach((column) => {\n        column._order = 0;\n      });\n      // Set order numbers to top-level columns\n      updateColumnOrders(columnTree[0], this._orderBaseScope, 0);\n    }\n\n    /**\n     * @param {!GridColumn} column\n     * @param {string} status\n     * @protected\n     */\n    _setSiblingsReorderStatus(column, status) {\n      iterateChildren(column.parentNode, (sibling) => {\n        if (/column/u.test(sibling.localName) && this._isSwapAllowed(sibling, column)) {\n          sibling._reorderStatus = status;\n        }\n      });\n    }\n\n    /** @protected */\n    _autoScroller() {\n      if (this._lastDragClientX) {\n        const rightDiff = this._lastDragClientX - this.getBoundingClientRect().right + 50;\n        const leftDiff = this.getBoundingClientRect().left - this._lastDragClientX + 50;\n\n        if (rightDiff > 0) {\n          this.$.table.scrollLeft += rightDiff / 10;\n        } else if (leftDiff > 0) {\n          this.$.table.scrollLeft -= leftDiff / 10;\n        }\n      }\n\n      if (this._draggedColumn) {\n        setTimeout(() => this._autoScroller(), 10);\n      }\n    }\n\n    /**\n     * @param {GridColumn | undefined} column1\n     * @param {GridColumn | undefined} column2\n     * @return {boolean | undefined}\n     * @protected\n     */\n    _isSwapAllowed(column1, column2) {\n      if (column1 && column2) {\n        const differentColumns = column1 !== column2;\n        const sameParent = column1.parentElement === column2.parentElement;\n        const sameFrozen =\n          (column1.frozen && column2.frozen) || // Both columns are frozen\n          (column1.frozenToEnd && column2.frozenToEnd) || // Both columns are frozen to end\n          (!column1.frozen && !column1.frozenToEnd && !column2.frozen && !column2.frozenToEnd);\n        return differentColumns && sameParent && sameFrozen;\n      }\n    }\n\n    /**\n     * @param {!GridColumn} targetColumn\n     * @param {number} clientX\n     * @return {boolean}\n     * @protected\n     */\n    _isSwappableByPosition(targetColumn, clientX) {\n      const targetCell = Array.from(this.$.header.querySelectorAll('tr:not([hidden]) [part~=\"cell\"]')).find((cell) =>\n        targetColumn.contains(cell._column),\n      );\n      const sourceCellRect = this.$.header\n        .querySelector('tr:not([hidden]) [reorder-status=dragging]')\n        .getBoundingClientRect();\n      const targetRect = targetCell.getBoundingClientRect();\n      if (targetRect.left > sourceCellRect.left) {\n        return clientX > targetRect.right - sourceCellRect.width;\n      }\n      return clientX < targetRect.left + sourceCellRect.width;\n    }\n\n    /**\n     * @param {!GridColumn} column1\n     * @param {!GridColumn} column2\n     * @protected\n     */\n    _swapColumnOrders(column1, column2) {\n      [column1._order, column2._order] = [column2._order, column1._order];\n      this._debounceUpdateFrozenColumn();\n      this._updateFirstAndLastColumn();\n    }\n\n    /**\n     * @param {HTMLElement | undefined} targetCell\n     * @param {GridColumn} draggedColumn\n     * @return {GridColumn | undefined}\n     * @protected\n     */\n    _getTargetColumn(targetCell, draggedColumn) {\n      if (targetCell && draggedColumn) {\n        let candidate = targetCell._column;\n        while (candidate.parentElement !== draggedColumn.parentElement && candidate !== this) {\n          candidate = candidate.parentElement;\n        }\n        if (candidate.parentElement === draggedColumn.parentElement) {\n          return candidate;\n        }\n        return targetCell._column;\n      }\n    }\n\n    /**\n     * Fired when the columns in the grid are reordered.\n     *\n     * @event column-reorder\n     * @param {Object} detail\n     * @param {Object} detail.columns the columns in the new order\n     */\n  };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,SAASA,OAAO,QAAQ,6CAA6C;AACrE,SAASC,WAAW,QAAQ,wCAAwC;AACpE,SAASC,eAAe,EAAEC,kBAAkB,QAAQ,0BAA0B;;AAE9E;AACA;AACA;AACA,OAAO,MAAMC,qBAAqB,GAAIC,UAAU,IAC9C,MAAMD,qBAAqB,SAASC,UAAU,CAAC;EAC7C,WAAWC,UAAUA,CAAA,EAAG;IACtB,OAAO;MACL;AACR;AACA;AACA;AACA;MACQC,uBAAuB,EAAE;QACvBC,IAAI,EAAEC,OAAO;QACbC,KAAK,EAAE;MACT,CAAC;MAED;MACAC,eAAe,EAAE;QACfH,IAAI,EAAEI,MAAM;QACZF,KAAK,EAAE;MACT;IACF,CAAC;EACH;EAEA,WAAWG,SAASA,CAAA,EAAG;IACrB,OAAO,CAAC,4BAA4B,CAAC;EACvC;;EAEA;EACAC,KAAKA,CAAA,EAAG;IACN,KAAK,CAACA,KAAK,CAAC,CAAC;IACbb,WAAW,CAAC,IAAI,EAAE,OAAO,EAAE,IAAI,CAACc,aAAa,CAAC;IAC9C,IAAI,CAACC,aAAa,GAAG,IAAI,CAACC,UAAU,CAACC,aAAa,CAAC,wBAAwB,CAAC;IAE5E,IAAI,CAACC,gBAAgB,CAAC,YAAY,EAAE,IAAI,CAACC,aAAa,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC;IAClE,IAAI,CAACF,gBAAgB,CAAC,WAAW,EAAE,IAAI,CAACG,YAAY,CAACD,IAAI,CAAC,IAAI,CAAC,CAAC;IAChE,IAAI,CAACF,gBAAgB,CAAC,UAAU,EAAE,IAAI,CAACI,WAAW,CAACF,IAAI,CAAC,IAAI,CAAC,CAAC;IAC9D,IAAI,CAACF,gBAAgB,CAAC,aAAa,EAAE,IAAI,CAACK,cAAc,CAACH,IAAI,CAAC,IAAI,CAAC,CAAC;EACtE;;EAEA;EACAG,cAAcA,CAACC,CAAC,EAAE;IAChB,IAAI,IAAI,CAACC,YAAY,CAAC,YAAY,CAAC,EAAE;MACnCD,CAAC,CAACE,cAAc,CAAC,CAAC;;MAElB;MACA;MACA,IAAI,CAAC3B,OAAO,EAAE;QACZ;QACA;QACA,IAAI,CAAC4B,WAAW,CAAC,CAAC;MACpB;IACF;EACF;;EAEA;EACAR,aAAaA,CAACK,CAAC,EAAE;IACf;IACA,IAAI,CAACI,yBAAyB,GAAGC,UAAU,CAAC,MAAM;MAChD,IAAI,CAACC,aAAa,CAAC;QACjBC,MAAM,EAAE;UACNC,CAAC,EAAER,CAAC,CAACS,OAAO,CAAC,CAAC,CAAC,CAACC,OAAO;UACvBC,CAAC,EAAEX,CAAC,CAACS,OAAO,CAAC,CAAC,CAAC,CAACG;QAClB;MACF,CAAC,CAAC;IACJ,CAAC,EAAE,GAAG,CAAC;EACT;;EAEA;EACAf,YAAYA,CAACG,CAAC,EAAE;IACd,IAAI,IAAI,CAACa,cAAc,EAAE;MACvBb,CAAC,CAACE,cAAc,CAAC,CAAC;IACpB;IACAY,YAAY,CAAC,IAAI,CAACV,yBAAyB,CAAC;EAC9C;;EAEA;EACAN,WAAWA,CAAA,EAAG;IACZgB,YAAY,CAAC,IAAI,CAACV,yBAAyB,CAAC;IAC5C,IAAI,CAACD,WAAW,CAAC,CAAC;EACpB;;EAEA;EACAb,aAAaA,CAACU,CAAC,EAAE;IACf,IAAIA,CAAC,CAACO,MAAM,CAACQ,KAAK,KAAK,OAAO,EAAE;MAC9B,MAAMC,IAAI,GAAGhB,CAAC,CAACiB,YAAY,CAAC,CAAC;MAC7B,MAAMC,UAAU,GAAGF,IAAI,CAACA,IAAI,CAACG,OAAO,CAAC,IAAI,CAACC,CAAC,CAACC,MAAM,CAAC,GAAG,CAAC,CAAC;MACxD,IAAI,CAACH,UAAU,IAAI,CAACA,UAAU,CAACI,QAAQ,EAAE;QACvC;QACA;MACF;MAEA,IAAIJ,UAAU,CAACI,QAAQ,CAACC,QAAQ,CAAC,IAAI,CAACC,WAAW,CAAC,CAAC,CAACC,aAAa,CAAC,EAAE;QAClE;QACA;MACF;MAEA,IAAI,IAAI,CAACL,CAAC,CAACM,QAAQ,CAACzB,YAAY,CAAC,iBAAiB,CAAC,EAAE;QACnD;QACA;MACF;MAEA,IAAI,CAAC,IAAI,CAAC0B,YAAY,EAAE;QACtB;QACA,IAAI,CAACrB,aAAa,CAACN,CAAC,CAAC;MACvB;IACF,CAAC,MAAM,IAAIA,CAAC,CAACO,MAAM,CAACQ,KAAK,KAAK,OAAO,EAAE;MACrC,IAAI,CAACa,QAAQ,CAAC5B,CAAC,CAAC;IAClB,CAAC,MAAM,IAAIA,CAAC,CAACO,MAAM,CAACQ,KAAK,KAAK,KAAK,EAAE;MACnC,IAAI,CAACZ,WAAW,CAACH,CAAC,CAAC;IACrB;EACF;;EAEA;EACAM,aAAaA,CAACN,CAAC,EAAE;IACf,IAAI,CAAC,IAAI,CAAClB,uBAAuB,EAAE;MACjC;IACF;;IAEA;IACA,MAAMkC,IAAI,GAAGhB,CAAC,CAACiB,YAAY,IAAIjB,CAAC,CAACiB,YAAY,CAAC,CAAC;IAC/C,IAAID,IAAI,IAAIA,IAAI,CAACa,IAAI,CAAEC,IAAI,IAAKA,IAAI,CAAC7B,YAAY,IAAI6B,IAAI,CAAC7B,YAAY,CAAC,WAAW,CAAC,CAAC,EAAE;MACpF;IACF;IAEA,MAAMiB,UAAU,GAAG,IAAI,CAACa,cAAc,CAAC/B,CAAC,CAACO,MAAM,CAACC,CAAC,EAAER,CAAC,CAACO,MAAM,CAACI,CAAC,CAAC;IAC9D,IAAI,CAACO,UAAU,IAAI,CAACA,UAAU,CAACc,YAAY,CAAC,MAAM,CAAC,CAACC,QAAQ,CAAC,aAAa,CAAC,EAAE;MAC3E;IACF;IAEA,IAAI,CAACC,eAAe,CAAC,YAAY,EAAE,IAAI,CAAC;IACxC,IAAI,CAACrB,cAAc,GAAGK,UAAU,CAACiB,OAAO;IACxC,OAAO,IAAI,CAACtB,cAAc,CAACuB,aAAa,CAACC,iBAAiB,KAAK,CAAC,EAAE;MAChE;MACA,IAAI,CAACxB,cAAc,GAAG,IAAI,CAACA,cAAc,CAACuB,aAAa;IACzD;IACA,IAAI,CAACE,yBAAyB,CAAC,IAAI,CAACzB,cAAc,EAAE,SAAS,CAAC;IAC9D,IAAI,CAACA,cAAc,CAAC0B,cAAc,GAAG,UAAU;IAE/C,IAAI,CAACC,YAAY,CAACtB,UAAU,CAAC;IAC7B,IAAI,CAAC3B,aAAa,CAACkD,KAAK,CAACC,UAAU,GAAG,SAAS;IAC/C,IAAI,CAACC,oBAAoB,CAAC3C,CAAC,CAACO,MAAM,CAACC,CAAC,EAAE,IAAI,CAACmB,YAAY,GAAG3B,CAAC,CAACO,MAAM,CAACI,CAAC,GAAG,EAAE,GAAGX,CAAC,CAACO,MAAM,CAACI,CAAC,CAAC;IACvF,IAAI,CAACiC,aAAa,CAAC,CAAC;EACtB;;EAEA;EACAhB,QAAQA,CAAC5B,CAAC,EAAE;IACV,IAAI,CAAC,IAAI,CAACa,cAAc,EAAE;MACxB;MACA;IACF;IAEA,MAAMgC,UAAU,GAAG,IAAI,CAACd,cAAc,CAAC/B,CAAC,CAACO,MAAM,CAACC,CAAC,EAAER,CAAC,CAACO,MAAM,CAACI,CAAC,CAAC;IAC9D,IAAI,CAACkC,UAAU,EAAE;MACf;IACF;IAEA,MAAMC,YAAY,GAAG,IAAI,CAACC,gBAAgB,CAACF,UAAU,EAAE,IAAI,CAAChC,cAAc,CAAC;IAC3E,IACE,IAAI,CAACmC,cAAc,CAAC,IAAI,CAACnC,cAAc,EAAEiC,YAAY,CAAC,IACtD,IAAI,CAACG,sBAAsB,CAACH,YAAY,EAAE9C,CAAC,CAACO,MAAM,CAACC,CAAC,CAAC,EACrD;MACA;MACA,MAAM0C,eAAe,GAAG,IAAI,CAACC,WAAW,CAACC,SAAS,CAAEC,KAAK,IAAKA,KAAK,CAACpB,QAAQ,CAACa,YAAY,CAAC,CAAC;MAC3F;MACA,MAAMQ,mBAAmB,GAAG,IAAI,CAACC,kBAAkB,CAACL,eAAe,CAAC;;MAEpE;MACA,MAAMM,UAAU,GAAGF,mBAAmB,CAACnC,OAAO,CAAC,IAAI,CAACN,cAAc,CAAC;MACnE;MACA,MAAM4C,QAAQ,GAAGH,mBAAmB,CAACnC,OAAO,CAAC2B,YAAY,CAAC;;MAE1D;MACA,MAAMY,SAAS,GAAGF,UAAU,GAAGC,QAAQ,GAAG,CAAC,GAAG,CAAC,CAAC;;MAEhD;MACA,KAAK,IAAIE,CAAC,GAAGH,UAAU,EAAEG,CAAC,KAAKF,QAAQ,EAAEE,CAAC,IAAID,SAAS,EAAE;QACvD,IAAI,CAACE,iBAAiB,CAAC,IAAI,CAAC/C,cAAc,EAAEyC,mBAAmB,CAACK,CAAC,GAAGD,SAAS,CAAC,CAAC;MACjF;IACF;IAEA,IAAI,CAACf,oBAAoB,CAAC3C,CAAC,CAACO,MAAM,CAACC,CAAC,EAAE,IAAI,CAACmB,YAAY,GAAG3B,CAAC,CAACO,MAAM,CAACI,CAAC,GAAG,EAAE,GAAGX,CAAC,CAACO,MAAM,CAACI,CAAC,CAAC;IACvF,IAAI,CAACkD,gBAAgB,GAAG7D,CAAC,CAACO,MAAM,CAACC,CAAC;EACpC;;EAEA;EACAL,WAAWA,CAAA,EAAG;IACZ,IAAI,CAAC,IAAI,CAACU,cAAc,EAAE;MACxB;MACA;IACF;IAEA,IAAI,CAACqB,eAAe,CAAC,YAAY,EAAE,KAAK,CAAC;IACzC,IAAI,CAACrB,cAAc,CAAC0B,cAAc,GAAG,EAAE;IACvC,IAAI,CAACD,yBAAyB,CAAC,IAAI,CAACzB,cAAc,EAAE,EAAE,CAAC;IACvD,IAAI,CAACA,cAAc,GAAG,IAAI;IAC1B,IAAI,CAACgD,gBAAgB,GAAG,IAAI;IAC5B,IAAI,CAACtE,aAAa,CAACkD,KAAK,CAACC,UAAU,GAAG,QAAQ;IAE9C,IAAI,CAACoB,aAAa,CAChB,IAAIC,WAAW,CAAC,gBAAgB,EAAE;MAChCxD,MAAM,EAAE;QACNyD,OAAO,EAAE,IAAI,CAACT,kBAAkB,CAAC;MACnC;IACF,CAAC,CACH,CAAC;EACH;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIA,kBAAkBA,CAACU,WAAW,GAAG,IAAI,CAACd,WAAW,CAACe,MAAM,GAAG,CAAC,EAAE;IAC5D,OAAO,IAAI,CAACf,WAAW,CAACc,WAAW,CAAC,CAACE,MAAM,CAAEC,CAAC,IAAK,CAACA,CAAC,CAACC,MAAM,CAAC,CAACC,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACE,MAAM,GAAGD,CAAC,CAACC,MAAM,CAAC;EACnG;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACI1C,cAAcA,CAACvB,CAAC,GAAG,CAAC,EAAEG,CAAC,GAAG,CAAC,EAAE;IAC3B,IAAI,CAAC,IAAI,CAACE,cAAc,EAAE;MACxB,IAAI,CAACO,CAAC,CAACM,QAAQ,CAACQ,eAAe,CAAC,2BAA2B,EAAE,IAAI,CAAC;IACpE;IACA,MAAMwC,IAAI,GAAG,IAAI,CAAClF,UAAU,CAACmF,gBAAgB,CAACnE,CAAC,EAAEG,CAAC,CAAC;IACnD,IAAI,CAACS,CAAC,CAACM,QAAQ,CAACQ,eAAe,CAAC,2BAA2B,EAAE,KAAK,CAAC;;IAEnE;IACA,IAAIwC,IAAI,IAAIA,IAAI,CAACvC,OAAO,EAAE;MACxB,OAAOuC,IAAI;IACb;EACF;;EAEA;AACJ;AACA;AACA;AACA;EACI/B,oBAAoBA,CAACiC,YAAY,EAAEC,YAAY,EAAE;IAC/C,MAAMC,SAAS,GAAG,IAAI,CAACvF,aAAa,CAACwF,qBAAqB,CAAC,CAAC;IAC5D;IACA,MAAMC,UAAU,GAAGJ,YAAY,GAAGE,SAAS,CAACG,KAAK,GAAG,CAAC;IACrD,MAAMC,SAAS,GAAGL,YAAY,GAAGC,SAAS,CAACK,MAAM,GAAG,CAAC;IACrD;IACA,MAAMC,KAAK,GAAGC,QAAQ,CAAC,IAAI,CAAC9F,aAAa,CAAC6F,KAAK,IAAI,CAAC,CAAC;IACrD,MAAME,IAAI,GAAGD,QAAQ,CAAC,IAAI,CAAC9F,aAAa,CAAC+F,IAAI,IAAI,CAAC,CAAC;IACnD;IACA,IAAI,CAAC/F,aAAa,CAAC6F,KAAK,GAAGA,KAAK,IAAIN,SAAS,CAACS,IAAI,GAAGP,UAAU,CAAC;IAChE,IAAI,CAACzF,aAAa,CAAC+F,IAAI,GAAGA,IAAI,IAAIR,SAAS,CAACU,GAAG,GAAGN,SAAS,CAAC;IAC5D,IAAI,CAAC3F,aAAa,CAACkD,KAAK,CAACgD,SAAS,GAAI,aAAY,IAAI,CAAClG,aAAa,CAAC6F,KAAM,OAAM,IAAI,CAAC7F,aAAa,CAAC+F,IAAK,KAAI;EAC/G;;EAEA;AACJ;AACA;AACA;AACA;EACI9C,YAAYA,CAACkC,IAAI,EAAE;IACjB,MAAMgB,KAAK,GAAG,IAAI,CAACnG,aAAa;IAChCmG,KAAK,CAACC,WAAW,GAAGjB,IAAI,CAACpD,QAAQ,CAACsE,SAAS;IAC3C,MAAMnD,KAAK,GAAGoD,MAAM,CAACC,gBAAgB,CAACpB,IAAI,CAAC;IAC3C,CACE,WAAW,EACX,SAAS,EACT,OAAO,EACP,QAAQ,EACR,YAAY,EACZ,YAAY,EACZ,SAAS,EACT,QAAQ,EACR,gBAAgB,EAChB,UAAU,CACX,CAACqB,OAAO,CAAEC,YAAY,IAAK;MAC1BN,KAAK,CAACjD,KAAK,CAACuD,YAAY,CAAC,GAAGvD,KAAK,CAACuD,YAAY,CAAC;IACjD,CAAC,CAAC;IACF,OAAON,KAAK;EACd;;EAEA;EACAO,aAAaA,CAACC,UAAU,EAAE;IACxB,IAAIA,UAAU,KAAKC,SAAS,EAAE;MAC5B;IACF;;IAEA;IACAD,UAAU,CAAC,CAAC,CAAC,CAACH,OAAO,CAAEK,MAAM,IAAK;MAChCA,MAAM,CAAC3B,MAAM,GAAG,CAAC;IACnB,CAAC,CAAC;IACF;IACA/F,kBAAkB,CAACwH,UAAU,CAAC,CAAC,CAAC,EAAE,IAAI,CAAChH,eAAe,EAAE,CAAC,CAAC;EAC5D;;EAEA;AACJ;AACA;AACA;AACA;EACIoD,yBAAyBA,CAAC8D,MAAM,EAAEC,MAAM,EAAE;IACxC5H,eAAe,CAAC2H,MAAM,CAACE,UAAU,EAAGC,OAAO,IAAK;MAC9C,IAAI,SAAS,CAACC,IAAI,CAACD,OAAO,CAACE,SAAS,CAAC,IAAI,IAAI,CAACzD,cAAc,CAACuD,OAAO,EAAEH,MAAM,CAAC,EAAE;QAC7EG,OAAO,CAAChE,cAAc,GAAG8D,MAAM;MACjC;IACF,CAAC,CAAC;EACJ;;EAEA;EACAzD,aAAaA,CAAA,EAAG;IACd,IAAI,IAAI,CAACiB,gBAAgB,EAAE;MACzB,MAAM6C,SAAS,GAAG,IAAI,CAAC7C,gBAAgB,GAAG,IAAI,CAACkB,qBAAqB,CAAC,CAAC,CAAC4B,KAAK,GAAG,EAAE;MACjF,MAAMC,QAAQ,GAAG,IAAI,CAAC7B,qBAAqB,CAAC,CAAC,CAACQ,IAAI,GAAG,IAAI,CAAC1B,gBAAgB,GAAG,EAAE;MAE/E,IAAI6C,SAAS,GAAG,CAAC,EAAE;QACjB,IAAI,CAACtF,CAAC,CAACyF,KAAK,CAACC,UAAU,IAAIJ,SAAS,GAAG,EAAE;MAC3C,CAAC,MAAM,IAAIE,QAAQ,GAAG,CAAC,EAAE;QACvB,IAAI,CAACxF,CAAC,CAACyF,KAAK,CAACC,UAAU,IAAIF,QAAQ,GAAG,EAAE;MAC1C;IACF;IAEA,IAAI,IAAI,CAAC/F,cAAc,EAAE;MACvBR,UAAU,CAAC,MAAM,IAAI,CAACuC,aAAa,CAAC,CAAC,EAAE,EAAE,CAAC;IAC5C;EACF;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACII,cAAcA,CAAC+D,OAAO,EAAEC,OAAO,EAAE;IAC/B,IAAID,OAAO,IAAIC,OAAO,EAAE;MACtB,MAAMC,gBAAgB,GAAGF,OAAO,KAAKC,OAAO;MAC5C,MAAME,UAAU,GAAGH,OAAO,CAAC3E,aAAa,KAAK4E,OAAO,CAAC5E,aAAa;MAClE,MAAM+E,UAAU,GACbJ,OAAO,CAACK,MAAM,IAAIJ,OAAO,CAACI,MAAM;MAAK;MACrCL,OAAO,CAACM,WAAW,IAAIL,OAAO,CAACK,WAAY;MAAI;MAC/C,CAACN,OAAO,CAACK,MAAM,IAAI,CAACL,OAAO,CAACM,WAAW,IAAI,CAACL,OAAO,CAACI,MAAM,IAAI,CAACJ,OAAO,CAACK,WAAY;MACtF,OAAOJ,gBAAgB,IAAIC,UAAU,IAAIC,UAAU;IACrD;EACF;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACIlE,sBAAsBA,CAACH,YAAY,EAAEpC,OAAO,EAAE;IAC5C,MAAMmC,UAAU,GAAGyE,KAAK,CAACC,IAAI,CAAC,IAAI,CAACnG,CAAC,CAACC,MAAM,CAACmG,gBAAgB,CAAC,iCAAiC,CAAC,CAAC,CAACC,IAAI,CAAE/C,IAAI,IACzG5B,YAAY,CAACvB,QAAQ,CAACmD,IAAI,CAACvC,OAAO,CACpC,CAAC;IACD,MAAMuF,cAAc,GAAG,IAAI,CAACtG,CAAC,CAACC,MAAM,CACjC5B,aAAa,CAAC,4CAA4C,CAAC,CAC3DsF,qBAAqB,CAAC,CAAC;IAC1B,MAAM4C,UAAU,GAAG9E,UAAU,CAACkC,qBAAqB,CAAC,CAAC;IACrD,IAAI4C,UAAU,CAACpC,IAAI,GAAGmC,cAAc,CAACnC,IAAI,EAAE;MACzC,OAAO7E,OAAO,GAAGiH,UAAU,CAAChB,KAAK,GAAGe,cAAc,CAACzC,KAAK;IAC1D;IACA,OAAOvE,OAAO,GAAGiH,UAAU,CAACpC,IAAI,GAAGmC,cAAc,CAACzC,KAAK;EACzD;;EAEA;AACJ;AACA;AACA;AACA;EACIrB,iBAAiBA,CAACmD,OAAO,EAAEC,OAAO,EAAE;IAClC,CAACD,OAAO,CAACtC,MAAM,EAAEuC,OAAO,CAACvC,MAAM,CAAC,GAAG,CAACuC,OAAO,CAACvC,MAAM,EAAEsC,OAAO,CAACtC,MAAM,CAAC;IACnE,IAAI,CAACmD,2BAA2B,CAAC,CAAC;IAClC,IAAI,CAACC,yBAAyB,CAAC,CAAC;EAClC;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACI9E,gBAAgBA,CAACF,UAAU,EAAEiF,aAAa,EAAE;IAC1C,IAAIjF,UAAU,IAAIiF,aAAa,EAAE;MAC/B,IAAIC,SAAS,GAAGlF,UAAU,CAACV,OAAO;MAClC,OAAO4F,SAAS,CAAC3F,aAAa,KAAK0F,aAAa,CAAC1F,aAAa,IAAI2F,SAAS,KAAK,IAAI,EAAE;QACpFA,SAAS,GAAGA,SAAS,CAAC3F,aAAa;MACrC;MACA,IAAI2F,SAAS,CAAC3F,aAAa,KAAK0F,aAAa,CAAC1F,aAAa,EAAE;QAC3D,OAAO2F,SAAS;MAClB;MACA,OAAOlF,UAAU,CAACV,OAAO;IAC3B;EACF;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACE,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}