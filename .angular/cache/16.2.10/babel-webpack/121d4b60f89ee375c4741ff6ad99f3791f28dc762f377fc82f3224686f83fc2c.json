{"ast":null,"code":"/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '@webcomponents/shadycss/entrypoints/apply-shim.js';\nimport { ElementMixin } from '../mixins/element-mixin.js';\nimport { GestureEventListeners } from '../mixins/gesture-event-listeners.js';\nimport { DirMixin } from '../mixins/dir-mixin.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nimport '../utils/render-status.js';\nimport '../utils/unresolved.js';\nimport { dom, matchesSelector } from './polymer.dom.js';\nimport { setTouchAction } from '../utils/gestures.js';\nimport { Debouncer } from '../utils/debounce.js';\nimport { timeOut, microTask } from '../utils/async.js';\nimport { get } from '../utils/path.js';\nimport { wrap } from '../utils/wrap.js';\nlet styleInterface = window.ShadyCSS;\n\n/**\n * Element class mixin that provides Polymer's \"legacy\" API intended to be\n * backward-compatible to the greatest extent possible with the API\n * found on the Polymer 1.x `Polymer.Base` prototype applied to all elements\n * defined using the `Polymer({...})` function.\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin ElementMixin\n * @appliesMixin GestureEventListeners\n * @property isAttached {boolean} Set to `true` in this element's\n *   `connectedCallback` and `false` in `disconnectedCallback`\n * @summary Element class mixin that provides Polymer's \"legacy\" API\n */\nexport const LegacyElementMixin = dedupingMixin(base => {\n  /**\n   * @constructor\n   * @implements {Polymer_ElementMixin}\n   * @implements {Polymer_GestureEventListeners}\n   * @implements {Polymer_DirMixin}\n   * @extends {HTMLElement}\n   * @private\n   */\n  const legacyElementBase = DirMixin(GestureEventListeners(ElementMixin(base)));\n\n  /**\n   * Map of simple names to touch action names\n   * @dict\n   */\n  const DIRECTION_MAP = {\n    'x': 'pan-x',\n    'y': 'pan-y',\n    'none': 'none',\n    'all': 'auto'\n  };\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @extends {legacyElementBase}\n   * @implements {Polymer_LegacyElementMixin}\n   * @unrestricted\n   */\n  class LegacyElement extends legacyElementBase {\n    constructor() {\n      super();\n      /** @type {boolean} */\n      this.isAttached;\n      /** @type {?WeakMap<!Element, !Object<string, !Function>>} */\n      this.__boundListeners;\n      /** @type {?Object<string, ?Function>} */\n      this._debouncers;\n    }\n\n    /**\n     * Forwards `importMeta` from the prototype (i.e. from the info object\n     * passed to `Polymer({...})`) to the static API.\n     *\n     * @return {!Object} The `import.meta` object set on the prototype\n     * @suppress {missingProperties} `this` is always in the instance in\n     *  closure for some reason even in a static method, rather than the class\n     */\n    static get importMeta() {\n      return this.prototype.importMeta;\n    }\n\n    /**\n     * Legacy callback called during the `constructor`, for overriding\n     * by the user.\n     * @override\n     * @return {void}\n     */\n    created() {}\n\n    /**\n     * Provides an implementation of `connectedCallback`\n     * which adds Polymer legacy API's `attached` method.\n     * @return {void}\n     * @override\n     */\n    connectedCallback() {\n      super.connectedCallback();\n      this.isAttached = true;\n      this.attached();\n    }\n\n    /**\n     * Legacy callback called during `connectedCallback`, for overriding\n     * by the user.\n     * @override\n     * @return {void}\n     */\n    attached() {}\n\n    /**\n     * Provides an implementation of `disconnectedCallback`\n     * which adds Polymer legacy API's `detached` method.\n     * @return {void}\n     * @override\n     */\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      this.isAttached = false;\n      this.detached();\n    }\n\n    /**\n     * Legacy callback called during `disconnectedCallback`, for overriding\n     * by the user.\n     * @override\n     * @return {void}\n     */\n    detached() {}\n\n    /**\n     * Provides an override implementation of `attributeChangedCallback`\n     * which adds the Polymer legacy API's `attributeChanged` method.\n     * @param {string} name Name of attribute.\n     * @param {?string} old Old value of attribute.\n     * @param {?string} value Current value of attribute.\n     * @param {?string} namespace Attribute namespace.\n     * @return {void}\n     * @override\n     */\n    attributeChangedCallback(name, old, value, namespace) {\n      if (old !== value) {\n        super.attributeChangedCallback(name, old, value, namespace);\n        this.attributeChanged(name, old, value);\n      }\n    }\n\n    /**\n     * Legacy callback called during `attributeChangedChallback`, for overriding\n     * by the user.\n     * @param {string} name Name of attribute.\n     * @param {?string} old Old value of attribute.\n     * @param {?string} value Current value of attribute.\n     * @return {void}\n     * @override\n     */\n    attributeChanged(name, old, value) {} // eslint-disable-line no-unused-vars\n\n    /**\n     * Overrides the default `Polymer.PropertyEffects` implementation to\n     * add support for class initialization via the `_registered` callback.\n     * This is called only when the first instance of the element is created.\n     *\n     * @return {void}\n     * @override\n     * @suppress {invalidCasts}\n     */\n    _initializeProperties() {\n      let proto = Object.getPrototypeOf(this);\n      if (!proto.hasOwnProperty('__hasRegisterFinished')) {\n        this._registered();\n        // backstop in case the `_registered` implementation does not set this\n        proto.__hasRegisterFinished = true;\n      }\n      super._initializeProperties();\n      this.root = /** @type {HTMLElement} */this;\n      this.created();\n      // Ensure listeners are applied immediately so that they are\n      // added before declarative event listeners. This allows an element to\n      // decorate itself via an event prior to any declarative listeners\n      // seeing the event. Note, this ensures compatibility with 1.x ordering.\n      this._applyListeners();\n    }\n\n    /**\n     * Called automatically when an element is initializing.\n     * Users may override this method to perform class registration time\n     * work. The implementation should ensure the work is performed\n     * only once for the class.\n     * @protected\n     * @return {void}\n     * @override\n     */\n    _registered() {}\n\n    /**\n     * Overrides the default `Polymer.PropertyEffects` implementation to\n     * add support for installing `hostAttributes` and `listeners`.\n     *\n     * @return {void}\n     * @override\n     */\n    ready() {\n      this._ensureAttributes();\n      super.ready();\n    }\n\n    /**\n     * Ensures an element has required attributes. Called when the element\n     * is being readied via `ready`. Users should override to set the\n     * element's required attributes. The implementation should be sure\n     * to check and not override existing attributes added by\n     * the user of the element. Typically, setting attributes should be left\n     * to the element user and not done here; reasonable exceptions include\n     * setting aria roles and focusability.\n     * @protected\n     * @return {void}\n     * @override\n     */\n    _ensureAttributes() {}\n\n    /**\n     * Adds element event listeners. Called when the element\n     * is being readied via `ready`. Users should override to\n     * add any required element event listeners.\n     * In performance critical elements, the work done here should be kept\n     * to a minimum since it is done before the element is rendered. In\n     * these elements, consider adding listeners asynchronously so as not to\n     * block render.\n     * @protected\n     * @return {void}\n     * @override\n     */\n    _applyListeners() {}\n\n    /**\n     * Converts a typed JavaScript value to a string.\n     *\n     * Note this method is provided as backward-compatible legacy API\n     * only.  It is not directly called by any Polymer features. To customize\n     * how properties are serialized to attributes for attribute bindings and\n     * `reflectToAttribute: true` properties as well as this method, override\n     * the `_serializeValue` method provided by `Polymer.PropertyAccessors`.\n     *\n     * @param {*} value Value to deserialize\n     * @return {string | undefined} Serialized value\n     * @override\n     */\n    serialize(value) {\n      return this._serializeValue(value);\n    }\n\n    /**\n     * Converts a string to a typed JavaScript value.\n     *\n     * Note this method is provided as backward-compatible legacy API\n     * only.  It is not directly called by any Polymer features.  To customize\n     * how attributes are deserialized to properties for in\n     * `attributeChangedCallback`, override `_deserializeValue` method\n     * provided by `Polymer.PropertyAccessors`.\n     *\n     * @param {string} value String to deserialize\n     * @param {*} type Type to deserialize the string to\n     * @return {*} Returns the deserialized value in the `type` given.\n     * @override\n     */\n    deserialize(value, type) {\n      return this._deserializeValue(value, type);\n    }\n\n    /**\n     * Serializes a property to its associated attribute.\n     *\n     * Note this method is provided as backward-compatible legacy API\n     * only.  It is not directly called by any Polymer features.\n     *\n     * @param {string} property Property name to reflect.\n     * @param {string=} attribute Attribute name to reflect.\n     * @param {*=} value Property value to reflect.\n     * @return {void}\n     * @override\n     */\n    reflectPropertyToAttribute(property, attribute, value) {\n      this._propertyToAttribute(property, attribute, value);\n    }\n\n    /**\n     * Sets a typed value to an HTML attribute on a node.\n     *\n     * Note this method is provided as backward-compatible legacy API\n     * only.  It is not directly called by any Polymer features.\n     *\n     * @param {*} value Value to serialize.\n     * @param {string} attribute Attribute name to serialize to.\n     * @param {Element} node Element to set attribute to.\n     * @return {void}\n     * @override\n     */\n    serializeValueToAttribute(value, attribute, node) {\n      this._valueToNodeAttribute( /** @type {Element} */node || this, value, attribute);\n    }\n\n    /**\n     * Copies own properties (including accessor descriptors) from a source\n     * object to a target object.\n     *\n     * @param {Object} prototype Target object to copy properties to.\n     * @param {Object} api Source object to copy properties from.\n     * @return {Object} prototype object that was passed as first argument.\n     * @override\n     */\n    extend(prototype, api) {\n      if (!(prototype && api)) {\n        return prototype || api;\n      }\n      let n$ = Object.getOwnPropertyNames(api);\n      for (let i = 0, n; i < n$.length && (n = n$[i]); i++) {\n        let pd = Object.getOwnPropertyDescriptor(api, n);\n        if (pd) {\n          Object.defineProperty(prototype, n, pd);\n        }\n      }\n      return prototype;\n    }\n\n    /**\n     * Copies props from a source object to a target object.\n     *\n     * Note, this method uses a simple `for...in` strategy for enumerating\n     * properties.  To ensure only `ownProperties` are copied from source\n     * to target and that accessor implementations are copied, use `extend`.\n     *\n     * @param {!Object} target Target object to copy properties to.\n     * @param {!Object} source Source object to copy properties from.\n     * @return {!Object} Target object that was passed as first argument.\n     * @override\n     */\n    mixin(target, source) {\n      for (let i in source) {\n        target[i] = source[i];\n      }\n      return target;\n    }\n\n    /**\n     * Sets the prototype of an object.\n     *\n     * Note this method is provided as backward-compatible legacy API\n     * only.  It is not directly called by any Polymer features.\n     * @param {Object} object The object on which to set the prototype.\n     * @param {Object} prototype The prototype that will be set on the given\n     * `object`.\n     * @return {Object} Returns the given `object` with its prototype set\n     * to the given `prototype` object.\n     * @override\n     */\n    chainObject(object, prototype) {\n      if (object && prototype && object !== prototype) {\n        object.__proto__ = prototype;\n      }\n      return object;\n    }\n\n    /* **** Begin Template **** */\n\n    /**\n     * Calls `importNode` on the `content` of the `template` specified and\n     * returns a document fragment containing the imported content.\n     *\n     * @param {HTMLTemplateElement} template HTML template element to instance.\n     * @return {!DocumentFragment} Document fragment containing the imported\n     *   template content.\n     * @override\n     * @suppress {missingProperties} go/missingfnprops\n     */\n    instanceTemplate(template) {\n      let content = this.constructor._contentForTemplate(template);\n      let dom = /** @type {!DocumentFragment} */\n      document.importNode(content, true);\n      return dom;\n    }\n\n    /* **** Begin Events **** */\n\n    /**\n     * Dispatches a custom event with an optional detail value.\n     *\n     * @param {string} type Name of event type.\n     * @param {*=} detail Detail value containing event-specific\n     *   payload.\n     * @param {{ bubbles: (boolean|undefined), cancelable: (boolean|undefined),\n     *     composed: (boolean|undefined) }=}\n     *  options Object specifying options.  These may include:\n     *  `bubbles` (boolean, defaults to `true`),\n     *  `cancelable` (boolean, defaults to false), and\n     *  `node` on which to fire the event (HTMLElement, defaults to `this`).\n     * @return {!Event} The new event that was fired.\n     * @override\n     */\n    fire(type, detail, options) {\n      options = options || {};\n      detail = detail === null || detail === undefined ? {} : detail;\n      let event = new Event(type, {\n        bubbles: options.bubbles === undefined ? true : options.bubbles,\n        cancelable: Boolean(options.cancelable),\n        composed: options.composed === undefined ? true : options.composed\n      });\n      event.detail = detail;\n      let node = options.node || this;\n      wrap(node).dispatchEvent(event);\n      return event;\n    }\n\n    /**\n     * Convenience method to add an event listener on a given element,\n     * late bound to a named method on this element.\n     *\n     * @param {?EventTarget} node Element to add event listener to.\n     * @param {string} eventName Name of event to listen for.\n     * @param {string} methodName Name of handler method on `this` to call.\n     * @return {void}\n     * @override\n     */\n    listen(node, eventName, methodName) {\n      node = /** @type {!EventTarget} */node || this;\n      let hbl = this.__boundListeners || (this.__boundListeners = new WeakMap());\n      let bl = hbl.get(node);\n      if (!bl) {\n        bl = {};\n        hbl.set(node, bl);\n      }\n      let key = eventName + methodName;\n      if (!bl[key]) {\n        bl[key] = this._addMethodEventListenerToNode( /** @type {!Node} */node, eventName, methodName, this);\n      }\n    }\n\n    /**\n     * Convenience method to remove an event listener from a given element,\n     * late bound to a named method on this element.\n     *\n     * @param {?EventTarget} node Element to remove event listener from.\n     * @param {string} eventName Name of event to stop listening to.\n     * @param {string} methodName Name of handler method on `this` to not call\n     anymore.\n     * @return {void}\n     * @override\n     */\n    unlisten(node, eventName, methodName) {\n      node = /** @type {!EventTarget} */node || this;\n      let bl = this.__boundListeners && this.__boundListeners.get( /** @type {!Element} */node);\n      let key = eventName + methodName;\n      let handler = bl && bl[key];\n      if (handler) {\n        this._removeEventListenerFromNode( /** @type {!Node} */node, eventName, handler);\n        bl[key] = /** @type {?} */null;\n      }\n    }\n\n    /**\n     * Override scrolling behavior to all direction, one direction, or none.\n     *\n     * Valid scroll directions:\n     *   - 'all': scroll in any direction\n     *   - 'x': scroll only in the 'x' direction\n     *   - 'y': scroll only in the 'y' direction\n     *   - 'none': disable scrolling for this node\n     *\n     * @param {string=} direction Direction to allow scrolling\n     * Defaults to `all`.\n     * @param {Element=} node Element to apply scroll direction setting.\n     * Defaults to `this`.\n     * @return {void}\n     * @override\n     */\n    setScrollDirection(direction, node) {\n      setTouchAction( /** @type {!Element} */node || this, DIRECTION_MAP[direction] || 'auto');\n    }\n    /* **** End Events **** */\n\n    /**\n     * Convenience method to run `querySelector` on this local DOM scope.\n     *\n     * This function calls `Polymer.dom(this.root).querySelector(slctr)`.\n     *\n     * @param {string} slctr Selector to run on this local DOM scope\n     * @return {Element} Element found by the selector, or null if not found.\n     * @override\n     */\n    $$(slctr) {\n      // Note, no need to `wrap` this because root is always patched\n      return this.root.querySelector(slctr);\n    }\n\n    /**\n     * Return the element whose local dom within which this element\n     * is contained. This is a shorthand for\n     * `this.getRootNode().host`.\n     * @this {Element}\n     */\n    get domHost() {\n      let root = wrap(this).getRootNode();\n      return root instanceof DocumentFragment ? /** @type {ShadowRoot} */root.host : root;\n    }\n\n    /**\n     * Force this element to distribute its children to its local dom.\n     * This should not be necessary as of Polymer 2.0.2 and is provided only\n     * for backwards compatibility.\n     * @return {void}\n     * @override\n     */\n    distributeContent() {\n      const thisEl = /** @type {Element} */this;\n      const domApi = /** @type {PolymerDomApi} */dom(thisEl);\n      if (window.ShadyDOM && domApi.shadowRoot) {\n        ShadyDOM.flush();\n      }\n    }\n\n    /**\n     * Returns a list of nodes that are the effective childNodes. The effective\n     * childNodes list is the same as the element's childNodes except that\n     * any `<content>` elements are replaced with the list of nodes distributed\n     * to the `<content>`, the result of its `getDistributedNodes` method.\n     * @return {!Array<!Node>} List of effective child nodes.\n     * @suppress {invalidCasts} LegacyElementMixin must be applied to an\n     *     HTMLElement\n     * @override\n     */\n    getEffectiveChildNodes() {\n      const thisEl = /** @type {Element} */this;\n      const domApi = /** @type {PolymerDomApi} */dom(thisEl);\n      return domApi.getEffectiveChildNodes();\n    }\n\n    /**\n     * Returns a list of nodes distributed within this element that match\n     * `selector`. These can be dom children or elements distributed to\n     * children that are insertion points.\n     * @param {string} selector Selector to run.\n     * @return {!Array<!Node>} List of distributed elements that match selector.\n     * @suppress {invalidCasts} LegacyElementMixin must be applied to an\n     * HTMLElement\n     * @override\n     */\n    queryDistributedElements(selector) {\n      const thisEl = /** @type {Element} */this;\n      const domApi = /** @type {PolymerDomApi} */dom(thisEl);\n      return domApi.queryDistributedElements(selector);\n    }\n\n    /**\n     * Returns a list of elements that are the effective children. The effective\n     * children list is the same as the element's children except that\n     * any `<content>` elements are replaced with the list of elements\n     * distributed to the `<content>`.\n     *\n     * @return {!Array<!Node>} List of effective children.\n     * @override\n     */\n    getEffectiveChildren() {\n      let list = this.getEffectiveChildNodes();\n      return list.filter(function ( /** @type {!Node} */n) {\n        return n.nodeType === Node.ELEMENT_NODE;\n      });\n    }\n\n    /**\n     * Returns a string of text content that is the concatenation of the\n     * text content's of the element's effective childNodes (the elements\n     * returned by <a href=\"#getEffectiveChildNodes>getEffectiveChildNodes</a>.\n     *\n     * @return {string} List of effective children.\n     * @override\n     */\n    getEffectiveTextContent() {\n      let cn = this.getEffectiveChildNodes();\n      let tc = [];\n      for (let i = 0, c; c = cn[i]; i++) {\n        if (c.nodeType !== Node.COMMENT_NODE) {\n          tc.push(c.textContent);\n        }\n      }\n      return tc.join('');\n    }\n\n    /**\n     * Returns the first effective childNode within this element that\n     * match `selector`. These can be dom child nodes or elements distributed\n     * to children that are insertion points.\n     * @param {string} selector Selector to run.\n     * @return {Node} First effective child node that matches selector.\n     * @override\n     */\n    queryEffectiveChildren(selector) {\n      let e$ = this.queryDistributedElements(selector);\n      return e$ && e$[0];\n    }\n\n    /**\n     * Returns a list of effective childNodes within this element that\n     * match `selector`. These can be dom child nodes or elements distributed\n     * to children that are insertion points.\n     * @param {string} selector Selector to run.\n     * @return {!Array<!Node>} List of effective child nodes that match\n     *     selector.\n     * @override\n     */\n    queryAllEffectiveChildren(selector) {\n      return this.queryDistributedElements(selector);\n    }\n\n    /**\n     * Returns a list of nodes distributed to this element's `<slot>`.\n     *\n     * If this element contains more than one `<slot>` in its local DOM,\n     * an optional selector may be passed to choose the desired content.\n     *\n     * @param {string=} slctr CSS selector to choose the desired\n     *   `<slot>`.  Defaults to `content`.\n     * @return {!Array<!Node>} List of distributed nodes for the `<slot>`.\n     * @override\n     */\n    getContentChildNodes(slctr) {\n      // Note, no need to `wrap` this because root is always\n      let content = this.root.querySelector(slctr || 'slot');\n      return content ? /** @type {PolymerDomApi} */dom(content).getDistributedNodes() : [];\n    }\n\n    /**\n     * Returns a list of element children distributed to this element's\n     * `<slot>`.\n     *\n     * If this element contains more than one `<slot>` in its\n     * local DOM, an optional selector may be passed to choose the desired\n     * content.  This method differs from `getContentChildNodes` in that only\n     * elements are returned.\n     *\n     * @param {string=} slctr CSS selector to choose the desired\n     *   `<content>`.  Defaults to `content`.\n     * @return {!Array<!HTMLElement>} List of distributed nodes for the\n     *   `<slot>`.\n     * @suppress {invalidCasts}\n     * @override\n     */\n    getContentChildren(slctr) {\n      let children = /** @type {!Array<!HTMLElement>} */this.getContentChildNodes(slctr).filter(function (n) {\n        return n.nodeType === Node.ELEMENT_NODE;\n      });\n      return children;\n    }\n\n    /**\n     * Checks whether an element is in this element's light DOM tree.\n     *\n     * @param {?Node} node The element to be checked.\n     * @return {boolean} true if node is in this element's light DOM tree.\n     * @suppress {invalidCasts} LegacyElementMixin must be applied to an\n     * HTMLElement\n     * @override\n     */\n    isLightDescendant(node) {\n      const thisNode = /** @type {Node} */this;\n      return thisNode !== node && wrap(thisNode).contains(node) && wrap(thisNode).getRootNode() === wrap(node).getRootNode();\n    }\n\n    /**\n     * Checks whether an element is in this element's local DOM tree.\n     *\n     * @param {!Element} node The element to be checked.\n     * @return {boolean} true if node is in this element's local DOM tree.\n     * @override\n     */\n    isLocalDescendant(node) {\n      return this.root === wrap(node).getRootNode();\n    }\n\n    /**\n     * No-op for backwards compatibility. This should now be handled by\n     * ShadyCss library.\n     * @param  {*} container Unused\n     * @param  {*} shouldObserve Unused\n     * @return {void}\n     * @override\n     */\n    scopeSubtree(container, shouldObserve) {// eslint-disable-line no-unused-vars\n    }\n\n    /**\n     * Returns the computed style value for the given property.\n     * @param {string} property The css property name.\n     * @return {string} Returns the computed css property value for the given\n     * `property`.\n     * @suppress {invalidCasts} LegacyElementMixin must be applied to an\n     *     HTMLElement\n     * @override\n     */\n    getComputedStyleValue(property) {\n      return styleInterface.getComputedStyleValue( /** @type {!Element} */this, property);\n    }\n\n    // debounce\n\n    /**\n     * Call `debounce` to collapse multiple requests for a named task into\n     * one invocation which is made after the wait time has elapsed with\n     * no new request.  If no wait time is given, the callback will be called\n     * at microtask timing (guaranteed before paint).\n     *\n     *     debouncedClickAction(e) {\n     *       // will not call `processClick` more than once per 100ms\n     *       this.debounce('click', function() {\n     *        this.processClick();\n     *       } 100);\n     *     }\n     *\n     * @param {string} jobName String to identify the debounce job.\n     * @param {function():void} callback Function that is called (with `this`\n     *   context) when the wait time elapses.\n     * @param {number=} wait Optional wait time in milliseconds (ms) after the\n     *   last signal that must elapse before invoking `callback`\n     * @return {!Object} Returns a debouncer object on which exists the\n     * following methods: `isActive()` returns true if the debouncer is\n     * active; `cancel()` cancels the debouncer if it is active;\n     * `flush()` immediately invokes the debounced callback if the debouncer\n     * is active.\n     * @override\n     */\n    debounce(jobName, callback, wait) {\n      this._debouncers = this._debouncers || {};\n      return this._debouncers[jobName] = Debouncer.debounce(this._debouncers[jobName], wait > 0 ? timeOut.after(wait) : microTask, callback.bind(this));\n    }\n\n    /**\n     * Returns whether a named debouncer is active.\n     *\n     * @param {string} jobName The name of the debouncer started with `debounce`\n     * @return {boolean} Whether the debouncer is active (has not yet fired).\n     * @override\n     */\n    isDebouncerActive(jobName) {\n      this._debouncers = this._debouncers || {};\n      let debouncer = this._debouncers[jobName];\n      return !!(debouncer && debouncer.isActive());\n    }\n\n    /**\n     * Immediately calls the debouncer `callback` and inactivates it.\n     *\n     * @param {string} jobName The name of the debouncer started with `debounce`\n     * @return {void}\n     * @override\n     */\n    flushDebouncer(jobName) {\n      this._debouncers = this._debouncers || {};\n      let debouncer = this._debouncers[jobName];\n      if (debouncer) {\n        debouncer.flush();\n      }\n    }\n\n    /**\n     * Cancels an active debouncer.  The `callback` will not be called.\n     *\n     * @param {string} jobName The name of the debouncer started with `debounce`\n     * @return {void}\n     * @override\n     */\n    cancelDebouncer(jobName) {\n      this._debouncers = this._debouncers || {};\n      let debouncer = this._debouncers[jobName];\n      if (debouncer) {\n        debouncer.cancel();\n      }\n    }\n\n    /**\n     * Runs a callback function asynchronously.\n     *\n     * By default (if no waitTime is specified), async callbacks are run at\n     * microtask timing, which will occur before paint.\n     *\n     * @param {!Function} callback The callback function to run, bound to\n     *     `this`.\n     * @param {number=} waitTime Time to wait before calling the\n     *   `callback`.  If unspecified or 0, the callback will be run at microtask\n     *   timing (before paint).\n     * @return {number} Handle that may be used to cancel the async job.\n     * @override\n     */\n    async(callback, waitTime) {\n      return waitTime > 0 ? timeOut.run(callback.bind(this), waitTime) : ~microTask.run(callback.bind(this));\n    }\n\n    /**\n     * Cancels an async operation started with `async`.\n     *\n     * @param {number} handle Handle returned from original `async` call to\n     *   cancel.\n     * @return {void}\n     * @override\n     */\n    cancelAsync(handle) {\n      handle < 0 ? microTask.cancel(~handle) : timeOut.cancel(handle);\n    }\n\n    // other\n\n    /**\n     * Convenience method for creating an element and configuring it.\n     *\n     * @param {string} tag HTML element tag to create.\n     * @param {Object=} props Object of properties to configure on the\n     *    instance.\n     * @return {!Element} Newly created and configured element.\n     * @override\n     */\n    create(tag, props) {\n      let elt = document.createElement(tag);\n      if (props) {\n        if (elt.setProperties) {\n          elt.setProperties(props);\n        } else {\n          for (let n in props) {\n            elt[n] = props[n];\n          }\n        }\n      }\n      return elt;\n    }\n\n    /**\n     * Polyfill for Element.prototype.matches, which is sometimes still\n     * prefixed.\n     *\n     * @param {string} selector Selector to test.\n     * @param {!Element=} node Element to test the selector against.\n     * @return {boolean} Whether the element matches the selector.\n     * @override\n     */\n    elementMatches(selector, node) {\n      return matchesSelector(node || this, selector);\n    }\n\n    /**\n     * Toggles an HTML attribute on or off.\n     *\n     * @param {string} name HTML attribute name\n     * @param {boolean=} bool Boolean to force the attribute on or off.\n     *    When unspecified, the state of the attribute will be reversed.\n     * @return {boolean} true if the attribute now exists\n     * @override\n     */\n    toggleAttribute(name, bool) {\n      let node = /** @type {Element} */this;\n      if (arguments.length === 3) {\n        node = /** @type {Element} */arguments[2];\n      }\n      if (arguments.length == 1) {\n        bool = !node.hasAttribute(name);\n      }\n      if (bool) {\n        wrap(node).setAttribute(name, '');\n        return true;\n      } else {\n        wrap(node).removeAttribute(name);\n        return false;\n      }\n    }\n\n    /**\n     * Toggles a CSS class on or off.\n     *\n     * @param {string} name CSS class name\n     * @param {boolean=} bool Boolean to force the class on or off.\n     *    When unspecified, the state of the class will be reversed.\n     * @param {Element=} node Node to target.  Defaults to `this`.\n     * @return {void}\n     * @override\n     */\n    toggleClass(name, bool, node) {\n      node = /** @type {Element} */node || this;\n      if (arguments.length == 1) {\n        bool = !node.classList.contains(name);\n      }\n      if (bool) {\n        node.classList.add(name);\n      } else {\n        node.classList.remove(name);\n      }\n    }\n\n    /**\n     * Cross-platform helper for setting an element's CSS `transform` property.\n     *\n     * @param {string} transformText Transform setting.\n     * @param {Element=} node Element to apply the transform to.\n     * Defaults to `this`\n     * @return {void}\n     * @override\n     */\n    transform(transformText, node) {\n      node = /** @type {Element} */node || this;\n      node.style.webkitTransform = transformText;\n      node.style.transform = transformText;\n    }\n\n    /**\n     * Cross-platform helper for setting an element's CSS `translate3d`\n     * property.\n     *\n     * @param {number} x X offset.\n     * @param {number} y Y offset.\n     * @param {number} z Z offset.\n     * @param {Element=} node Element to apply the transform to.\n     * Defaults to `this`.\n     * @return {void}\n     * @override\n     */\n    translate3d(x, y, z, node) {\n      node = /** @type {Element} */node || this;\n      this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);\n    }\n\n    /**\n     * Removes an item from an array, if it exists.\n     *\n     * If the array is specified by path, a change notification is\n     * generated, so that observers, data bindings and computed\n     * properties watching that path can update.\n     *\n     * If the array is passed directly, **no change\n     * notification is generated**.\n     *\n     * @param {string | !Array<number|string>} arrayOrPath Path to array from\n     *     which to remove the item\n     *   (or the array itself).\n     * @param {*} item Item to remove.\n     * @return {Array} Array containing item removed.\n     * @override\n     */\n    arrayDelete(arrayOrPath, item) {\n      let index;\n      if (Array.isArray(arrayOrPath)) {\n        index = arrayOrPath.indexOf(item);\n        if (index >= 0) {\n          return arrayOrPath.splice(index, 1);\n        }\n      } else {\n        let arr = get(this, arrayOrPath);\n        index = arr.indexOf(item);\n        if (index >= 0) {\n          return this.splice(arrayOrPath, index, 1);\n        }\n      }\n      return null;\n    }\n\n    // logging\n\n    /**\n     * Facades `console.log`/`warn`/`error` as override point.\n     *\n     * @param {string} level One of 'log', 'warn', 'error'\n     * @param {Array} args Array of strings or objects to log\n     * @return {void}\n     * @override\n     */\n    _logger(level, args) {\n      // accept ['foo', 'bar'] and [['foo', 'bar']]\n      if (Array.isArray(args) && args.length === 1 && Array.isArray(args[0])) {\n        args = args[0];\n      }\n      switch (level) {\n        case 'log':\n        case 'warn':\n        case 'error':\n          console[level](...args);\n      }\n    }\n\n    /**\n     * Facades `console.log` as an override point.\n     *\n     * @param {...*} args Array of strings or objects to log\n     * @return {void}\n     * @override\n     */\n    _log(...args) {\n      this._logger('log', args);\n    }\n\n    /**\n     * Facades `console.warn` as an override point.\n     *\n     * @param {...*} args Array of strings or objects to log\n     * @return {void}\n     * @override\n     */\n    _warn(...args) {\n      this._logger('warn', args);\n    }\n\n    /**\n     * Facades `console.error` as an override point.\n     *\n     * @param {...*} args Array of strings or objects to log\n     * @return {void}\n     * @override\n     */\n    _error(...args) {\n      this._logger('error', args);\n    }\n\n    /**\n     * Formats a message using the element type an a method name.\n     *\n     * @param {string} methodName Method name to associate with message\n     * @param {...*} args Array of strings or objects to log\n     * @return {Array} Array with formatting information for `console`\n     *   logging.\n     * @override\n     */\n    _logf(methodName, ...args) {\n      return ['[%s::%s]', this.is, methodName, ...args];\n    }\n  }\n  LegacyElement.prototype.is = '';\n  return LegacyElement;\n});","map":{"version":3,"names":["ElementMixin","GestureEventListeners","DirMixin","dedupingMixin","dom","matchesSelector","setTouchAction","Debouncer","timeOut","microTask","get","wrap","styleInterface","window","ShadyCSS","LegacyElementMixin","base","legacyElementBase","DIRECTION_MAP","LegacyElement","constructor","isAttached","__boundListeners","_debouncers","importMeta","prototype","created","connectedCallback","attached","disconnectedCallback","detached","attributeChangedCallback","name","old","value","namespace","attributeChanged","_initializeProperties","proto","Object","getPrototypeOf","hasOwnProperty","_registered","__hasRegisterFinished","root","_applyListeners","ready","_ensureAttributes","serialize","_serializeValue","deserialize","type","_deserializeValue","reflectPropertyToAttribute","property","attribute","_propertyToAttribute","serializeValueToAttribute","node","_valueToNodeAttribute","extend","api","n$","getOwnPropertyNames","i","n","length","pd","getOwnPropertyDescriptor","defineProperty","mixin","target","source","chainObject","object","__proto__","instanceTemplate","template","content","_contentForTemplate","document","importNode","fire","detail","options","undefined","event","Event","bubbles","cancelable","Boolean","composed","dispatchEvent","listen","eventName","methodName","hbl","WeakMap","bl","set","key","_addMethodEventListenerToNode","unlisten","handler","_removeEventListenerFromNode","setScrollDirection","direction","$$","slctr","querySelector","domHost","getRootNode","DocumentFragment","host","distributeContent","thisEl","domApi","ShadyDOM","shadowRoot","flush","getEffectiveChildNodes","queryDistributedElements","selector","getEffectiveChildren","list","filter","nodeType","Node","ELEMENT_NODE","getEffectiveTextContent","cn","tc","c","COMMENT_NODE","push","textContent","join","queryEffectiveChildren","e$","queryAllEffectiveChildren","getContentChildNodes","getDistributedNodes","getContentChildren","children","isLightDescendant","thisNode","contains","isLocalDescendant","scopeSubtree","container","shouldObserve","getComputedStyleValue","debounce","jobName","callback","wait","after","bind","isDebouncerActive","debouncer","isActive","flushDebouncer","cancelDebouncer","cancel","async","waitTime","run","cancelAsync","handle","create","tag","props","elt","createElement","setProperties","elementMatches","toggleAttribute","bool","arguments","hasAttribute","setAttribute","removeAttribute","toggleClass","classList","add","remove","transform","transformText","style","webkitTransform","translate3d","x","y","z","arrayDelete","arrayOrPath","item","index","Array","isArray","indexOf","splice","arr","_logger","level","args","console","_log","_warn","_error","_logf","is"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@polymer/polymer/lib/legacy/legacy-element-mixin.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '@webcomponents/shadycss/entrypoints/apply-shim.js';\nimport { ElementMixin } from '../mixins/element-mixin.js';\nimport { GestureEventListeners } from '../mixins/gesture-event-listeners.js';\nimport { DirMixin } from '../mixins/dir-mixin.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nimport '../utils/render-status.js';\nimport '../utils/unresolved.js';\nimport { dom, matchesSelector } from './polymer.dom.js';\nimport { setTouchAction } from '../utils/gestures.js';\nimport { Debouncer } from '../utils/debounce.js';\nimport { timeOut, microTask } from '../utils/async.js';\nimport { get } from '../utils/path.js';\nimport { wrap } from '../utils/wrap.js';\n\nlet styleInterface = window.ShadyCSS;\n\n/**\n * Element class mixin that provides Polymer's \"legacy\" API intended to be\n * backward-compatible to the greatest extent possible with the API\n * found on the Polymer 1.x `Polymer.Base` prototype applied to all elements\n * defined using the `Polymer({...})` function.\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin ElementMixin\n * @appliesMixin GestureEventListeners\n * @property isAttached {boolean} Set to `true` in this element's\n *   `connectedCallback` and `false` in `disconnectedCallback`\n * @summary Element class mixin that provides Polymer's \"legacy\" API\n */\nexport const LegacyElementMixin = dedupingMixin((base) => {\n  /**\n   * @constructor\n   * @implements {Polymer_ElementMixin}\n   * @implements {Polymer_GestureEventListeners}\n   * @implements {Polymer_DirMixin}\n   * @extends {HTMLElement}\n   * @private\n   */\n  const legacyElementBase = DirMixin(GestureEventListeners(ElementMixin(base)));\n\n  /**\n   * Map of simple names to touch action names\n   * @dict\n   */\n  const DIRECTION_MAP = {\n    'x': 'pan-x',\n    'y': 'pan-y',\n    'none': 'none',\n    'all': 'auto'\n  };\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @extends {legacyElementBase}\n   * @implements {Polymer_LegacyElementMixin}\n   * @unrestricted\n   */\n  class LegacyElement extends legacyElementBase {\n\n    constructor() {\n      super();\n      /** @type {boolean} */\n      this.isAttached;\n      /** @type {?WeakMap<!Element, !Object<string, !Function>>} */\n      this.__boundListeners;\n      /** @type {?Object<string, ?Function>} */\n      this._debouncers;\n    }\n\n    /**\n     * Forwards `importMeta` from the prototype (i.e. from the info object\n     * passed to `Polymer({...})`) to the static API.\n     *\n     * @return {!Object} The `import.meta` object set on the prototype\n     * @suppress {missingProperties} `this` is always in the instance in\n     *  closure for some reason even in a static method, rather than the class\n     */\n    static get importMeta() {\n      return this.prototype.importMeta;\n    }\n\n    /**\n     * Legacy callback called during the `constructor`, for overriding\n     * by the user.\n     * @override\n     * @return {void}\n     */\n    created() {}\n\n    /**\n     * Provides an implementation of `connectedCallback`\n     * which adds Polymer legacy API's `attached` method.\n     * @return {void}\n     * @override\n     */\n    connectedCallback() {\n      super.connectedCallback();\n      this.isAttached = true;\n      this.attached();\n    }\n\n    /**\n     * Legacy callback called during `connectedCallback`, for overriding\n     * by the user.\n     * @override\n     * @return {void}\n     */\n    attached() {}\n\n    /**\n     * Provides an implementation of `disconnectedCallback`\n     * which adds Polymer legacy API's `detached` method.\n     * @return {void}\n     * @override\n     */\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      this.isAttached = false;\n      this.detached();\n    }\n\n    /**\n     * Legacy callback called during `disconnectedCallback`, for overriding\n     * by the user.\n     * @override\n     * @return {void}\n     */\n    detached() {}\n\n    /**\n     * Provides an override implementation of `attributeChangedCallback`\n     * which adds the Polymer legacy API's `attributeChanged` method.\n     * @param {string} name Name of attribute.\n     * @param {?string} old Old value of attribute.\n     * @param {?string} value Current value of attribute.\n     * @param {?string} namespace Attribute namespace.\n     * @return {void}\n     * @override\n     */\n    attributeChangedCallback(name, old, value, namespace) {\n      if (old !== value) {\n        super.attributeChangedCallback(name, old, value, namespace);\n        this.attributeChanged(name, old, value);\n      }\n    }\n\n    /**\n     * Legacy callback called during `attributeChangedChallback`, for overriding\n     * by the user.\n     * @param {string} name Name of attribute.\n     * @param {?string} old Old value of attribute.\n     * @param {?string} value Current value of attribute.\n     * @return {void}\n     * @override\n     */\n    attributeChanged(name, old, value) {} // eslint-disable-line no-unused-vars\n\n    /**\n     * Overrides the default `Polymer.PropertyEffects` implementation to\n     * add support for class initialization via the `_registered` callback.\n     * This is called only when the first instance of the element is created.\n     *\n     * @return {void}\n     * @override\n     * @suppress {invalidCasts}\n     */\n    _initializeProperties() {\n      let proto = Object.getPrototypeOf(this);\n      if (!proto.hasOwnProperty('__hasRegisterFinished')) {\n        this._registered();\n        // backstop in case the `_registered` implementation does not set this\n        proto.__hasRegisterFinished = true;\n      }\n      super._initializeProperties();\n      this.root = /** @type {HTMLElement} */(this);\n      this.created();\n      // Ensure listeners are applied immediately so that they are\n      // added before declarative event listeners. This allows an element to\n      // decorate itself via an event prior to any declarative listeners\n      // seeing the event. Note, this ensures compatibility with 1.x ordering.\n      this._applyListeners();\n    }\n\n    /**\n     * Called automatically when an element is initializing.\n     * Users may override this method to perform class registration time\n     * work. The implementation should ensure the work is performed\n     * only once for the class.\n     * @protected\n     * @return {void}\n     * @override\n     */\n    _registered() {}\n\n    /**\n     * Overrides the default `Polymer.PropertyEffects` implementation to\n     * add support for installing `hostAttributes` and `listeners`.\n     *\n     * @return {void}\n     * @override\n     */\n    ready() {\n      this._ensureAttributes();\n      super.ready();\n    }\n\n    /**\n     * Ensures an element has required attributes. Called when the element\n     * is being readied via `ready`. Users should override to set the\n     * element's required attributes. The implementation should be sure\n     * to check and not override existing attributes added by\n     * the user of the element. Typically, setting attributes should be left\n     * to the element user and not done here; reasonable exceptions include\n     * setting aria roles and focusability.\n     * @protected\n     * @return {void}\n     * @override\n     */\n    _ensureAttributes() {}\n\n    /**\n     * Adds element event listeners. Called when the element\n     * is being readied via `ready`. Users should override to\n     * add any required element event listeners.\n     * In performance critical elements, the work done here should be kept\n     * to a minimum since it is done before the element is rendered. In\n     * these elements, consider adding listeners asynchronously so as not to\n     * block render.\n     * @protected\n     * @return {void}\n     * @override\n     */\n    _applyListeners() {}\n\n    /**\n     * Converts a typed JavaScript value to a string.\n     *\n     * Note this method is provided as backward-compatible legacy API\n     * only.  It is not directly called by any Polymer features. To customize\n     * how properties are serialized to attributes for attribute bindings and\n     * `reflectToAttribute: true` properties as well as this method, override\n     * the `_serializeValue` method provided by `Polymer.PropertyAccessors`.\n     *\n     * @param {*} value Value to deserialize\n     * @return {string | undefined} Serialized value\n     * @override\n     */\n    serialize(value) {\n      return this._serializeValue(value);\n    }\n\n    /**\n     * Converts a string to a typed JavaScript value.\n     *\n     * Note this method is provided as backward-compatible legacy API\n     * only.  It is not directly called by any Polymer features.  To customize\n     * how attributes are deserialized to properties for in\n     * `attributeChangedCallback`, override `_deserializeValue` method\n     * provided by `Polymer.PropertyAccessors`.\n     *\n     * @param {string} value String to deserialize\n     * @param {*} type Type to deserialize the string to\n     * @return {*} Returns the deserialized value in the `type` given.\n     * @override\n     */\n    deserialize(value, type) {\n      return this._deserializeValue(value, type);\n    }\n\n    /**\n     * Serializes a property to its associated attribute.\n     *\n     * Note this method is provided as backward-compatible legacy API\n     * only.  It is not directly called by any Polymer features.\n     *\n     * @param {string} property Property name to reflect.\n     * @param {string=} attribute Attribute name to reflect.\n     * @param {*=} value Property value to reflect.\n     * @return {void}\n     * @override\n     */\n    reflectPropertyToAttribute(property, attribute, value) {\n      this._propertyToAttribute(property, attribute, value);\n    }\n\n    /**\n     * Sets a typed value to an HTML attribute on a node.\n     *\n     * Note this method is provided as backward-compatible legacy API\n     * only.  It is not directly called by any Polymer features.\n     *\n     * @param {*} value Value to serialize.\n     * @param {string} attribute Attribute name to serialize to.\n     * @param {Element} node Element to set attribute to.\n     * @return {void}\n     * @override\n     */\n    serializeValueToAttribute(value, attribute, node) {\n      this._valueToNodeAttribute(/** @type {Element} */ (node || this), value, attribute);\n    }\n\n    /**\n     * Copies own properties (including accessor descriptors) from a source\n     * object to a target object.\n     *\n     * @param {Object} prototype Target object to copy properties to.\n     * @param {Object} api Source object to copy properties from.\n     * @return {Object} prototype object that was passed as first argument.\n     * @override\n     */\n    extend(prototype, api) {\n      if (!(prototype && api)) {\n        return prototype || api;\n      }\n      let n$ = Object.getOwnPropertyNames(api);\n      for (let i=0, n; (i<n$.length) && (n=n$[i]); i++) {\n        let pd = Object.getOwnPropertyDescriptor(api, n);\n        if (pd) {\n          Object.defineProperty(prototype, n, pd);\n        }\n      }\n      return prototype;\n    }\n\n    /**\n     * Copies props from a source object to a target object.\n     *\n     * Note, this method uses a simple `for...in` strategy for enumerating\n     * properties.  To ensure only `ownProperties` are copied from source\n     * to target and that accessor implementations are copied, use `extend`.\n     *\n     * @param {!Object} target Target object to copy properties to.\n     * @param {!Object} source Source object to copy properties from.\n     * @return {!Object} Target object that was passed as first argument.\n     * @override\n     */\n    mixin(target, source) {\n      for (let i in source) {\n        target[i] = source[i];\n      }\n      return target;\n    }\n\n    /**\n     * Sets the prototype of an object.\n     *\n     * Note this method is provided as backward-compatible legacy API\n     * only.  It is not directly called by any Polymer features.\n     * @param {Object} object The object on which to set the prototype.\n     * @param {Object} prototype The prototype that will be set on the given\n     * `object`.\n     * @return {Object} Returns the given `object` with its prototype set\n     * to the given `prototype` object.\n     * @override\n     */\n    chainObject(object, prototype) {\n      if (object && prototype && object !== prototype) {\n        object.__proto__ = prototype;\n      }\n      return object;\n    }\n\n    /* **** Begin Template **** */\n\n    /**\n     * Calls `importNode` on the `content` of the `template` specified and\n     * returns a document fragment containing the imported content.\n     *\n     * @param {HTMLTemplateElement} template HTML template element to instance.\n     * @return {!DocumentFragment} Document fragment containing the imported\n     *   template content.\n     * @override\n     * @suppress {missingProperties} go/missingfnprops\n     */\n    instanceTemplate(template) {\n      let content = this.constructor._contentForTemplate(template);\n      let dom = /** @type {!DocumentFragment} */\n        (document.importNode(content, true));\n      return dom;\n    }\n\n    /* **** Begin Events **** */\n\n\n\n    /**\n     * Dispatches a custom event with an optional detail value.\n     *\n     * @param {string} type Name of event type.\n     * @param {*=} detail Detail value containing event-specific\n     *   payload.\n     * @param {{ bubbles: (boolean|undefined), cancelable: (boolean|undefined),\n     *     composed: (boolean|undefined) }=}\n     *  options Object specifying options.  These may include:\n     *  `bubbles` (boolean, defaults to `true`),\n     *  `cancelable` (boolean, defaults to false), and\n     *  `node` on which to fire the event (HTMLElement, defaults to `this`).\n     * @return {!Event} The new event that was fired.\n     * @override\n     */\n    fire(type, detail, options) {\n      options = options || {};\n      detail = (detail === null || detail === undefined) ? {} : detail;\n      let event = new Event(type, {\n        bubbles: options.bubbles === undefined ? true : options.bubbles,\n        cancelable: Boolean(options.cancelable),\n        composed: options.composed === undefined ? true: options.composed\n      });\n      event.detail = detail;\n      let node = options.node || this;\n      wrap(node).dispatchEvent(event);\n      return event;\n    }\n\n    /**\n     * Convenience method to add an event listener on a given element,\n     * late bound to a named method on this element.\n     *\n     * @param {?EventTarget} node Element to add event listener to.\n     * @param {string} eventName Name of event to listen for.\n     * @param {string} methodName Name of handler method on `this` to call.\n     * @return {void}\n     * @override\n     */\n    listen(node, eventName, methodName) {\n      node = /** @type {!EventTarget} */ (node || this);\n      let hbl = this.__boundListeners ||\n        (this.__boundListeners = new WeakMap());\n      let bl = hbl.get(node);\n      if (!bl) {\n        bl = {};\n        hbl.set(node, bl);\n      }\n      let key = eventName + methodName;\n      if (!bl[key]) {\n        bl[key] = this._addMethodEventListenerToNode(\n            /** @type {!Node} */ (node), eventName, methodName, this);\n      }\n    }\n\n    /**\n     * Convenience method to remove an event listener from a given element,\n     * late bound to a named method on this element.\n     *\n     * @param {?EventTarget} node Element to remove event listener from.\n     * @param {string} eventName Name of event to stop listening to.\n     * @param {string} methodName Name of handler method on `this` to not call\n     anymore.\n     * @return {void}\n     * @override\n     */\n    unlisten(node, eventName, methodName) {\n      node = /** @type {!EventTarget} */ (node || this);\n      let bl = this.__boundListeners &&\n          this.__boundListeners.get(/** @type {!Element} */ (node));\n      let key = eventName + methodName;\n      let handler = bl && bl[key];\n      if (handler) {\n        this._removeEventListenerFromNode(\n            /** @type {!Node} */ (node), eventName, handler);\n        bl[key] = /** @type {?} */ (null);\n      }\n    }\n\n    /**\n     * Override scrolling behavior to all direction, one direction, or none.\n     *\n     * Valid scroll directions:\n     *   - 'all': scroll in any direction\n     *   - 'x': scroll only in the 'x' direction\n     *   - 'y': scroll only in the 'y' direction\n     *   - 'none': disable scrolling for this node\n     *\n     * @param {string=} direction Direction to allow scrolling\n     * Defaults to `all`.\n     * @param {Element=} node Element to apply scroll direction setting.\n     * Defaults to `this`.\n     * @return {void}\n     * @override\n     */\n    setScrollDirection(direction, node) {\n      setTouchAction(\n          /** @type {!Element} */ (node || this),\n          DIRECTION_MAP[direction] || 'auto');\n    }\n    /* **** End Events **** */\n\n    /**\n     * Convenience method to run `querySelector` on this local DOM scope.\n     *\n     * This function calls `Polymer.dom(this.root).querySelector(slctr)`.\n     *\n     * @param {string} slctr Selector to run on this local DOM scope\n     * @return {Element} Element found by the selector, or null if not found.\n     * @override\n     */\n    $$(slctr) {\n      // Note, no need to `wrap` this because root is always patched\n      return this.root.querySelector(slctr);\n    }\n\n    /**\n     * Return the element whose local dom within which this element\n     * is contained. This is a shorthand for\n     * `this.getRootNode().host`.\n     * @this {Element}\n     */\n    get domHost() {\n      let root = wrap(this).getRootNode();\n      return (root instanceof DocumentFragment) ? /** @type {ShadowRoot} */ (root).host : root;\n    }\n\n    /**\n     * Force this element to distribute its children to its local dom.\n     * This should not be necessary as of Polymer 2.0.2 and is provided only\n     * for backwards compatibility.\n     * @return {void}\n     * @override\n     */\n    distributeContent() {\n      const thisEl = /** @type {Element} */ (this);\n      const domApi = /** @type {PolymerDomApi} */(dom(thisEl));\n      if (window.ShadyDOM && domApi.shadowRoot) {\n        ShadyDOM.flush();\n      }\n    }\n\n    /**\n     * Returns a list of nodes that are the effective childNodes. The effective\n     * childNodes list is the same as the element's childNodes except that\n     * any `<content>` elements are replaced with the list of nodes distributed\n     * to the `<content>`, the result of its `getDistributedNodes` method.\n     * @return {!Array<!Node>} List of effective child nodes.\n     * @suppress {invalidCasts} LegacyElementMixin must be applied to an\n     *     HTMLElement\n     * @override\n     */\n    getEffectiveChildNodes() {\n      const thisEl = /** @type {Element} */ (this);\n      const domApi = /** @type {PolymerDomApi} */ (dom(thisEl));\n      return domApi.getEffectiveChildNodes();\n    }\n\n    /**\n     * Returns a list of nodes distributed within this element that match\n     * `selector`. These can be dom children or elements distributed to\n     * children that are insertion points.\n     * @param {string} selector Selector to run.\n     * @return {!Array<!Node>} List of distributed elements that match selector.\n     * @suppress {invalidCasts} LegacyElementMixin must be applied to an\n     * HTMLElement\n     * @override\n     */\n    queryDistributedElements(selector) {\n      const thisEl = /** @type {Element} */ (this);\n      const domApi = /** @type {PolymerDomApi} */ (dom(thisEl));\n      return domApi.queryDistributedElements(selector);\n    }\n\n    /**\n     * Returns a list of elements that are the effective children. The effective\n     * children list is the same as the element's children except that\n     * any `<content>` elements are replaced with the list of elements\n     * distributed to the `<content>`.\n     *\n     * @return {!Array<!Node>} List of effective children.\n     * @override\n     */\n    getEffectiveChildren() {\n      let list = this.getEffectiveChildNodes();\n      return list.filter(function(/** @type {!Node} */ n) {\n        return (n.nodeType === Node.ELEMENT_NODE);\n      });\n    }\n\n    /**\n     * Returns a string of text content that is the concatenation of the\n     * text content's of the element's effective childNodes (the elements\n     * returned by <a href=\"#getEffectiveChildNodes>getEffectiveChildNodes</a>.\n     *\n     * @return {string} List of effective children.\n     * @override\n     */\n    getEffectiveTextContent() {\n      let cn = this.getEffectiveChildNodes();\n      let tc = [];\n      for (let i=0, c; (c = cn[i]); i++) {\n        if (c.nodeType !== Node.COMMENT_NODE) {\n          tc.push(c.textContent);\n        }\n      }\n      return tc.join('');\n    }\n\n    /**\n     * Returns the first effective childNode within this element that\n     * match `selector`. These can be dom child nodes or elements distributed\n     * to children that are insertion points.\n     * @param {string} selector Selector to run.\n     * @return {Node} First effective child node that matches selector.\n     * @override\n     */\n    queryEffectiveChildren(selector) {\n      let e$ = this.queryDistributedElements(selector);\n      return e$ && e$[0];\n    }\n\n    /**\n     * Returns a list of effective childNodes within this element that\n     * match `selector`. These can be dom child nodes or elements distributed\n     * to children that are insertion points.\n     * @param {string} selector Selector to run.\n     * @return {!Array<!Node>} List of effective child nodes that match\n     *     selector.\n     * @override\n     */\n    queryAllEffectiveChildren(selector) {\n      return this.queryDistributedElements(selector);\n    }\n\n    /**\n     * Returns a list of nodes distributed to this element's `<slot>`.\n     *\n     * If this element contains more than one `<slot>` in its local DOM,\n     * an optional selector may be passed to choose the desired content.\n     *\n     * @param {string=} slctr CSS selector to choose the desired\n     *   `<slot>`.  Defaults to `content`.\n     * @return {!Array<!Node>} List of distributed nodes for the `<slot>`.\n     * @override\n     */\n    getContentChildNodes(slctr) {\n      // Note, no need to `wrap` this because root is always\n      let content = this.root.querySelector(slctr || 'slot');\n      return content ?\n          /** @type {PolymerDomApi} */ (dom(content)).getDistributedNodes() :\n          [];\n    }\n\n    /**\n     * Returns a list of element children distributed to this element's\n     * `<slot>`.\n     *\n     * If this element contains more than one `<slot>` in its\n     * local DOM, an optional selector may be passed to choose the desired\n     * content.  This method differs from `getContentChildNodes` in that only\n     * elements are returned.\n     *\n     * @param {string=} slctr CSS selector to choose the desired\n     *   `<content>`.  Defaults to `content`.\n     * @return {!Array<!HTMLElement>} List of distributed nodes for the\n     *   `<slot>`.\n     * @suppress {invalidCasts}\n     * @override\n     */\n    getContentChildren(slctr) {\n      let children = /** @type {!Array<!HTMLElement>} */(this.getContentChildNodes(slctr).filter(function(n) {\n        return (n.nodeType === Node.ELEMENT_NODE);\n      }));\n      return children;\n    }\n\n    /**\n     * Checks whether an element is in this element's light DOM tree.\n     *\n     * @param {?Node} node The element to be checked.\n     * @return {boolean} true if node is in this element's light DOM tree.\n     * @suppress {invalidCasts} LegacyElementMixin must be applied to an\n     * HTMLElement\n     * @override\n     */\n    isLightDescendant(node) {\n      const thisNode = /** @type {Node} */ (this);\n      return thisNode !== node && wrap(thisNode).contains(node) &&\n        wrap(thisNode).getRootNode() === wrap(node).getRootNode();\n    }\n\n    /**\n     * Checks whether an element is in this element's local DOM tree.\n     *\n     * @param {!Element} node The element to be checked.\n     * @return {boolean} true if node is in this element's local DOM tree.\n     * @override\n     */\n    isLocalDescendant(node) {\n      return this.root === wrap(node).getRootNode();\n    }\n\n    /**\n     * No-op for backwards compatibility. This should now be handled by\n     * ShadyCss library.\n     * @param  {*} container Unused\n     * @param  {*} shouldObserve Unused\n     * @return {void}\n     * @override\n     */\n    scopeSubtree(container, shouldObserve) { // eslint-disable-line no-unused-vars\n    }\n\n    /**\n     * Returns the computed style value for the given property.\n     * @param {string} property The css property name.\n     * @return {string} Returns the computed css property value for the given\n     * `property`.\n     * @suppress {invalidCasts} LegacyElementMixin must be applied to an\n     *     HTMLElement\n     * @override\n     */\n    getComputedStyleValue(property) {\n      return styleInterface.getComputedStyleValue(/** @type {!Element} */(this), property);\n    }\n\n    // debounce\n\n    /**\n     * Call `debounce` to collapse multiple requests for a named task into\n     * one invocation which is made after the wait time has elapsed with\n     * no new request.  If no wait time is given, the callback will be called\n     * at microtask timing (guaranteed before paint).\n     *\n     *     debouncedClickAction(e) {\n     *       // will not call `processClick` more than once per 100ms\n     *       this.debounce('click', function() {\n     *        this.processClick();\n     *       } 100);\n     *     }\n     *\n     * @param {string} jobName String to identify the debounce job.\n     * @param {function():void} callback Function that is called (with `this`\n     *   context) when the wait time elapses.\n     * @param {number=} wait Optional wait time in milliseconds (ms) after the\n     *   last signal that must elapse before invoking `callback`\n     * @return {!Object} Returns a debouncer object on which exists the\n     * following methods: `isActive()` returns true if the debouncer is\n     * active; `cancel()` cancels the debouncer if it is active;\n     * `flush()` immediately invokes the debounced callback if the debouncer\n     * is active.\n     * @override\n     */\n    debounce(jobName, callback, wait) {\n      this._debouncers = this._debouncers || {};\n      return this._debouncers[jobName] = Debouncer.debounce(\n            this._debouncers[jobName]\n          , wait > 0 ? timeOut.after(wait) : microTask\n          , callback.bind(this));\n    }\n\n    /**\n     * Returns whether a named debouncer is active.\n     *\n     * @param {string} jobName The name of the debouncer started with `debounce`\n     * @return {boolean} Whether the debouncer is active (has not yet fired).\n     * @override\n     */\n    isDebouncerActive(jobName) {\n      this._debouncers = this._debouncers || {};\n      let debouncer = this._debouncers[jobName];\n      return !!(debouncer && debouncer.isActive());\n    }\n\n    /**\n     * Immediately calls the debouncer `callback` and inactivates it.\n     *\n     * @param {string} jobName The name of the debouncer started with `debounce`\n     * @return {void}\n     * @override\n     */\n    flushDebouncer(jobName) {\n      this._debouncers = this._debouncers || {};\n      let debouncer = this._debouncers[jobName];\n      if (debouncer) {\n        debouncer.flush();\n      }\n    }\n\n    /**\n     * Cancels an active debouncer.  The `callback` will not be called.\n     *\n     * @param {string} jobName The name of the debouncer started with `debounce`\n     * @return {void}\n     * @override\n     */\n    cancelDebouncer(jobName) {\n      this._debouncers = this._debouncers || {};\n      let debouncer = this._debouncers[jobName];\n      if (debouncer) {\n        debouncer.cancel();\n      }\n    }\n\n    /**\n     * Runs a callback function asynchronously.\n     *\n     * By default (if no waitTime is specified), async callbacks are run at\n     * microtask timing, which will occur before paint.\n     *\n     * @param {!Function} callback The callback function to run, bound to\n     *     `this`.\n     * @param {number=} waitTime Time to wait before calling the\n     *   `callback`.  If unspecified or 0, the callback will be run at microtask\n     *   timing (before paint).\n     * @return {number} Handle that may be used to cancel the async job.\n     * @override\n     */\n    async(callback, waitTime) {\n      return waitTime > 0 ? timeOut.run(callback.bind(this), waitTime) :\n          ~microTask.run(callback.bind(this));\n    }\n\n    /**\n     * Cancels an async operation started with `async`.\n     *\n     * @param {number} handle Handle returned from original `async` call to\n     *   cancel.\n     * @return {void}\n     * @override\n     */\n    cancelAsync(handle) {\n      handle < 0 ? microTask.cancel(~handle) :\n          timeOut.cancel(handle);\n    }\n\n    // other\n\n    /**\n     * Convenience method for creating an element and configuring it.\n     *\n     * @param {string} tag HTML element tag to create.\n     * @param {Object=} props Object of properties to configure on the\n     *    instance.\n     * @return {!Element} Newly created and configured element.\n     * @override\n     */\n    create(tag, props) {\n      let elt = document.createElement(tag);\n      if (props) {\n        if (elt.setProperties) {\n          elt.setProperties(props);\n        } else {\n          for (let n in props) {\n            elt[n] = props[n];\n          }\n        }\n      }\n      return elt;\n    }\n\n    /**\n     * Polyfill for Element.prototype.matches, which is sometimes still\n     * prefixed.\n     *\n     * @param {string} selector Selector to test.\n     * @param {!Element=} node Element to test the selector against.\n     * @return {boolean} Whether the element matches the selector.\n     * @override\n     */\n    elementMatches(selector, node) {\n      return matchesSelector( (node || this), selector);\n    }\n\n    /**\n     * Toggles an HTML attribute on or off.\n     *\n     * @param {string} name HTML attribute name\n     * @param {boolean=} bool Boolean to force the attribute on or off.\n     *    When unspecified, the state of the attribute will be reversed.\n     * @return {boolean} true if the attribute now exists\n     * @override\n     */\n    toggleAttribute(name, bool) {\n      let node = /** @type {Element} */(this);\n      if (arguments.length === 3) {\n        node = /** @type {Element} */(arguments[2]);\n      }\n      if (arguments.length == 1) {\n        bool = !node.hasAttribute(name);\n      }\n      if (bool) {\n        wrap(node).setAttribute(name, '');\n        return true;\n      } else {\n        wrap(node).removeAttribute(name);\n        return false;\n      }\n    }\n\n\n    /**\n     * Toggles a CSS class on or off.\n     *\n     * @param {string} name CSS class name\n     * @param {boolean=} bool Boolean to force the class on or off.\n     *    When unspecified, the state of the class will be reversed.\n     * @param {Element=} node Node to target.  Defaults to `this`.\n     * @return {void}\n     * @override\n     */\n    toggleClass(name, bool, node) {\n      node = /** @type {Element} */ (node || this);\n      if (arguments.length == 1) {\n        bool = !node.classList.contains(name);\n      }\n      if (bool) {\n        node.classList.add(name);\n      } else {\n        node.classList.remove(name);\n      }\n    }\n\n    /**\n     * Cross-platform helper for setting an element's CSS `transform` property.\n     *\n     * @param {string} transformText Transform setting.\n     * @param {Element=} node Element to apply the transform to.\n     * Defaults to `this`\n     * @return {void}\n     * @override\n     */\n    transform(transformText, node) {\n      node = /** @type {Element} */ (node || this);\n      node.style.webkitTransform = transformText;\n      node.style.transform = transformText;\n    }\n\n    /**\n     * Cross-platform helper for setting an element's CSS `translate3d`\n     * property.\n     *\n     * @param {number} x X offset.\n     * @param {number} y Y offset.\n     * @param {number} z Z offset.\n     * @param {Element=} node Element to apply the transform to.\n     * Defaults to `this`.\n     * @return {void}\n     * @override\n     */\n    translate3d(x, y, z, node) {\n      node = /** @type {Element} */ (node || this);\n      this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);\n    }\n\n    /**\n     * Removes an item from an array, if it exists.\n     *\n     * If the array is specified by path, a change notification is\n     * generated, so that observers, data bindings and computed\n     * properties watching that path can update.\n     *\n     * If the array is passed directly, **no change\n     * notification is generated**.\n     *\n     * @param {string | !Array<number|string>} arrayOrPath Path to array from\n     *     which to remove the item\n     *   (or the array itself).\n     * @param {*} item Item to remove.\n     * @return {Array} Array containing item removed.\n     * @override\n     */\n    arrayDelete(arrayOrPath, item) {\n      let index;\n      if (Array.isArray(arrayOrPath)) {\n        index = arrayOrPath.indexOf(item);\n        if (index >= 0) {\n          return arrayOrPath.splice(index, 1);\n        }\n      } else {\n        let arr = get(this, arrayOrPath);\n        index = arr.indexOf(item);\n        if (index >= 0) {\n          return this.splice(arrayOrPath, index, 1);\n        }\n      }\n      return null;\n    }\n\n    // logging\n\n    /**\n     * Facades `console.log`/`warn`/`error` as override point.\n     *\n     * @param {string} level One of 'log', 'warn', 'error'\n     * @param {Array} args Array of strings or objects to log\n     * @return {void}\n     * @override\n     */\n    _logger(level, args) {\n      // accept ['foo', 'bar'] and [['foo', 'bar']]\n      if (Array.isArray(args) && args.length === 1 && Array.isArray(args[0])) {\n        args = args[0];\n      }\n      switch(level) {\n        case 'log':\n        case 'warn':\n        case 'error':\n          console[level](...args);\n      }\n    }\n\n    /**\n     * Facades `console.log` as an override point.\n     *\n     * @param {...*} args Array of strings or objects to log\n     * @return {void}\n     * @override\n     */\n    _log(...args) {\n      this._logger('log', args);\n    }\n\n    /**\n     * Facades `console.warn` as an override point.\n     *\n     * @param {...*} args Array of strings or objects to log\n     * @return {void}\n     * @override\n     */\n    _warn(...args) {\n      this._logger('warn', args);\n    }\n\n    /**\n     * Facades `console.error` as an override point.\n     *\n     * @param {...*} args Array of strings or objects to log\n     * @return {void}\n     * @override\n     */\n    _error(...args) {\n      this._logger('error', args);\n    }\n\n    /**\n     * Formats a message using the element type an a method name.\n     *\n     * @param {string} methodName Method name to associate with message\n     * @param {...*} args Array of strings or objects to log\n     * @return {Array} Array with formatting information for `console`\n     *   logging.\n     * @override\n     */\n    _logf(methodName, ...args) {\n      return ['[%s::%s]', this.is, methodName, ...args];\n    }\n\n  }\n\n  LegacyElement.prototype.is = '';\n\n  return LegacyElement;\n});\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,mDAAmD;AAC1D,SAASA,YAAY,QAAQ,4BAA4B;AACzD,SAASC,qBAAqB,QAAQ,sCAAsC;AAC5E,SAASC,QAAQ,QAAQ,wBAAwB;AACjD,SAASC,aAAa,QAAQ,mBAAmB;AACjD,OAAO,2BAA2B;AAClC,OAAO,wBAAwB;AAC/B,SAASC,GAAG,EAAEC,eAAe,QAAQ,kBAAkB;AACvD,SAASC,cAAc,QAAQ,sBAAsB;AACrD,SAASC,SAAS,QAAQ,sBAAsB;AAChD,SAASC,OAAO,EAAEC,SAAS,QAAQ,mBAAmB;AACtD,SAASC,GAAG,QAAQ,kBAAkB;AACtC,SAASC,IAAI,QAAQ,kBAAkB;AAEvC,IAAIC,cAAc,GAAGC,MAAM,CAACC,QAAQ;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,kBAAkB,GAAGZ,aAAa,CAAEa,IAAI,IAAK;EACxD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMC,iBAAiB,GAAGf,QAAQ,CAACD,qBAAqB,CAACD,YAAY,CAACgB,IAAI,CAAC,CAAC,CAAC;;EAE7E;AACF;AACA;AACA;EACE,MAAME,aAAa,GAAG;IACpB,GAAG,EAAE,OAAO;IACZ,GAAG,EAAE,OAAO;IACZ,MAAM,EAAE,MAAM;IACd,KAAK,EAAE;EACT,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACE,MAAMC,aAAa,SAASF,iBAAiB,CAAC;IAE5CG,WAAWA,CAAA,EAAG;MACZ,KAAK,CAAC,CAAC;MACP;MACA,IAAI,CAACC,UAAU;MACf;MACA,IAAI,CAACC,gBAAgB;MACrB;MACA,IAAI,CAACC,WAAW;IAClB;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IACI,WAAWC,UAAUA,CAAA,EAAG;MACtB,OAAO,IAAI,CAACC,SAAS,CAACD,UAAU;IAClC;;IAEA;AACJ;AACA;AACA;AACA;AACA;IACIE,OAAOA,CAAA,EAAG,CAAC;;IAEX;AACJ;AACA;AACA;AACA;AACA;IACIC,iBAAiBA,CAAA,EAAG;MAClB,KAAK,CAACA,iBAAiB,CAAC,CAAC;MACzB,IAAI,CAACN,UAAU,GAAG,IAAI;MACtB,IAAI,CAACO,QAAQ,CAAC,CAAC;IACjB;;IAEA;AACJ;AACA;AACA;AACA;AACA;IACIA,QAAQA,CAAA,EAAG,CAAC;;IAEZ;AACJ;AACA;AACA;AACA;AACA;IACIC,oBAAoBA,CAAA,EAAG;MACrB,KAAK,CAACA,oBAAoB,CAAC,CAAC;MAC5B,IAAI,CAACR,UAAU,GAAG,KAAK;MACvB,IAAI,CAACS,QAAQ,CAAC,CAAC;IACjB;;IAEA;AACJ;AACA;AACA;AACA;AACA;IACIA,QAAQA,CAAA,EAAG,CAAC;;IAEZ;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIC,wBAAwBA,CAACC,IAAI,EAAEC,GAAG,EAAEC,KAAK,EAAEC,SAAS,EAAE;MACpD,IAAIF,GAAG,KAAKC,KAAK,EAAE;QACjB,KAAK,CAACH,wBAAwB,CAACC,IAAI,EAAEC,GAAG,EAAEC,KAAK,EAAEC,SAAS,CAAC;QAC3D,IAAI,CAACC,gBAAgB,CAACJ,IAAI,EAAEC,GAAG,EAAEC,KAAK,CAAC;MACzC;IACF;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIE,gBAAgBA,CAACJ,IAAI,EAAEC,GAAG,EAAEC,KAAK,EAAE,CAAC,CAAC,CAAC;;IAEtC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIG,qBAAqBA,CAAA,EAAG;MACtB,IAAIC,KAAK,GAAGC,MAAM,CAACC,cAAc,CAAC,IAAI,CAAC;MACvC,IAAI,CAACF,KAAK,CAACG,cAAc,CAAC,uBAAuB,CAAC,EAAE;QAClD,IAAI,CAACC,WAAW,CAAC,CAAC;QAClB;QACAJ,KAAK,CAACK,qBAAqB,GAAG,IAAI;MACpC;MACA,KAAK,CAACN,qBAAqB,CAAC,CAAC;MAC7B,IAAI,CAACO,IAAI,GAAG,0BAA2B,IAAK;MAC5C,IAAI,CAAClB,OAAO,CAAC,CAAC;MACd;MACA;MACA;MACA;MACA,IAAI,CAACmB,eAAe,CAAC,CAAC;IACxB;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIH,WAAWA,CAAA,EAAG,CAAC;;IAEf;AACJ;AACA;AACA;AACA;AACA;AACA;IACII,KAAKA,CAAA,EAAG;MACN,IAAI,CAACC,iBAAiB,CAAC,CAAC;MACxB,KAAK,CAACD,KAAK,CAAC,CAAC;IACf;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIC,iBAAiBA,CAAA,EAAG,CAAC;;IAErB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIF,eAAeA,CAAA,EAAG,CAAC;;IAEnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIG,SAASA,CAACd,KAAK,EAAE;MACf,OAAO,IAAI,CAACe,eAAe,CAACf,KAAK,CAAC;IACpC;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIgB,WAAWA,CAAChB,KAAK,EAAEiB,IAAI,EAAE;MACvB,OAAO,IAAI,CAACC,iBAAiB,CAAClB,KAAK,EAAEiB,IAAI,CAAC;IAC5C;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIE,0BAA0BA,CAACC,QAAQ,EAAEC,SAAS,EAAErB,KAAK,EAAE;MACrD,IAAI,CAACsB,oBAAoB,CAACF,QAAQ,EAAEC,SAAS,EAAErB,KAAK,CAAC;IACvD;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIuB,yBAAyBA,CAACvB,KAAK,EAAEqB,SAAS,EAAEG,IAAI,EAAE;MAChD,IAAI,CAACC,qBAAqB,EAAC,sBAAwBD,IAAI,IAAI,IAAI,EAAGxB,KAAK,EAAEqB,SAAS,CAAC;IACrF;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIK,MAAMA,CAACnC,SAAS,EAAEoC,GAAG,EAAE;MACrB,IAAI,EAAEpC,SAAS,IAAIoC,GAAG,CAAC,EAAE;QACvB,OAAOpC,SAAS,IAAIoC,GAAG;MACzB;MACA,IAAIC,EAAE,GAAGvB,MAAM,CAACwB,mBAAmB,CAACF,GAAG,CAAC;MACxC,KAAK,IAAIG,CAAC,GAAC,CAAC,EAAEC,CAAC,EAAGD,CAAC,GAACF,EAAE,CAACI,MAAM,KAAMD,CAAC,GAACH,EAAE,CAACE,CAAC,CAAC,CAAC,EAAEA,CAAC,EAAE,EAAE;QAChD,IAAIG,EAAE,GAAG5B,MAAM,CAAC6B,wBAAwB,CAACP,GAAG,EAAEI,CAAC,CAAC;QAChD,IAAIE,EAAE,EAAE;UACN5B,MAAM,CAAC8B,cAAc,CAAC5C,SAAS,EAAEwC,CAAC,EAAEE,EAAE,CAAC;QACzC;MACF;MACA,OAAO1C,SAAS;IAClB;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI6C,KAAKA,CAACC,MAAM,EAAEC,MAAM,EAAE;MACpB,KAAK,IAAIR,CAAC,IAAIQ,MAAM,EAAE;QACpBD,MAAM,CAACP,CAAC,CAAC,GAAGQ,MAAM,CAACR,CAAC,CAAC;MACvB;MACA,OAAOO,MAAM;IACf;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIE,WAAWA,CAACC,MAAM,EAAEjD,SAAS,EAAE;MAC7B,IAAIiD,MAAM,IAAIjD,SAAS,IAAIiD,MAAM,KAAKjD,SAAS,EAAE;QAC/CiD,MAAM,CAACC,SAAS,GAAGlD,SAAS;MAC9B;MACA,OAAOiD,MAAM;IACf;;IAEA;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIE,gBAAgBA,CAACC,QAAQ,EAAE;MACzB,IAAIC,OAAO,GAAG,IAAI,CAAC1D,WAAW,CAAC2D,mBAAmB,CAACF,QAAQ,CAAC;MAC5D,IAAIzE,GAAG,GAAG;MACP4E,QAAQ,CAACC,UAAU,CAACH,OAAO,EAAE,IAAI,CAAE;MACtC,OAAO1E,GAAG;IACZ;;IAEA;;IAIA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI8E,IAAIA,CAAC/B,IAAI,EAAEgC,MAAM,EAAEC,OAAO,EAAE;MAC1BA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;MACvBD,MAAM,GAAIA,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAKE,SAAS,GAAI,CAAC,CAAC,GAAGF,MAAM;MAChE,IAAIG,KAAK,GAAG,IAAIC,KAAK,CAACpC,IAAI,EAAE;QAC1BqC,OAAO,EAAEJ,OAAO,CAACI,OAAO,KAAKH,SAAS,GAAG,IAAI,GAAGD,OAAO,CAACI,OAAO;QAC/DC,UAAU,EAAEC,OAAO,CAACN,OAAO,CAACK,UAAU,CAAC;QACvCE,QAAQ,EAAEP,OAAO,CAACO,QAAQ,KAAKN,SAAS,GAAG,IAAI,GAAED,OAAO,CAACO;MAC3D,CAAC,CAAC;MACFL,KAAK,CAACH,MAAM,GAAGA,MAAM;MACrB,IAAIzB,IAAI,GAAG0B,OAAO,CAAC1B,IAAI,IAAI,IAAI;MAC/B/C,IAAI,CAAC+C,IAAI,CAAC,CAACkC,aAAa,CAACN,KAAK,CAAC;MAC/B,OAAOA,KAAK;IACd;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIO,MAAMA,CAACnC,IAAI,EAAEoC,SAAS,EAAEC,UAAU,EAAE;MAClCrC,IAAI,GAAG,2BAA6BA,IAAI,IAAI,IAAK;MACjD,IAAIsC,GAAG,GAAG,IAAI,CAAC1E,gBAAgB,KAC5B,IAAI,CAACA,gBAAgB,GAAG,IAAI2E,OAAO,CAAC,CAAC,CAAC;MACzC,IAAIC,EAAE,GAAGF,GAAG,CAACtF,GAAG,CAACgD,IAAI,CAAC;MACtB,IAAI,CAACwC,EAAE,EAAE;QACPA,EAAE,GAAG,CAAC,CAAC;QACPF,GAAG,CAACG,GAAG,CAACzC,IAAI,EAAEwC,EAAE,CAAC;MACnB;MACA,IAAIE,GAAG,GAAGN,SAAS,GAAGC,UAAU;MAChC,IAAI,CAACG,EAAE,CAACE,GAAG,CAAC,EAAE;QACZF,EAAE,CAACE,GAAG,CAAC,GAAG,IAAI,CAACC,6BAA6B,EACxC,oBAAsB3C,IAAI,EAAGoC,SAAS,EAAEC,UAAU,EAAE,IAAI,CAAC;MAC/D;IACF;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIO,QAAQA,CAAC5C,IAAI,EAAEoC,SAAS,EAAEC,UAAU,EAAE;MACpCrC,IAAI,GAAG,2BAA6BA,IAAI,IAAI,IAAK;MACjD,IAAIwC,EAAE,GAAG,IAAI,CAAC5E,gBAAgB,IAC1B,IAAI,CAACA,gBAAgB,CAACZ,GAAG,EAAC,uBAAyBgD,IAAK,CAAC;MAC7D,IAAI0C,GAAG,GAAGN,SAAS,GAAGC,UAAU;MAChC,IAAIQ,OAAO,GAAGL,EAAE,IAAIA,EAAE,CAACE,GAAG,CAAC;MAC3B,IAAIG,OAAO,EAAE;QACX,IAAI,CAACC,4BAA4B,EAC7B,oBAAsB9C,IAAI,EAAGoC,SAAS,EAAES,OAAO,CAAC;QACpDL,EAAE,CAACE,GAAG,CAAC,GAAG,gBAAkB,IAAK;MACnC;IACF;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIK,kBAAkBA,CAACC,SAAS,EAAEhD,IAAI,EAAE;MAClCpD,cAAc,EACV,uBAAyBoD,IAAI,IAAI,IAAI,EACrCxC,aAAa,CAACwF,SAAS,CAAC,IAAI,MAAM,CAAC;IACzC;IACA;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIC,EAAEA,CAACC,KAAK,EAAE;MACR;MACA,OAAO,IAAI,CAAChE,IAAI,CAACiE,aAAa,CAACD,KAAK,CAAC;IACvC;;IAEA;AACJ;AACA;AACA;AACA;AACA;IACI,IAAIE,OAAOA,CAAA,EAAG;MACZ,IAAIlE,IAAI,GAAGjC,IAAI,CAAC,IAAI,CAAC,CAACoG,WAAW,CAAC,CAAC;MACnC,OAAQnE,IAAI,YAAYoE,gBAAgB,GAAI,yBAA2BpE,IAAI,CAAEqE,IAAI,GAAGrE,IAAI;IAC1F;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;IACIsE,iBAAiBA,CAAA,EAAG;MAClB,MAAMC,MAAM,GAAG,sBAAwB,IAAK;MAC5C,MAAMC,MAAM,GAAG,4BAA6BhH,GAAG,CAAC+G,MAAM,CAAE;MACxD,IAAItG,MAAM,CAACwG,QAAQ,IAAID,MAAM,CAACE,UAAU,EAAE;QACxCD,QAAQ,CAACE,KAAK,CAAC,CAAC;MAClB;IACF;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIC,sBAAsBA,CAAA,EAAG;MACvB,MAAML,MAAM,GAAG,sBAAwB,IAAK;MAC5C,MAAMC,MAAM,GAAG,4BAA8BhH,GAAG,CAAC+G,MAAM,CAAE;MACzD,OAAOC,MAAM,CAACI,sBAAsB,CAAC,CAAC;IACxC;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIC,wBAAwBA,CAACC,QAAQ,EAAE;MACjC,MAAMP,MAAM,GAAG,sBAAwB,IAAK;MAC5C,MAAMC,MAAM,GAAG,4BAA8BhH,GAAG,CAAC+G,MAAM,CAAE;MACzD,OAAOC,MAAM,CAACK,wBAAwB,CAACC,QAAQ,CAAC;IAClD;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIC,oBAAoBA,CAAA,EAAG;MACrB,IAAIC,IAAI,GAAG,IAAI,CAACJ,sBAAsB,CAAC,CAAC;MACxC,OAAOI,IAAI,CAACC,MAAM,CAAC,WAAS,oBAAqB5D,CAAC,EAAE;QAClD,OAAQA,CAAC,CAAC6D,QAAQ,KAAKC,IAAI,CAACC,YAAY;MAC1C,CAAC,CAAC;IACJ;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IACIC,uBAAuBA,CAAA,EAAG;MACxB,IAAIC,EAAE,GAAG,IAAI,CAACV,sBAAsB,CAAC,CAAC;MACtC,IAAIW,EAAE,GAAG,EAAE;MACX,KAAK,IAAInE,CAAC,GAAC,CAAC,EAAEoE,CAAC,EAAGA,CAAC,GAAGF,EAAE,CAAClE,CAAC,CAAC,EAAGA,CAAC,EAAE,EAAE;QACjC,IAAIoE,CAAC,CAACN,QAAQ,KAAKC,IAAI,CAACM,YAAY,EAAE;UACpCF,EAAE,CAACG,IAAI,CAACF,CAAC,CAACG,WAAW,CAAC;QACxB;MACF;MACA,OAAOJ,EAAE,CAACK,IAAI,CAAC,EAAE,CAAC;IACpB;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IACIC,sBAAsBA,CAACf,QAAQ,EAAE;MAC/B,IAAIgB,EAAE,GAAG,IAAI,CAACjB,wBAAwB,CAACC,QAAQ,CAAC;MAChD,OAAOgB,EAAE,IAAIA,EAAE,CAAC,CAAC,CAAC;IACpB;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIC,yBAAyBA,CAACjB,QAAQ,EAAE;MAClC,OAAO,IAAI,CAACD,wBAAwB,CAACC,QAAQ,CAAC;IAChD;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIkB,oBAAoBA,CAAChC,KAAK,EAAE;MAC1B;MACA,IAAI9B,OAAO,GAAG,IAAI,CAAClC,IAAI,CAACiE,aAAa,CAACD,KAAK,IAAI,MAAM,CAAC;MACtD,OAAO9B,OAAO,GACV,4BAA8B1E,GAAG,CAAC0E,OAAO,CAAC,CAAE+D,mBAAmB,CAAC,CAAC,GACjE,EAAE;IACR;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIC,kBAAkBA,CAAClC,KAAK,EAAE;MACxB,IAAImC,QAAQ,GAAG,mCAAoC,IAAI,CAACH,oBAAoB,CAAChC,KAAK,CAAC,CAACiB,MAAM,CAAC,UAAS5D,CAAC,EAAE;QACrG,OAAQA,CAAC,CAAC6D,QAAQ,KAAKC,IAAI,CAACC,YAAY;MAC1C,CAAC,CAAE;MACH,OAAOe,QAAQ;IACjB;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIC,iBAAiBA,CAACtF,IAAI,EAAE;MACtB,MAAMuF,QAAQ,GAAG,mBAAqB,IAAK;MAC3C,OAAOA,QAAQ,KAAKvF,IAAI,IAAI/C,IAAI,CAACsI,QAAQ,CAAC,CAACC,QAAQ,CAACxF,IAAI,CAAC,IACvD/C,IAAI,CAACsI,QAAQ,CAAC,CAAClC,WAAW,CAAC,CAAC,KAAKpG,IAAI,CAAC+C,IAAI,CAAC,CAACqD,WAAW,CAAC,CAAC;IAC7D;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;IACIoC,iBAAiBA,CAACzF,IAAI,EAAE;MACtB,OAAO,IAAI,CAACd,IAAI,KAAKjC,IAAI,CAAC+C,IAAI,CAAC,CAACqD,WAAW,CAAC,CAAC;IAC/C;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IACIqC,YAAYA,CAACC,SAAS,EAAEC,aAAa,EAAE,CAAE;IAAA;;IAGzC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIC,qBAAqBA,CAACjG,QAAQ,EAAE;MAC9B,OAAO1C,cAAc,CAAC2I,qBAAqB,EAAC,uBAAwB,IAAI,EAAGjG,QAAQ,CAAC;IACtF;;IAEA;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIkG,QAAQA,CAACC,OAAO,EAAEC,QAAQ,EAAEC,IAAI,EAAE;MAChC,IAAI,CAACpI,WAAW,GAAG,IAAI,CAACA,WAAW,IAAI,CAAC,CAAC;MACzC,OAAO,IAAI,CAACA,WAAW,CAACkI,OAAO,CAAC,GAAGlJ,SAAS,CAACiJ,QAAQ,CAC/C,IAAI,CAACjI,WAAW,CAACkI,OAAO,CAAC,EACzBE,IAAI,GAAG,CAAC,GAAGnJ,OAAO,CAACoJ,KAAK,CAACD,IAAI,CAAC,GAAGlJ,SAAS,EAC1CiJ,QAAQ,CAACG,IAAI,CAAC,IAAI,CAAC,CAAC;IAC5B;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;IACIC,iBAAiBA,CAACL,OAAO,EAAE;MACzB,IAAI,CAAClI,WAAW,GAAG,IAAI,CAACA,WAAW,IAAI,CAAC,CAAC;MACzC,IAAIwI,SAAS,GAAG,IAAI,CAACxI,WAAW,CAACkI,OAAO,CAAC;MACzC,OAAO,CAAC,EAAEM,SAAS,IAAIA,SAAS,CAACC,QAAQ,CAAC,CAAC,CAAC;IAC9C;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;IACIC,cAAcA,CAACR,OAAO,EAAE;MACtB,IAAI,CAAClI,WAAW,GAAG,IAAI,CAACA,WAAW,IAAI,CAAC,CAAC;MACzC,IAAIwI,SAAS,GAAG,IAAI,CAACxI,WAAW,CAACkI,OAAO,CAAC;MACzC,IAAIM,SAAS,EAAE;QACbA,SAAS,CAACxC,KAAK,CAAC,CAAC;MACnB;IACF;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;IACI2C,eAAeA,CAACT,OAAO,EAAE;MACvB,IAAI,CAAClI,WAAW,GAAG,IAAI,CAACA,WAAW,IAAI,CAAC,CAAC;MACzC,IAAIwI,SAAS,GAAG,IAAI,CAACxI,WAAW,CAACkI,OAAO,CAAC;MACzC,IAAIM,SAAS,EAAE;QACbA,SAAS,CAACI,MAAM,CAAC,CAAC;MACpB;IACF;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIC,KAAKA,CAACV,QAAQ,EAAEW,QAAQ,EAAE;MACxB,OAAOA,QAAQ,GAAG,CAAC,GAAG7J,OAAO,CAAC8J,GAAG,CAACZ,QAAQ,CAACG,IAAI,CAAC,IAAI,CAAC,EAAEQ,QAAQ,CAAC,GAC5D,CAAC5J,SAAS,CAAC6J,GAAG,CAACZ,QAAQ,CAACG,IAAI,CAAC,IAAI,CAAC,CAAC;IACzC;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IACIU,WAAWA,CAACC,MAAM,EAAE;MAClBA,MAAM,GAAG,CAAC,GAAG/J,SAAS,CAAC0J,MAAM,CAAC,CAACK,MAAM,CAAC,GAClChK,OAAO,CAAC2J,MAAM,CAACK,MAAM,CAAC;IAC5B;;IAEA;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIC,MAAMA,CAACC,GAAG,EAAEC,KAAK,EAAE;MACjB,IAAIC,GAAG,GAAG5F,QAAQ,CAAC6F,aAAa,CAACH,GAAG,CAAC;MACrC,IAAIC,KAAK,EAAE;QACT,IAAIC,GAAG,CAACE,aAAa,EAAE;UACrBF,GAAG,CAACE,aAAa,CAACH,KAAK,CAAC;QAC1B,CAAC,MAAM;UACL,KAAK,IAAI1G,CAAC,IAAI0G,KAAK,EAAE;YACnBC,GAAG,CAAC3G,CAAC,CAAC,GAAG0G,KAAK,CAAC1G,CAAC,CAAC;UACnB;QACF;MACF;MACA,OAAO2G,GAAG;IACZ;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIG,cAAcA,CAACrD,QAAQ,EAAEhE,IAAI,EAAE;MAC7B,OAAOrD,eAAe,CAAGqD,IAAI,IAAI,IAAI,EAAGgE,QAAQ,CAAC;IACnD;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIsD,eAAeA,CAAChJ,IAAI,EAAEiJ,IAAI,EAAE;MAC1B,IAAIvH,IAAI,GAAG,sBAAuB,IAAK;MACvC,IAAIwH,SAAS,CAAChH,MAAM,KAAK,CAAC,EAAE;QAC1BR,IAAI,GAAG,sBAAuBwH,SAAS,CAAC,CAAC,CAAE;MAC7C;MACA,IAAIA,SAAS,CAAChH,MAAM,IAAI,CAAC,EAAE;QACzB+G,IAAI,GAAG,CAACvH,IAAI,CAACyH,YAAY,CAACnJ,IAAI,CAAC;MACjC;MACA,IAAIiJ,IAAI,EAAE;QACRtK,IAAI,CAAC+C,IAAI,CAAC,CAAC0H,YAAY,CAACpJ,IAAI,EAAE,EAAE,CAAC;QACjC,OAAO,IAAI;MACb,CAAC,MAAM;QACLrB,IAAI,CAAC+C,IAAI,CAAC,CAAC2H,eAAe,CAACrJ,IAAI,CAAC;QAChC,OAAO,KAAK;MACd;IACF;;IAGA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIsJ,WAAWA,CAACtJ,IAAI,EAAEiJ,IAAI,EAAEvH,IAAI,EAAE;MAC5BA,IAAI,GAAG,sBAAwBA,IAAI,IAAI,IAAK;MAC5C,IAAIwH,SAAS,CAAChH,MAAM,IAAI,CAAC,EAAE;QACzB+G,IAAI,GAAG,CAACvH,IAAI,CAAC6H,SAAS,CAACrC,QAAQ,CAAClH,IAAI,CAAC;MACvC;MACA,IAAIiJ,IAAI,EAAE;QACRvH,IAAI,CAAC6H,SAAS,CAACC,GAAG,CAACxJ,IAAI,CAAC;MAC1B,CAAC,MAAM;QACL0B,IAAI,CAAC6H,SAAS,CAACE,MAAM,CAACzJ,IAAI,CAAC;MAC7B;IACF;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI0J,SAASA,CAACC,aAAa,EAAEjI,IAAI,EAAE;MAC7BA,IAAI,GAAG,sBAAwBA,IAAI,IAAI,IAAK;MAC5CA,IAAI,CAACkI,KAAK,CAACC,eAAe,GAAGF,aAAa;MAC1CjI,IAAI,CAACkI,KAAK,CAACF,SAAS,GAAGC,aAAa;IACtC;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIG,WAAWA,CAACC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEvI,IAAI,EAAE;MACzBA,IAAI,GAAG,sBAAwBA,IAAI,IAAI,IAAK;MAC5C,IAAI,CAACgI,SAAS,CAAC,cAAc,GAAGK,CAAC,GAAG,GAAG,GAAGC,CAAC,GAAG,GAAG,GAAGC,CAAC,GAAG,GAAG,EAAEvI,IAAI,CAAC;IACpE;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIwI,WAAWA,CAACC,WAAW,EAAEC,IAAI,EAAE;MAC7B,IAAIC,KAAK;MACT,IAAIC,KAAK,CAACC,OAAO,CAACJ,WAAW,CAAC,EAAE;QAC9BE,KAAK,GAAGF,WAAW,CAACK,OAAO,CAACJ,IAAI,CAAC;QACjC,IAAIC,KAAK,IAAI,CAAC,EAAE;UACd,OAAOF,WAAW,CAACM,MAAM,CAACJ,KAAK,EAAE,CAAC,CAAC;QACrC;MACF,CAAC,MAAM;QACL,IAAIK,GAAG,GAAGhM,GAAG,CAAC,IAAI,EAAEyL,WAAW,CAAC;QAChCE,KAAK,GAAGK,GAAG,CAACF,OAAO,CAACJ,IAAI,CAAC;QACzB,IAAIC,KAAK,IAAI,CAAC,EAAE;UACd,OAAO,IAAI,CAACI,MAAM,CAACN,WAAW,EAAEE,KAAK,EAAE,CAAC,CAAC;QAC3C;MACF;MACA,OAAO,IAAI;IACb;;IAEA;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IACIM,OAAOA,CAACC,KAAK,EAAEC,IAAI,EAAE;MACnB;MACA,IAAIP,KAAK,CAACC,OAAO,CAACM,IAAI,CAAC,IAAIA,IAAI,CAAC3I,MAAM,KAAK,CAAC,IAAIoI,KAAK,CAACC,OAAO,CAACM,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;QACtEA,IAAI,GAAGA,IAAI,CAAC,CAAC,CAAC;MAChB;MACA,QAAOD,KAAK;QACV,KAAK,KAAK;QACV,KAAK,MAAM;QACX,KAAK,OAAO;UACVE,OAAO,CAACF,KAAK,CAAC,CAAC,GAAGC,IAAI,CAAC;MAC3B;IACF;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;IACIE,IAAIA,CAAC,GAAGF,IAAI,EAAE;MACZ,IAAI,CAACF,OAAO,CAAC,KAAK,EAAEE,IAAI,CAAC;IAC3B;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;IACIG,KAAKA,CAAC,GAAGH,IAAI,EAAE;MACb,IAAI,CAACF,OAAO,CAAC,MAAM,EAAEE,IAAI,CAAC;IAC5B;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;IACII,MAAMA,CAAC,GAAGJ,IAAI,EAAE;MACd,IAAI,CAACF,OAAO,CAAC,OAAO,EAAEE,IAAI,CAAC;IAC7B;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIK,KAAKA,CAACnH,UAAU,EAAE,GAAG8G,IAAI,EAAE;MACzB,OAAO,CAAC,UAAU,EAAE,IAAI,CAACM,EAAE,EAAEpH,UAAU,EAAE,GAAG8G,IAAI,CAAC;IACnD;EAEF;EAEA1L,aAAa,CAACM,SAAS,CAAC0L,EAAE,GAAG,EAAE;EAE/B,OAAOhM,aAAa;AACtB,CAAC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}