{"ast":null,"code":"/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '../utils/boot.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nimport { microTask } from '../utils/async.js';\nimport { wrap } from '../utils/wrap.js';\n\n/** @const {!AsyncInterface} */\nconst microtask = microTask;\n\n/**\n * Element class mixin that provides basic meta-programming for creating one\n * or more property accessors (getter/setter pair) that enqueue an async\n * (batched) `_propertiesChanged` callback.\n *\n * For basic usage of this mixin, call `MyClass.createProperties(props)`\n * once at class definition time to create property accessors for properties\n * named in props, implement `_propertiesChanged` to react as desired to\n * property changes, and implement `static get observedAttributes()` and\n * include lowercase versions of any property names that should be set from\n * attributes. Last, call `this._enableProperties()` in the element's\n * `connectedCallback` to enable the accessors.\n *\n * @mixinFunction\n * @polymer\n * @summary Element class mixin for reacting to property changes from\n *   generated property accessors.\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nexport const PropertiesChanged = dedupingMixin(\n/**\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nsuperClass => {\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_PropertiesChanged}\n   * @unrestricted\n   */\n  class PropertiesChanged extends superClass {\n    /**\n     * Creates property accessors for the given property names.\n     * @param {!Object} props Object whose keys are names of accessors.\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createProperties(props) {\n      const proto = this.prototype;\n      for (let prop in props) {\n        // don't stomp an existing accessor\n        if (!(prop in proto)) {\n          proto._createPropertyAccessor(prop);\n        }\n      }\n    }\n\n    /**\n     * Returns an attribute name that corresponds to the given property.\n     * The attribute name is the lowercased property name. Override to\n     * customize this mapping.\n     * @param {string} property Property to convert\n     * @return {string} Attribute name corresponding to the given property.\n     *\n     * @protected\n     * @nocollapse\n     */\n    static attributeNameForProperty(property) {\n      return property.toLowerCase();\n    }\n\n    /**\n     * Override point to provide a type to which to deserialize a value to\n     * a given property.\n     * @param {string} name Name of property\n     *\n     * @protected\n     * @nocollapse\n     */\n    static typeForProperty(name) {} //eslint-disable-line no-unused-vars\n\n    /**\n     * Creates a setter/getter pair for the named property with its own\n     * local storage.  The getter returns the value in the local storage,\n     * and the setter calls `_setProperty`, which updates the local storage\n     * for the property and enqueues a `_propertiesChanged` callback.\n     *\n     * This method may be called on a prototype or an instance.  Calling\n     * this method may overwrite a property value that already exists on\n     * the prototype/instance by creating the accessor.\n     *\n     * @param {string} property Name of the property\n     * @param {boolean=} readOnly When true, no setter is created; the\n     *   protected `_setProperty` function must be used to set the property\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _createPropertyAccessor(property, readOnly) {\n      this._addPropertyToAttributeMap(property);\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('__dataHasAccessor', this))) {\n        this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);\n      }\n      if (!this.__dataHasAccessor[property]) {\n        this.__dataHasAccessor[property] = true;\n        this._definePropertyAccessor(property, readOnly);\n      }\n    }\n\n    /**\n     * Adds the given `property` to a map matching attribute names\n     * to property names, using `attributeNameForProperty`. This map is\n     * used when deserializing attribute values to properties.\n     *\n     * @param {string} property Name of the property\n     * @override\n     */\n    _addPropertyToAttributeMap(property) {\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('__dataAttributes', this))) {\n        this.__dataAttributes = Object.assign({}, this.__dataAttributes);\n      }\n      // This check is technically not correct; it's an optimization that\n      // assumes that if a _property_ name is already in the map (note this is\n      // an attr->property map), the property mapped directly to the attribute\n      // and it has already been mapped.  This would fail if\n      // `attributeNameForProperty` were overridden such that this was not the\n      // case.\n      let attr = this.__dataAttributes[property];\n      if (!attr) {\n        attr = this.constructor.attributeNameForProperty(property);\n        this.__dataAttributes[attr] = property;\n      }\n      return attr;\n    }\n\n    /**\n     * Defines a property accessor for the given property.\n     * @param {string} property Name of the property\n     * @param {boolean=} readOnly When true, no setter is created\n     * @return {void}\n     * @override\n     */\n    _definePropertyAccessor(property, readOnly) {\n      Object.defineProperty(this, property, {\n        /* eslint-disable valid-jsdoc */\n        /** @this {PropertiesChanged} */\n        get() {\n          // Inline for perf instead of using `_getProperty`\n          return this.__data[property];\n        },\n        /** @this {PropertiesChanged} */\n        set: readOnly ? function () {} : function (value) {\n          // Inline for perf instead of using `_setProperty`\n          if (this._setPendingProperty(property, value, true)) {\n            this._invalidateProperties();\n          }\n        }\n        /* eslint-enable */\n      });\n    }\n\n    constructor() {\n      super();\n      /** @type {boolean} */\n      this.__dataEnabled = false;\n      this.__dataReady = false;\n      this.__dataInvalid = false;\n      this.__data = {};\n      this.__dataPending = null;\n      this.__dataOld = null;\n      this.__dataInstanceProps = null;\n      /** @type {number} */\n      // NOTE: used to track re-entrant calls to `_flushProperties`\n      this.__dataCounter = 0;\n      this.__serializing = false;\n      this._initializeProperties();\n    }\n\n    /**\n     * Lifecycle callback called when properties are enabled via\n     * `_enableProperties`.\n     *\n     * Users may override this function to implement behavior that is\n     * dependent on the element having its property data initialized, e.g.\n     * from defaults (initialized from `constructor`, `_initializeProperties`),\n     * `attributeChangedCallback`, or values propagated from host e.g. via\n     * bindings.  `super.ready()` must be called to ensure the data system\n     * becomes enabled.\n     *\n     * @return {void}\n     * @public\n     * @override\n     */\n    ready() {\n      this.__dataReady = true;\n      this._flushProperties();\n    }\n\n    /**\n     * Initializes the local storage for property accessors.\n     *\n     * Provided as an override point for performing any setup work prior\n     * to initializing the property accessor system.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _initializeProperties() {\n      // Capture instance properties; these will be set into accessors\n      // during first flush. Don't set them here, since we want\n      // these to overwrite defaults/constructor assignments\n      for (let p in this.__dataHasAccessor) {\n        if (this.hasOwnProperty(p)) {\n          this.__dataInstanceProps = this.__dataInstanceProps || {};\n          this.__dataInstanceProps[p] = this[p];\n          delete this[p];\n        }\n      }\n    }\n\n    /**\n     * Called at ready time with bag of instance properties that overwrote\n     * accessors when the element upgraded.\n     *\n     * The default implementation sets these properties back into the\n     * setter at ready time.  This method is provided as an override\n     * point for customizing or providing more efficient initialization.\n     *\n     * @param {Object} props Bag of property values that were overwritten\n     *   when creating property accessors.\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _initializeInstanceProperties(props) {\n      Object.assign(this, props);\n    }\n\n    /**\n     * Updates the local storage for a property (via `_setPendingProperty`)\n     * and enqueues a `_proeprtiesChanged` callback.\n     *\n     * @param {string} property Name of the property\n     * @param {*} value Value to set\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _setProperty(property, value) {\n      if (this._setPendingProperty(property, value)) {\n        this._invalidateProperties();\n      }\n    }\n\n    /**\n     * Returns the value for the given property.\n     * @param {string} property Name of property\n     * @return {*} Value for the given property\n     * @protected\n     * @override\n     */\n    _getProperty(property) {\n      return this.__data[property];\n    }\n\n    /* eslint-disable no-unused-vars */\n    /**\n     * Updates the local storage for a property, records the previous value,\n     * and adds it to the set of \"pending changes\" that will be passed to the\n     * `_propertiesChanged` callback.  This method does not enqueue the\n     * `_propertiesChanged` callback.\n     *\n     * @param {string} property Name of the property\n     * @param {*} value Value to set\n     * @param {boolean=} ext Not used here; affordance for closure\n     * @return {boolean} Returns true if the property changed\n     * @protected\n     * @override\n     */\n    _setPendingProperty(property, value, ext) {\n      let old = this.__data[property];\n      let changed = this._shouldPropertyChange(property, value, old);\n      if (changed) {\n        if (!this.__dataPending) {\n          this.__dataPending = {};\n          this.__dataOld = {};\n        }\n        // Ensure old is captured from the last turn\n        if (this.__dataOld && !(property in this.__dataOld)) {\n          this.__dataOld[property] = old;\n        }\n        this.__data[property] = value;\n        this.__dataPending[property] = value;\n      }\n      return changed;\n    }\n    /* eslint-enable */\n\n    /**\n     * @param {string} property Name of the property\n     * @return {boolean} Returns true if the property is pending.\n     */\n    _isPropertyPending(property) {\n      return !!(this.__dataPending && this.__dataPending.hasOwnProperty(property));\n    }\n\n    /**\n     * Marks the properties as invalid, and enqueues an async\n     * `_propertiesChanged` callback.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _invalidateProperties() {\n      if (!this.__dataInvalid && this.__dataReady) {\n        this.__dataInvalid = true;\n        microtask.run(() => {\n          if (this.__dataInvalid) {\n            this.__dataInvalid = false;\n            this._flushProperties();\n          }\n        });\n      }\n    }\n\n    /**\n     * Call to enable property accessor processing. Before this method is\n     * called accessor values will be set but side effects are\n     * queued. When called, any pending side effects occur immediately.\n     * For elements, generally `connectedCallback` is a normal spot to do so.\n     * It is safe to call this method multiple times as it only turns on\n     * property accessors once.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _enableProperties() {\n      if (!this.__dataEnabled) {\n        this.__dataEnabled = true;\n        if (this.__dataInstanceProps) {\n          this._initializeInstanceProperties(this.__dataInstanceProps);\n          this.__dataInstanceProps = null;\n        }\n        this.ready();\n      }\n    }\n\n    /**\n     * Calls the `_propertiesChanged` callback with the current set of\n     * pending changes (and old values recorded when pending changes were\n     * set), and resets the pending set of changes. Generally, this method\n     * should not be called in user code.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _flushProperties() {\n      this.__dataCounter++;\n      const props = this.__data;\n      const changedProps = this.__dataPending;\n      const old = this.__dataOld;\n      if (this._shouldPropertiesChange(props, changedProps, old)) {\n        this.__dataPending = null;\n        this.__dataOld = null;\n        this._propertiesChanged(props, changedProps, old);\n      }\n      this.__dataCounter--;\n    }\n\n    /**\n     * Called in `_flushProperties` to determine if `_propertiesChanged`\n     * should be called. The default implementation returns true if\n     * properties are pending. Override to customize when\n     * `_propertiesChanged` is called.\n     * @param {!Object} currentProps Bag of all current accessor values\n     * @param {?Object} changedProps Bag of properties changed since the last\n     *   call to `_propertiesChanged`\n     * @param {?Object} oldProps Bag of previous values for each property\n     *   in `changedProps`\n     * @return {boolean} true if changedProps is truthy\n     * @override\n     */\n    _shouldPropertiesChange(currentProps, changedProps, oldProps) {\n      // eslint-disable-line no-unused-vars\n      return Boolean(changedProps);\n    }\n\n    /**\n     * Callback called when any properties with accessors created via\n     * `_createPropertyAccessor` have been set.\n     *\n     * @param {!Object} currentProps Bag of all current accessor values\n     * @param {?Object} changedProps Bag of properties changed since the last\n     *   call to `_propertiesChanged`\n     * @param {?Object} oldProps Bag of previous values for each property\n     *   in `changedProps`\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _propertiesChanged(currentProps, changedProps, oldProps) {// eslint-disable-line no-unused-vars\n    }\n\n    /**\n     * Method called to determine whether a property value should be\n     * considered as a change and cause the `_propertiesChanged` callback\n     * to be enqueued.\n     *\n     * The default implementation returns `true` if a strict equality\n     * check fails. The method always returns false for `NaN`.\n     *\n     * Override this method to e.g. provide stricter checking for\n     * Objects/Arrays when using immutable patterns.\n     *\n     * @param {string} property Property name\n     * @param {*} value New property value\n     * @param {*} old Previous property value\n     * @return {boolean} Whether the property should be considered a change\n     *   and enqueue a `_proeprtiesChanged` callback\n     * @protected\n     * @override\n     */\n    _shouldPropertyChange(property, value, old) {\n      return (\n        // Strict equality check\n        old !== value && (\n        // This ensures (old==NaN, value==NaN) always returns false\n        old === old || value === value)\n      );\n    }\n\n    /**\n     * Implements native Custom Elements `attributeChangedCallback` to\n     * set an attribute value to a property via `_attributeToProperty`.\n     *\n     * @param {string} name Name of attribute that changed\n     * @param {?string} old Old attribute value\n     * @param {?string} value New attribute value\n     * @param {?string} namespace Attribute namespace.\n     * @return {void}\n     * @suppress {missingProperties} Super may or may not implement the callback\n     * @override\n     */\n    attributeChangedCallback(name, old, value, namespace) {\n      if (old !== value) {\n        this._attributeToProperty(name, value);\n      }\n      if (super.attributeChangedCallback) {\n        super.attributeChangedCallback(name, old, value, namespace);\n      }\n    }\n\n    /**\n     * Deserializes an attribute to its associated property.\n     *\n     * This method calls the `_deserializeValue` method to convert the string to\n     * a typed value.\n     *\n     * @param {string} attribute Name of attribute to deserialize.\n     * @param {?string} value of the attribute.\n     * @param {*=} type type to deserialize to, defaults to the value\n     * returned from `typeForProperty`\n     * @return {void}\n     * @override\n     */\n    _attributeToProperty(attribute, value, type) {\n      if (!this.__serializing) {\n        const map = this.__dataAttributes;\n        const property = map && map[attribute] || attribute;\n        this[property] = this._deserializeValue(value, type || this.constructor.typeForProperty(property));\n      }\n    }\n\n    /**\n     * Serializes a property to its associated attribute.\n     *\n     * @suppress {invalidCasts} Closure can't figure out `this` is an element.\n     *\n     * @param {string} property Property name to reflect.\n     * @param {string=} attribute Attribute name to reflect to.\n     * @param {*=} value Property value to refect.\n     * @return {void}\n     * @override\n     */\n    _propertyToAttribute(property, attribute, value) {\n      this.__serializing = true;\n      value = arguments.length < 3 ? this[property] : value;\n      this._valueToNodeAttribute( /** @type {!HTMLElement} */this, value, attribute || this.constructor.attributeNameForProperty(property));\n      this.__serializing = false;\n    }\n\n    /**\n     * Sets a typed value to an HTML attribute on a node.\n     *\n     * This method calls the `_serializeValue` method to convert the typed\n     * value to a string.  If the `_serializeValue` method returns `undefined`,\n     * the attribute will be removed (this is the default for boolean\n     * type `false`).\n     *\n     * @param {Element} node Element to set attribute to.\n     * @param {*} value Value to serialize.\n     * @param {string} attribute Attribute name to serialize to.\n     * @return {void}\n     * @override\n     */\n    _valueToNodeAttribute(node, value, attribute) {\n      const str = this._serializeValue(value);\n      if (attribute === 'class' || attribute === 'name' || attribute === 'slot') {\n        node = /** @type {?Element} */wrap(node);\n      }\n      if (str === undefined) {\n        node.removeAttribute(attribute);\n      } else {\n        node.setAttribute(attribute,\n        // Closure's type for `setAttribute`'s second parameter incorrectly\n        // excludes `TrustedScript`.\n        str === '' && window.trustedTypes ? ( /** @type {?} */window.trustedTypes.emptyScript) : str);\n      }\n    }\n\n    /**\n     * Converts a typed JavaScript value to a string.\n     *\n     * This method is called when setting JS property values to\n     * HTML attributes.  Users may override this method to provide\n     * serialization for custom types.\n     *\n     * @param {*} value Property value to serialize.\n     * @return {string | undefined} String serialized from the provided\n     * property  value.\n     * @override\n     */\n    _serializeValue(value) {\n      switch (typeof value) {\n        case 'boolean':\n          return value ? '' : undefined;\n        default:\n          return value != null ? value.toString() : undefined;\n      }\n    }\n\n    /**\n     * Converts a string to a typed JavaScript value.\n     *\n     * This method is called when reading HTML attribute values to\n     * JS properties.  Users may override this method to provide\n     * deserialization for custom `type`s. Types for `Boolean`, `String`,\n     * and `Number` convert attributes to the expected types.\n     *\n     * @param {?string} value Value to deserialize.\n     * @param {*=} type Type to deserialize the string to.\n     * @return {*} Typed value deserialized from the provided string.\n     * @override\n     */\n    _deserializeValue(value, type) {\n      switch (type) {\n        case Boolean:\n          return value !== null;\n        case Number:\n          return Number(value);\n        default:\n          return value;\n      }\n    }\n  }\n  return PropertiesChanged;\n});","map":{"version":3,"names":["dedupingMixin","microTask","wrap","microtask","PropertiesChanged","superClass","createProperties","props","proto","prototype","prop","_createPropertyAccessor","attributeNameForProperty","property","toLowerCase","typeForProperty","name","readOnly","_addPropertyToAttributeMap","hasOwnProperty","JSCompiler_renameProperty","__dataHasAccessor","Object","assign","_definePropertyAccessor","__dataAttributes","attr","constructor","defineProperty","get","__data","set","value","_setPendingProperty","_invalidateProperties","__dataEnabled","__dataReady","__dataInvalid","__dataPending","__dataOld","__dataInstanceProps","__dataCounter","__serializing","_initializeProperties","ready","_flushProperties","p","_initializeInstanceProperties","_setProperty","_getProperty","ext","old","changed","_shouldPropertyChange","_isPropertyPending","run","_enableProperties","changedProps","_shouldPropertiesChange","_propertiesChanged","currentProps","oldProps","Boolean","attributeChangedCallback","namespace","_attributeToProperty","attribute","type","map","_deserializeValue","_propertyToAttribute","arguments","length","_valueToNodeAttribute","node","str","_serializeValue","undefined","removeAttribute","setAttribute","window","trustedTypes","emptyScript","toString","Number"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@polymer/polymer/lib/mixins/properties-changed.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '../utils/boot.js';\n\nimport { dedupingMixin } from '../utils/mixin.js';\nimport { microTask } from '../utils/async.js';\nimport { wrap } from '../utils/wrap.js';\n\n/** @const {!AsyncInterface} */\nconst microtask = microTask;\n\n/**\n * Element class mixin that provides basic meta-programming for creating one\n * or more property accessors (getter/setter pair) that enqueue an async\n * (batched) `_propertiesChanged` callback.\n *\n * For basic usage of this mixin, call `MyClass.createProperties(props)`\n * once at class definition time to create property accessors for properties\n * named in props, implement `_propertiesChanged` to react as desired to\n * property changes, and implement `static get observedAttributes()` and\n * include lowercase versions of any property names that should be set from\n * attributes. Last, call `this._enableProperties()` in the element's\n * `connectedCallback` to enable the accessors.\n *\n * @mixinFunction\n * @polymer\n * @summary Element class mixin for reacting to property changes from\n *   generated property accessors.\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nexport const PropertiesChanged = dedupingMixin(\n    /**\n     * @template T\n     * @param {function(new:T)} superClass Class to apply mixin to.\n     * @return {function(new:T)} superClass with mixin applied.\n     */\n    (superClass) => {\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_PropertiesChanged}\n   * @unrestricted\n   */\n  class PropertiesChanged extends superClass {\n\n    /**\n     * Creates property accessors for the given property names.\n     * @param {!Object} props Object whose keys are names of accessors.\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createProperties(props) {\n      const proto = this.prototype;\n      for (let prop in props) {\n        // don't stomp an existing accessor\n        if (!(prop in proto)) {\n          proto._createPropertyAccessor(prop);\n        }\n      }\n    }\n\n    /**\n     * Returns an attribute name that corresponds to the given property.\n     * The attribute name is the lowercased property name. Override to\n     * customize this mapping.\n     * @param {string} property Property to convert\n     * @return {string} Attribute name corresponding to the given property.\n     *\n     * @protected\n     * @nocollapse\n     */\n    static attributeNameForProperty(property) {\n      return property.toLowerCase();\n    }\n\n    /**\n     * Override point to provide a type to which to deserialize a value to\n     * a given property.\n     * @param {string} name Name of property\n     *\n     * @protected\n     * @nocollapse\n     */\n    static typeForProperty(name) { } //eslint-disable-line no-unused-vars\n\n    /**\n     * Creates a setter/getter pair for the named property with its own\n     * local storage.  The getter returns the value in the local storage,\n     * and the setter calls `_setProperty`, which updates the local storage\n     * for the property and enqueues a `_propertiesChanged` callback.\n     *\n     * This method may be called on a prototype or an instance.  Calling\n     * this method may overwrite a property value that already exists on\n     * the prototype/instance by creating the accessor.\n     *\n     * @param {string} property Name of the property\n     * @param {boolean=} readOnly When true, no setter is created; the\n     *   protected `_setProperty` function must be used to set the property\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _createPropertyAccessor(property, readOnly) {\n      this._addPropertyToAttributeMap(property);\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('__dataHasAccessor', this))) {\n        this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);\n      }\n      if (!this.__dataHasAccessor[property]) {\n        this.__dataHasAccessor[property] = true;\n        this._definePropertyAccessor(property, readOnly);\n      }\n    }\n\n    /**\n     * Adds the given `property` to a map matching attribute names\n     * to property names, using `attributeNameForProperty`. This map is\n     * used when deserializing attribute values to properties.\n     *\n     * @param {string} property Name of the property\n     * @override\n     */\n    _addPropertyToAttributeMap(property) {\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('__dataAttributes', this))) {\n        this.__dataAttributes = Object.assign({}, this.__dataAttributes);\n      }\n      // This check is technically not correct; it's an optimization that\n      // assumes that if a _property_ name is already in the map (note this is\n      // an attr->property map), the property mapped directly to the attribute\n      // and it has already been mapped.  This would fail if\n      // `attributeNameForProperty` were overridden such that this was not the\n      // case.\n      let attr = this.__dataAttributes[property];\n      if (!attr) {\n        attr = this.constructor.attributeNameForProperty(property);\n        this.__dataAttributes[attr] = property;\n      }\n      return attr;\n    }\n\n    /**\n     * Defines a property accessor for the given property.\n     * @param {string} property Name of the property\n     * @param {boolean=} readOnly When true, no setter is created\n     * @return {void}\n     * @override\n     */\n     _definePropertyAccessor(property, readOnly) {\n      Object.defineProperty(this, property, {\n        /* eslint-disable valid-jsdoc */\n        /** @this {PropertiesChanged} */\n        get() {\n          // Inline for perf instead of using `_getProperty`\n          return this.__data[property];\n        },\n        /** @this {PropertiesChanged} */\n        set: readOnly ? function () {} : function (value) {\n          // Inline for perf instead of using `_setProperty`\n          if (this._setPendingProperty(property, value, true)) {\n            this._invalidateProperties();\n          }\n        }\n        /* eslint-enable */\n      });\n    }\n\n    constructor() {\n      super();\n      /** @type {boolean} */\n      this.__dataEnabled = false;\n      this.__dataReady = false;\n      this.__dataInvalid = false;\n      this.__data = {};\n      this.__dataPending = null;\n      this.__dataOld = null;\n      this.__dataInstanceProps = null;\n      /** @type {number} */\n      // NOTE: used to track re-entrant calls to `_flushProperties`\n      this.__dataCounter = 0;\n      this.__serializing = false;\n      this._initializeProperties();\n    }\n\n    /**\n     * Lifecycle callback called when properties are enabled via\n     * `_enableProperties`.\n     *\n     * Users may override this function to implement behavior that is\n     * dependent on the element having its property data initialized, e.g.\n     * from defaults (initialized from `constructor`, `_initializeProperties`),\n     * `attributeChangedCallback`, or values propagated from host e.g. via\n     * bindings.  `super.ready()` must be called to ensure the data system\n     * becomes enabled.\n     *\n     * @return {void}\n     * @public\n     * @override\n     */\n    ready() {\n      this.__dataReady = true;\n      this._flushProperties();\n    }\n\n    /**\n     * Initializes the local storage for property accessors.\n     *\n     * Provided as an override point for performing any setup work prior\n     * to initializing the property accessor system.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _initializeProperties() {\n      // Capture instance properties; these will be set into accessors\n      // during first flush. Don't set them here, since we want\n      // these to overwrite defaults/constructor assignments\n      for (let p in this.__dataHasAccessor) {\n        if (this.hasOwnProperty(p)) {\n          this.__dataInstanceProps = this.__dataInstanceProps || {};\n          this.__dataInstanceProps[p] = this[p];\n          delete this[p];\n        }\n      }\n    }\n\n    /**\n     * Called at ready time with bag of instance properties that overwrote\n     * accessors when the element upgraded.\n     *\n     * The default implementation sets these properties back into the\n     * setter at ready time.  This method is provided as an override\n     * point for customizing or providing more efficient initialization.\n     *\n     * @param {Object} props Bag of property values that were overwritten\n     *   when creating property accessors.\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _initializeInstanceProperties(props) {\n      Object.assign(this, props);\n    }\n\n    /**\n     * Updates the local storage for a property (via `_setPendingProperty`)\n     * and enqueues a `_proeprtiesChanged` callback.\n     *\n     * @param {string} property Name of the property\n     * @param {*} value Value to set\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _setProperty(property, value) {\n      if (this._setPendingProperty(property, value)) {\n        this._invalidateProperties();\n      }\n    }\n\n    /**\n     * Returns the value for the given property.\n     * @param {string} property Name of property\n     * @return {*} Value for the given property\n     * @protected\n     * @override\n     */\n    _getProperty(property) {\n      return this.__data[property];\n    }\n\n    /* eslint-disable no-unused-vars */\n    /**\n     * Updates the local storage for a property, records the previous value,\n     * and adds it to the set of \"pending changes\" that will be passed to the\n     * `_propertiesChanged` callback.  This method does not enqueue the\n     * `_propertiesChanged` callback.\n     *\n     * @param {string} property Name of the property\n     * @param {*} value Value to set\n     * @param {boolean=} ext Not used here; affordance for closure\n     * @return {boolean} Returns true if the property changed\n     * @protected\n     * @override\n     */\n    _setPendingProperty(property, value, ext) {\n      let old = this.__data[property];\n      let changed = this._shouldPropertyChange(property, value, old);\n      if (changed) {\n        if (!this.__dataPending) {\n          this.__dataPending = {};\n          this.__dataOld = {};\n        }\n        // Ensure old is captured from the last turn\n        if (this.__dataOld && !(property in this.__dataOld)) {\n          this.__dataOld[property] = old;\n        }\n        this.__data[property] = value;\n        this.__dataPending[property] = value;\n      }\n      return changed;\n    }\n    /* eslint-enable */\n\n    /**\n     * @param {string} property Name of the property\n     * @return {boolean} Returns true if the property is pending.\n     */\n    _isPropertyPending(property) {\n      return !!(this.__dataPending && this.__dataPending.hasOwnProperty(property));\n    }\n\n    /**\n     * Marks the properties as invalid, and enqueues an async\n     * `_propertiesChanged` callback.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _invalidateProperties() {\n      if (!this.__dataInvalid && this.__dataReady) {\n        this.__dataInvalid = true;\n        microtask.run(() => {\n          if (this.__dataInvalid) {\n            this.__dataInvalid = false;\n            this._flushProperties();\n          }\n        });\n      }\n    }\n\n    /**\n     * Call to enable property accessor processing. Before this method is\n     * called accessor values will be set but side effects are\n     * queued. When called, any pending side effects occur immediately.\n     * For elements, generally `connectedCallback` is a normal spot to do so.\n     * It is safe to call this method multiple times as it only turns on\n     * property accessors once.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _enableProperties() {\n      if (!this.__dataEnabled) {\n        this.__dataEnabled = true;\n        if (this.__dataInstanceProps) {\n          this._initializeInstanceProperties(this.__dataInstanceProps);\n          this.__dataInstanceProps = null;\n        }\n        this.ready();\n      }\n    }\n\n    /**\n     * Calls the `_propertiesChanged` callback with the current set of\n     * pending changes (and old values recorded when pending changes were\n     * set), and resets the pending set of changes. Generally, this method\n     * should not be called in user code.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _flushProperties() {\n      this.__dataCounter++;\n      const props = this.__data;\n      const changedProps = this.__dataPending;\n      const old = this.__dataOld;\n      if (this._shouldPropertiesChange(props, changedProps, old)) {\n        this.__dataPending = null;\n        this.__dataOld = null;\n        this._propertiesChanged(props, changedProps, old);\n      }\n      this.__dataCounter--;\n    }\n\n    /**\n     * Called in `_flushProperties` to determine if `_propertiesChanged`\n     * should be called. The default implementation returns true if\n     * properties are pending. Override to customize when\n     * `_propertiesChanged` is called.\n     * @param {!Object} currentProps Bag of all current accessor values\n     * @param {?Object} changedProps Bag of properties changed since the last\n     *   call to `_propertiesChanged`\n     * @param {?Object} oldProps Bag of previous values for each property\n     *   in `changedProps`\n     * @return {boolean} true if changedProps is truthy\n     * @override\n     */\n    _shouldPropertiesChange(currentProps, changedProps, oldProps) { // eslint-disable-line no-unused-vars\n      return Boolean(changedProps);\n    }\n\n    /**\n     * Callback called when any properties with accessors created via\n     * `_createPropertyAccessor` have been set.\n     *\n     * @param {!Object} currentProps Bag of all current accessor values\n     * @param {?Object} changedProps Bag of properties changed since the last\n     *   call to `_propertiesChanged`\n     * @param {?Object} oldProps Bag of previous values for each property\n     *   in `changedProps`\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _propertiesChanged(currentProps, changedProps, oldProps) { // eslint-disable-line no-unused-vars\n    }\n\n    /**\n     * Method called to determine whether a property value should be\n     * considered as a change and cause the `_propertiesChanged` callback\n     * to be enqueued.\n     *\n     * The default implementation returns `true` if a strict equality\n     * check fails. The method always returns false for `NaN`.\n     *\n     * Override this method to e.g. provide stricter checking for\n     * Objects/Arrays when using immutable patterns.\n     *\n     * @param {string} property Property name\n     * @param {*} value New property value\n     * @param {*} old Previous property value\n     * @return {boolean} Whether the property should be considered a change\n     *   and enqueue a `_proeprtiesChanged` callback\n     * @protected\n     * @override\n     */\n    _shouldPropertyChange(property, value, old) {\n      return (\n        // Strict equality check\n        (old !== value &&\n          // This ensures (old==NaN, value==NaN) always returns false\n          (old === old || value === value))\n      );\n    }\n\n    /**\n     * Implements native Custom Elements `attributeChangedCallback` to\n     * set an attribute value to a property via `_attributeToProperty`.\n     *\n     * @param {string} name Name of attribute that changed\n     * @param {?string} old Old attribute value\n     * @param {?string} value New attribute value\n     * @param {?string} namespace Attribute namespace.\n     * @return {void}\n     * @suppress {missingProperties} Super may or may not implement the callback\n     * @override\n     */\n    attributeChangedCallback(name, old, value, namespace) {\n      if (old !== value) {\n        this._attributeToProperty(name, value);\n      }\n      if (super.attributeChangedCallback) {\n        super.attributeChangedCallback(name, old, value, namespace);\n      }\n    }\n\n    /**\n     * Deserializes an attribute to its associated property.\n     *\n     * This method calls the `_deserializeValue` method to convert the string to\n     * a typed value.\n     *\n     * @param {string} attribute Name of attribute to deserialize.\n     * @param {?string} value of the attribute.\n     * @param {*=} type type to deserialize to, defaults to the value\n     * returned from `typeForProperty`\n     * @return {void}\n     * @override\n     */\n    _attributeToProperty(attribute, value, type) {\n      if (!this.__serializing) {\n        const map = this.__dataAttributes;\n        const property = map && map[attribute] || attribute;\n        this[property] = this._deserializeValue(value, type ||\n          this.constructor.typeForProperty(property));\n      }\n    }\n\n    /**\n     * Serializes a property to its associated attribute.\n     *\n     * @suppress {invalidCasts} Closure can't figure out `this` is an element.\n     *\n     * @param {string} property Property name to reflect.\n     * @param {string=} attribute Attribute name to reflect to.\n     * @param {*=} value Property value to refect.\n     * @return {void}\n     * @override\n     */\n    _propertyToAttribute(property, attribute, value) {\n      this.__serializing = true;\n      value = (arguments.length < 3) ? this[property] : value;\n      this._valueToNodeAttribute(/** @type {!HTMLElement} */(this), value,\n        attribute || this.constructor.attributeNameForProperty(property));\n      this.__serializing = false;\n    }\n\n    /**\n     * Sets a typed value to an HTML attribute on a node.\n     *\n     * This method calls the `_serializeValue` method to convert the typed\n     * value to a string.  If the `_serializeValue` method returns `undefined`,\n     * the attribute will be removed (this is the default for boolean\n     * type `false`).\n     *\n     * @param {Element} node Element to set attribute to.\n     * @param {*} value Value to serialize.\n     * @param {string} attribute Attribute name to serialize to.\n     * @return {void}\n     * @override\n     */\n    _valueToNodeAttribute(node, value, attribute) {\n      const str = this._serializeValue(value);\n      if (attribute === 'class' || attribute === 'name' || attribute === 'slot') {\n        node = /** @type {?Element} */(wrap(node));\n      }\n      if (str === undefined) {\n        node.removeAttribute(attribute);\n      } else {\n        node.setAttribute(\n            attribute,\n            // Closure's type for `setAttribute`'s second parameter incorrectly\n            // excludes `TrustedScript`.\n            (str === '' && window.trustedTypes) ?\n                /** @type {?} */ (window.trustedTypes.emptyScript) :\n                str);\n      }\n    }\n\n    /**\n     * Converts a typed JavaScript value to a string.\n     *\n     * This method is called when setting JS property values to\n     * HTML attributes.  Users may override this method to provide\n     * serialization for custom types.\n     *\n     * @param {*} value Property value to serialize.\n     * @return {string | undefined} String serialized from the provided\n     * property  value.\n     * @override\n     */\n    _serializeValue(value) {\n      switch (typeof value) {\n        case 'boolean':\n          return value ? '' : undefined;\n        default:\n          return value != null ? value.toString() : undefined;\n      }\n    }\n\n    /**\n     * Converts a string to a typed JavaScript value.\n     *\n     * This method is called when reading HTML attribute values to\n     * JS properties.  Users may override this method to provide\n     * deserialization for custom `type`s. Types for `Boolean`, `String`,\n     * and `Number` convert attributes to the expected types.\n     *\n     * @param {?string} value Value to deserialize.\n     * @param {*=} type Type to deserialize the string to.\n     * @return {*} Typed value deserialized from the provided string.\n     * @override\n     */\n    _deserializeValue(value, type) {\n      switch (type) {\n        case Boolean:\n          return (value !== null);\n        case Number:\n          return Number(value);\n        default:\n          return value;\n      }\n    }\n\n  }\n\n  return PropertiesChanged;\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}