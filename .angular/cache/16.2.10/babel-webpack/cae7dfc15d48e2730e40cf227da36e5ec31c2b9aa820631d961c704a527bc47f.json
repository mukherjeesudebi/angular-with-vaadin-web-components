{"ast":null,"code":"/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '../utils/boot.js';\nimport { dedupingMixin } from '../utils/mixin.js';\n\n// 1.x backwards-compatible auto-wrapper for template type extensions\n// This is a clear layering violation and gives favored-nation status to\n// dom-if and dom-repeat templates.  This is a conceit we're choosing to keep\n// a.) to ease 1.x backwards-compatibility due to loss of `is`, and\n// b.) to maintain if/repeat capability in parser-constrained elements\n//     (e.g. table, select) in lieu of native CE type extensions without\n//     massive new invention in this space (e.g. directive system)\nconst templateExtensions = {\n  'dom-if': true,\n  'dom-repeat': true\n};\nlet placeholderBugDetect = false;\nlet placeholderBug = false;\nfunction hasPlaceholderBug() {\n  if (!placeholderBugDetect) {\n    placeholderBugDetect = true;\n    const t = document.createElement('textarea');\n    t.placeholder = 'a';\n    placeholderBug = t.placeholder === t.textContent;\n  }\n  return placeholderBug;\n}\n\n/**\n * Some browsers have a bug with textarea, where placeholder text is copied as\n * a textnode child of the textarea.\n *\n * If the placeholder is a binding, this can break template stamping in two\n * ways.\n *\n * One issue is that when the `placeholder` attribute is removed when the\n * binding is processed, the textnode child of the textarea is deleted, and the\n * template info tries to bind into that node.\n *\n * With `legacyOptimizations` in use, when the template is stamped and the\n * `textarea.textContent` binding is processed, no corresponding node is found\n * because it was removed during parsing. An exception is generated when this\n * binding is updated.\n *\n * With `legacyOptimizations` not in use, the template is cloned before\n * processing and this changes the above behavior. The cloned template also has\n * a value property set to the placeholder and textContent. This prevents the\n * removal of the textContent when the placeholder attribute is removed.\n * Therefore the exception does not occur. However, there is an extra\n * unnecessary binding.\n *\n * @param {!Node} node Check node for placeholder bug\n * @return {void}\n */\nfunction fixPlaceholder(node) {\n  if (hasPlaceholderBug() && node.localName === 'textarea' && node.placeholder && node.placeholder === node.textContent) {\n    node.textContent = null;\n  }\n}\n\n/**\n * Copies an attribute from one element to another, converting the value to a\n * `TrustedScript` if it is named like a Polymer template event listener.\n *\n * @param {!Element} dest The element to set the attribute on\n * @param {!Element} src The element to read the attribute from\n * @param {string} name The name of the attribute\n */\nconst copyAttributeWithTemplateEventPolicy = (() => {\n  /**\n   * This `TrustedTypePolicy` is used to work around a Chrome bug in the Trusted\n   * Types API where any attribute that starts with `on` may only be set to a\n   * `TrustedScript` value, even if that attribute would not cause an event\n   * listener to be created. (See https://crbug.com/993268 for details.)\n   *\n   * Polymer's template system allows `<dom-if>` and `<dom-repeat>` to be\n   * written using the `<template is=\"...\">` syntax, even if there is no UA\n   * support for custom element extensions of built-in elements. In doing so, it\n   * copies attributes from the original `<template>` to a newly created\n   * `<dom-if>` or `<dom-repeat>`, which can trigger the bug mentioned above if\n   * any of those attributes uses Polymer's `on-` syntax for event listeners.\n   * (Note, the value of these `on-` listeners is not evaluated as script: it is\n   * the name of a member function of a component that will be used as the event\n   * listener.)\n   *\n   * @type {!TrustedTypePolicy|undefined}\n   */\n  const polymerTemplateEventAttributePolicy = window.trustedTypes && window.trustedTypes.createPolicy('polymer-template-event-attribute-policy', {\n    createScript: x => x\n  });\n  return (dest, src, name) => {\n    const value = src.getAttribute(name);\n    if (polymerTemplateEventAttributePolicy && name.startsWith('on-')) {\n      dest.setAttribute(name, polymerTemplateEventAttributePolicy.createScript(value, name));\n      return;\n    }\n    dest.setAttribute(name, value);\n  };\n})();\nfunction wrapTemplateExtension(node) {\n  let is = node.getAttribute('is');\n  if (is && templateExtensions[is]) {\n    let t = node;\n    t.removeAttribute('is');\n    node = t.ownerDocument.createElement(is);\n    t.parentNode.replaceChild(node, t);\n    node.appendChild(t);\n    while (t.attributes.length) {\n      const {\n        name\n      } = t.attributes[0];\n      copyAttributeWithTemplateEventPolicy(node, t, name);\n      t.removeAttribute(name);\n    }\n  }\n  return node;\n}\nfunction findTemplateNode(root, nodeInfo) {\n  // recursively ascend tree until we hit root\n  let parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);\n  // unwind the stack, returning the indexed node at each level\n  if (parent) {\n    // note: marginally faster than indexing via childNodes\n    // (http://jsperf.com/childnodes-lookup)\n    for (let n = parent.firstChild, i = 0; n; n = n.nextSibling) {\n      if (nodeInfo.parentIndex === i++) {\n        return n;\n      }\n    }\n  } else {\n    return root;\n  }\n}\n\n// construct `$` map (from id annotations)\nfunction applyIdToMap(inst, map, node, nodeInfo) {\n  if (nodeInfo.id) {\n    map[nodeInfo.id] = node;\n  }\n}\n\n// install event listeners (from event annotations)\nfunction applyEventListener(inst, node, nodeInfo) {\n  if (nodeInfo.events && nodeInfo.events.length) {\n    for (let j = 0, e$ = nodeInfo.events, e; j < e$.length && (e = e$[j]); j++) {\n      inst._addMethodEventListenerToNode(node, e.name, e.value, inst);\n    }\n  }\n}\n\n// push configuration references at configure time\nfunction applyTemplateInfo(inst, node, nodeInfo, parentTemplateInfo) {\n  if (nodeInfo.templateInfo) {\n    // Give the node an instance of this templateInfo and set its parent\n    node._templateInfo = nodeInfo.templateInfo;\n    node._parentTemplateInfo = parentTemplateInfo;\n  }\n}\nfunction createNodeEventHandler(context, eventName, methodName) {\n  // Instances can optionally have a _methodHost which allows redirecting where\n  // to find methods. Currently used by `templatize`.\n  context = context._methodHost || context;\n  let handler = function (e) {\n    if (context[methodName]) {\n      context[methodName](e, e.detail);\n    } else {\n      console.warn('listener method `' + methodName + '` not defined');\n    }\n  };\n  return handler;\n}\n\n/**\n * Element mixin that provides basic template parsing and stamping, including\n * the following template-related features for stamped templates:\n *\n * - Declarative event listeners (`on-eventname=\"listener\"`)\n * - Map of node id's to stamped node instances (`this.$.id`)\n * - Nested template content caching/removal and re-installation (performance\n *   optimization)\n *\n * @mixinFunction\n * @polymer\n * @summary Element class mixin that provides basic template parsing and stamping\n */\nexport const TemplateStamp = dedupingMixin(\n/**\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nsuperClass => {\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_TemplateStamp}\n   */\n  class TemplateStamp extends superClass {\n    /**\n     * Scans a template to produce template metadata.\n     *\n     * Template-specific metadata are stored in the object returned, and node-\n     * specific metadata are stored in objects in its flattened `nodeInfoList`\n     * array.  Only nodes in the template that were parsed as nodes of\n     * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object\n     * contains an `index` (`childNodes` index in parent) and optionally\n     * `parent`, which points to node info of its parent (including its index).\n     *\n     * The template metadata object returned from this method has the following\n     * structure (many fields optional):\n     *\n     * ```js\n     *   {\n     *     // Flattened list of node metadata (for nodes that generated metadata)\n     *     nodeInfoList: [\n     *       {\n     *         // `id` attribute for any nodes with id's for generating `$` map\n     *         id: {string},\n     *         // `on-event=\"handler\"` metadata\n     *         events: [\n     *           {\n     *             name: {string},   // event name\n     *             value: {string},  // handler method name\n     *           }, ...\n     *         ],\n     *         // Notes when the template contained a `<slot>` for shady DOM\n     *         // optimization purposes\n     *         hasInsertionPoint: {boolean},\n     *         // For nested `<template>`` nodes, nested template metadata\n     *         templateInfo: {object}, // nested template metadata\n     *         // Metadata to allow efficient retrieval of instanced node\n     *         // corresponding to this metadata\n     *         parentInfo: {number},   // reference to parent nodeInfo>\n     *         parentIndex: {number},  // index in parent's `childNodes` collection\n     *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`\n     *       },\n     *       ...\n     *     ],\n     *     // When true, the template had the `strip-whitespace` attribute\n     *     // or was nested in a template with that setting\n     *     stripWhitespace: {boolean},\n     *     // For nested templates, nested template content is moved into\n     *     // a document fragment stored here; this is an optimization to\n     *     // avoid the cost of nested template cloning\n     *     content: {DocumentFragment}\n     *   }\n     * ```\n     *\n     * This method kicks off a recursive treewalk as follows:\n     *\n     * ```\n     *    _parseTemplate <---------------------+\n     *      _parseTemplateContent              |\n     *        _parseTemplateNode  <------------|--+\n     *          _parseTemplateNestedTemplate --+  |\n     *          _parseTemplateChildNodes ---------+\n     *          _parseTemplateNodeAttributes\n     *            _parseTemplateNodeAttribute\n     *\n     * ```\n     *\n     * These methods may be overridden to add custom metadata about templates\n     * to either `templateInfo` or `nodeInfo`.\n     *\n     * Note that this method may be destructive to the template, in that\n     * e.g. event annotations may be removed after being noted in the\n     * template metadata.\n     *\n     * @param {!HTMLTemplateElement} template Template to parse\n     * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer\n     *   template, for parsing nested templates\n     * @return {!TemplateInfo} Parsed template metadata\n     * @nocollapse\n     */\n    static _parseTemplate(template, outerTemplateInfo) {\n      // since a template may be re-used, memo-ize metadata\n      if (!template._templateInfo) {\n        // TODO(rictic): fix typing\n        let /** ? */templateInfo = template._templateInfo = {};\n        templateInfo.nodeInfoList = [];\n        templateInfo.nestedTemplate = Boolean(outerTemplateInfo);\n        templateInfo.stripWhiteSpace = outerTemplateInfo && outerTemplateInfo.stripWhiteSpace || template.hasAttribute && template.hasAttribute('strip-whitespace');\n        // TODO(rictic): fix typing\n        this._parseTemplateContent(template, templateInfo, /** @type {?} */{\n          parent: null\n        });\n      }\n      return template._templateInfo;\n    }\n\n    /**\n     * See docs for _parseTemplateNode.\n     *\n     * @param {!HTMLTemplateElement} template .\n     * @param {!TemplateInfo} templateInfo .\n     * @param {!NodeInfo} nodeInfo .\n     * @return {boolean} .\n     * @nocollapse\n     */\n    static _parseTemplateContent(template, templateInfo, nodeInfo) {\n      return this._parseTemplateNode(template.content, templateInfo, nodeInfo);\n    }\n\n    /**\n     * Parses template node and adds template and node metadata based on\n     * the current node, and its `childNodes` and `attributes`.\n     *\n     * This method may be overridden to add custom node or template specific\n     * metadata based on this node.\n     *\n     * @param {Node} node Node to parse\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n    static _parseTemplateNode(node, templateInfo, nodeInfo) {\n      let noted = false;\n      let element = /** @type {!HTMLTemplateElement} */node;\n      if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {\n        noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;\n      } else if (element.localName === 'slot') {\n        // For ShadyDom optimization, indicating there is an insertion point\n        templateInfo.hasInsertionPoint = true;\n      }\n      fixPlaceholder(element);\n      if (element.firstChild) {\n        this._parseTemplateChildNodes(element, templateInfo, nodeInfo);\n      }\n      if (element.hasAttributes && element.hasAttributes()) {\n        noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;\n      }\n      // Checking `nodeInfo.noted` allows a child node of this node (who gets\n      // access to `parentInfo`) to cause the parent to be noted, which\n      // otherwise has no return path via `_parseTemplateChildNodes` (used by\n      // some optimizations)\n      return noted || nodeInfo.noted;\n    }\n\n    /**\n     * Parses template child nodes for the given root node.\n     *\n     * This method also wraps whitelisted legacy template extensions\n     * (`is=\"dom-if\"` and `is=\"dom-repeat\"`) with their equivalent element\n     * wrappers, collapses text nodes, and strips whitespace from the template\n     * if the `templateInfo.stripWhitespace` setting was provided.\n     *\n     * @param {Node} root Root node whose `childNodes` will be parsed\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {void}\n     */\n    static _parseTemplateChildNodes(root, templateInfo, nodeInfo) {\n      if (root.localName === 'script' || root.localName === 'style') {\n        return;\n      }\n      for (let node = root.firstChild, parentIndex = 0, next; node; node = next) {\n        // Wrap templates\n        if (node.localName == 'template') {\n          node = wrapTemplateExtension(node);\n        }\n        // collapse adjacent textNodes: fixes an IE issue that can cause\n        // text nodes to be inexplicably split =(\n        // note that root.normalize() should work but does not so we do this\n        // manually.\n        next = node.nextSibling;\n        if (node.nodeType === Node.TEXT_NODE) {\n          let /** Node */n = next;\n          while (n && n.nodeType === Node.TEXT_NODE) {\n            node.textContent += n.textContent;\n            next = n.nextSibling;\n            root.removeChild(n);\n            n = next;\n          }\n          // optionally strip whitespace\n          if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {\n            root.removeChild(node);\n            continue;\n          }\n        }\n        let childInfo = /** @type {!NodeInfo} */{\n          parentIndex,\n          parentInfo: nodeInfo\n        };\n        if (this._parseTemplateNode(node, templateInfo, childInfo)) {\n          childInfo.infoIndex = templateInfo.nodeInfoList.push(childInfo) - 1;\n        }\n        // Increment if not removed\n        if (node.parentNode) {\n          parentIndex++;\n        }\n      }\n    }\n\n    /**\n     * Parses template content for the given nested `<template>`.\n     *\n     * Nested template info is stored as `templateInfo` in the current node's\n     * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.\n     * It will then be the responsibility of the host to set it back to the\n     * template and for users stamping nested templates to use the\n     * `_contentForTemplate` method to retrieve the content for this template\n     * (an optimization to avoid the cost of cloning nested template content).\n     *\n     * @param {HTMLTemplateElement} node Node to parse (a <template>)\n     * @param {TemplateInfo} outerTemplateInfo Template metadata for current template\n     *   that includes the template `node`\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n    static _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {\n      // TODO(rictic): the type of node should be non-null\n      let element = /** @type {!HTMLTemplateElement} */node;\n      let templateInfo = this._parseTemplate(element, outerTemplateInfo);\n      let content = templateInfo.content = element.content.ownerDocument.createDocumentFragment();\n      content.appendChild(element.content);\n      nodeInfo.templateInfo = templateInfo;\n      return true;\n    }\n\n    /**\n     * Parses template node attributes and adds node metadata to `nodeInfo`\n     * for nodes of interest.\n     *\n     * @param {Element} node Node to parse\n     * @param {!TemplateInfo} templateInfo Template metadata for current\n     *     template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n    static _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {\n      // Make copy of original attribute list, since the order may change\n      // as attributes are added and removed\n      let noted = false;\n      let attrs = Array.from(node.attributes);\n      for (let i = attrs.length - 1, a; a = attrs[i]; i--) {\n        noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;\n      }\n      return noted;\n    }\n\n    /**\n     * Parses a single template node attribute and adds node metadata to\n     * `nodeInfo` for attributes of interest.\n     *\n     * This implementation adds metadata for `on-event=\"handler\"` attributes\n     * and `id` attributes.\n     *\n     * @param {Element} node Node to parse\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @param {string} name Attribute name\n     * @param {string} value Attribute value\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\n      // events (on-*)\n      if (name.slice(0, 3) === 'on-') {\n        node.removeAttribute(name);\n        nodeInfo.events = nodeInfo.events || [];\n        nodeInfo.events.push({\n          name: name.slice(3),\n          value\n        });\n        return true;\n      }\n      // static id\n      else if (name === 'id') {\n        nodeInfo.id = value;\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Returns the `content` document fragment for a given template.\n     *\n     * For nested templates, Polymer performs an optimization to cache nested\n     * template content to avoid the cost of cloning deeply nested templates.\n     * This method retrieves the cached content for a given template.\n     *\n     * @param {HTMLTemplateElement} template Template to retrieve `content` for\n     * @return {DocumentFragment} Content fragment\n     * @nocollapse\n     */\n    static _contentForTemplate(template) {\n      let templateInfo = /** @type {HTMLTemplateElementWithInfo} */template._templateInfo;\n      return templateInfo && templateInfo.content || template.content;\n    }\n\n    /**\n     * Clones the provided template content and returns a document fragment\n     * containing the cloned dom.\n     *\n     * The template is parsed (once and memoized) using this library's\n     * template parsing features, and provides the following value-added\n     * features:\n     * * Adds declarative event listeners for `on-event=\"handler\"` attributes\n     * * Generates an \"id map\" for all nodes with id's under `$` on returned\n     *   document fragment\n     * * Passes template info including `content` back to templates as\n     *   `_templateInfo` (a performance optimization to avoid deep template\n     *   cloning)\n     *\n     * Note that the memoized template parsing process is destructive to the\n     * template: attributes for bindings and declarative event listeners are\n     * removed after being noted in notes, and any nested `<template>.content`\n     * is removed and stored in notes as well.\n     *\n     * @param {!HTMLTemplateElement} template Template to stamp\n     * @param {TemplateInfo=} templateInfo Optional template info associated\n     *   with the template to be stamped; if omitted the template will be\n     *   automatically parsed.\n     * @return {!StampedTemplate} Cloned template content\n     * @override\n     */\n    _stampTemplate(template, templateInfo) {\n      // Polyfill support: bootstrap the template if it has not already been\n      if (template && !template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {\n        HTMLTemplateElement.decorate(template);\n      }\n      // Accepting the `templateInfo` via an argument allows for creating\n      // instances of the `templateInfo` by the caller, useful for adding\n      // instance-time information to the prototypical data\n      templateInfo = templateInfo || this.constructor._parseTemplate(template);\n      let nodeInfo = templateInfo.nodeInfoList;\n      let content = templateInfo.content || template.content;\n      let dom = /** @type {DocumentFragment} */document.importNode(content, true);\n      // NOTE: ShadyDom optimization indicating there is an insertion point\n      dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;\n      let nodes = dom.nodeList = new Array(nodeInfo.length);\n      dom.$ = {};\n      for (let i = 0, l = nodeInfo.length, info; i < l && (info = nodeInfo[i]); i++) {\n        let node = nodes[i] = findTemplateNode(dom, info);\n        applyIdToMap(this, dom.$, node, info);\n        applyTemplateInfo(this, node, info, templateInfo);\n        applyEventListener(this, node, info);\n      }\n      dom = /** @type {!StampedTemplate} */dom; // eslint-disable-line no-self-assign\n      return dom;\n    }\n\n    /**\n     * Adds an event listener by method name for the event provided.\n     *\n     * This method generates a handler function that looks up the method\n     * name at handling time.\n     *\n     * @param {!EventTarget} node Node to add listener on\n     * @param {string} eventName Name of event\n     * @param {string} methodName Name of method\n     * @param {*=} context Context the method will be called on (defaults\n     *   to `node`)\n     * @return {Function} Generated handler function\n     * @override\n     */\n    _addMethodEventListenerToNode(node, eventName, methodName, context) {\n      context = context || node;\n      let handler = createNodeEventHandler(context, eventName, methodName);\n      this._addEventListenerToNode(node, eventName, handler);\n      return handler;\n    }\n\n    /**\n     * Override point for adding custom or simulated event handling.\n     *\n     * @param {!EventTarget} node Node to add event listener to\n     * @param {string} eventName Name of event\n     * @param {function(!Event):void} handler Listener function to add\n     * @return {void}\n     * @override\n     */\n    _addEventListenerToNode(node, eventName, handler) {\n      node.addEventListener(eventName, handler);\n    }\n\n    /**\n     * Override point for adding custom or simulated event handling.\n     *\n     * @param {!EventTarget} node Node to remove event listener from\n     * @param {string} eventName Name of event\n     * @param {function(!Event):void} handler Listener function to remove\n     * @return {void}\n     * @override\n     */\n    _removeEventListenerFromNode(node, eventName, handler) {\n      node.removeEventListener(eventName, handler);\n    }\n  }\n  return TemplateStamp;\n});","map":{"version":3,"names":["dedupingMixin","templateExtensions","placeholderBugDetect","placeholderBug","hasPlaceholderBug","t","document","createElement","placeholder","textContent","fixPlaceholder","node","localName","copyAttributeWithTemplateEventPolicy","polymerTemplateEventAttributePolicy","window","trustedTypes","createPolicy","createScript","x","dest","src","name","value","getAttribute","startsWith","setAttribute","wrapTemplateExtension","is","removeAttribute","ownerDocument","parentNode","replaceChild","appendChild","attributes","length","findTemplateNode","root","nodeInfo","parent","parentInfo","n","firstChild","i","nextSibling","parentIndex","applyIdToMap","inst","map","id","applyEventListener","events","j","e$","e","_addMethodEventListenerToNode","applyTemplateInfo","parentTemplateInfo","templateInfo","_templateInfo","_parentTemplateInfo","createNodeEventHandler","context","eventName","methodName","_methodHost","handler","detail","console","warn","TemplateStamp","superClass","_parseTemplate","template","outerTemplateInfo","nodeInfoList","nestedTemplate","Boolean","stripWhiteSpace","hasAttribute","_parseTemplateContent","_parseTemplateNode","content","noted","element","_parseTemplateNestedTemplate","hasInsertionPoint","_parseTemplateChildNodes","hasAttributes","_parseTemplateNodeAttributes","next","nodeType","Node","TEXT_NODE","removeChild","trim","childInfo","infoIndex","push","createDocumentFragment","attrs","Array","from","a","_parseTemplateNodeAttribute","slice","_contentForTemplate","_stampTemplate","HTMLTemplateElement","decorate","constructor","dom","importNode","__noInsertionPoint","nodes","nodeList","$","l","info","_addEventListenerToNode","addEventListener","_removeEventListenerFromNode","removeEventListener"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@polymer/polymer/lib/mixins/template-stamp.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '../utils/boot.js';\n\nimport { dedupingMixin } from '../utils/mixin.js';\n\n// 1.x backwards-compatible auto-wrapper for template type extensions\n// This is a clear layering violation and gives favored-nation status to\n// dom-if and dom-repeat templates.  This is a conceit we're choosing to keep\n// a.) to ease 1.x backwards-compatibility due to loss of `is`, and\n// b.) to maintain if/repeat capability in parser-constrained elements\n//     (e.g. table, select) in lieu of native CE type extensions without\n//     massive new invention in this space (e.g. directive system)\nconst templateExtensions = {\n  'dom-if': true,\n  'dom-repeat': true\n};\n\nlet placeholderBugDetect = false;\nlet placeholderBug = false;\n\nfunction hasPlaceholderBug() {\n  if (!placeholderBugDetect) {\n    placeholderBugDetect = true;\n    const t = document.createElement('textarea');\n    t.placeholder = 'a';\n    placeholderBug = t.placeholder === t.textContent;\n  }\n  return placeholderBug;\n}\n\n/**\n * Some browsers have a bug with textarea, where placeholder text is copied as\n * a textnode child of the textarea.\n *\n * If the placeholder is a binding, this can break template stamping in two\n * ways.\n *\n * One issue is that when the `placeholder` attribute is removed when the\n * binding is processed, the textnode child of the textarea is deleted, and the\n * template info tries to bind into that node.\n *\n * With `legacyOptimizations` in use, when the template is stamped and the\n * `textarea.textContent` binding is processed, no corresponding node is found\n * because it was removed during parsing. An exception is generated when this\n * binding is updated.\n *\n * With `legacyOptimizations` not in use, the template is cloned before\n * processing and this changes the above behavior. The cloned template also has\n * a value property set to the placeholder and textContent. This prevents the\n * removal of the textContent when the placeholder attribute is removed.\n * Therefore the exception does not occur. However, there is an extra\n * unnecessary binding.\n *\n * @param {!Node} node Check node for placeholder bug\n * @return {void}\n */\nfunction fixPlaceholder(node) {\n  if (hasPlaceholderBug() && node.localName === 'textarea' && node.placeholder\n        && node.placeholder === node.textContent) {\n    node.textContent = null;\n  }\n}\n\n/**\n * Copies an attribute from one element to another, converting the value to a\n * `TrustedScript` if it is named like a Polymer template event listener.\n *\n * @param {!Element} dest The element to set the attribute on\n * @param {!Element} src The element to read the attribute from\n * @param {string} name The name of the attribute\n */\nconst copyAttributeWithTemplateEventPolicy = (() => {\n  /**\n   * This `TrustedTypePolicy` is used to work around a Chrome bug in the Trusted\n   * Types API where any attribute that starts with `on` may only be set to a\n   * `TrustedScript` value, even if that attribute would not cause an event\n   * listener to be created. (See https://crbug.com/993268 for details.)\n   *\n   * Polymer's template system allows `<dom-if>` and `<dom-repeat>` to be\n   * written using the `<template is=\"...\">` syntax, even if there is no UA\n   * support for custom element extensions of built-in elements. In doing so, it\n   * copies attributes from the original `<template>` to a newly created\n   * `<dom-if>` or `<dom-repeat>`, which can trigger the bug mentioned above if\n   * any of those attributes uses Polymer's `on-` syntax for event listeners.\n   * (Note, the value of these `on-` listeners is not evaluated as script: it is\n   * the name of a member function of a component that will be used as the event\n   * listener.)\n   *\n   * @type {!TrustedTypePolicy|undefined}\n   */\n  const polymerTemplateEventAttributePolicy = window.trustedTypes &&\n      window.trustedTypes.createPolicy(\n          'polymer-template-event-attribute-policy', {\n            createScript: x => x,\n          });\n\n  return (dest, src, name) => {\n    const value = src.getAttribute(name);\n\n    if (polymerTemplateEventAttributePolicy && name.startsWith('on-')) {\n      dest.setAttribute(\n          name, polymerTemplateEventAttributePolicy.createScript(value, name));\n      return;\n    }\n\n    dest.setAttribute(name, value);\n  };\n})();\n\nfunction wrapTemplateExtension(node) {\n  let is = node.getAttribute('is');\n  if (is && templateExtensions[is]) {\n    let t = node;\n    t.removeAttribute('is');\n    node = t.ownerDocument.createElement(is);\n    t.parentNode.replaceChild(node, t);\n    node.appendChild(t);\n    while(t.attributes.length) {\n      const {name} = t.attributes[0];\n      copyAttributeWithTemplateEventPolicy(node, t, name);\n      t.removeAttribute(name);\n    }\n  }\n  return node;\n}\n\nfunction findTemplateNode(root, nodeInfo) {\n  // recursively ascend tree until we hit root\n  let parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);\n  // unwind the stack, returning the indexed node at each level\n  if (parent) {\n    // note: marginally faster than indexing via childNodes\n    // (http://jsperf.com/childnodes-lookup)\n    for (let n=parent.firstChild, i=0; n; n=n.nextSibling) {\n      if (nodeInfo.parentIndex === i++) {\n        return n;\n      }\n    }\n  } else {\n    return root;\n  }\n}\n\n// construct `$` map (from id annotations)\nfunction applyIdToMap(inst, map, node, nodeInfo) {\n  if (nodeInfo.id) {\n    map[nodeInfo.id] = node;\n  }\n}\n\n// install event listeners (from event annotations)\nfunction applyEventListener(inst, node, nodeInfo) {\n  if (nodeInfo.events && nodeInfo.events.length) {\n    for (let j=0, e$=nodeInfo.events, e; (j<e$.length) && (e=e$[j]); j++) {\n      inst._addMethodEventListenerToNode(node, e.name, e.value, inst);\n    }\n  }\n}\n\n// push configuration references at configure time\nfunction applyTemplateInfo(inst, node, nodeInfo, parentTemplateInfo) {\n  if (nodeInfo.templateInfo) {\n    // Give the node an instance of this templateInfo and set its parent\n    node._templateInfo = nodeInfo.templateInfo;\n    node._parentTemplateInfo = parentTemplateInfo;\n  }\n}\n\nfunction createNodeEventHandler(context, eventName, methodName) {\n  // Instances can optionally have a _methodHost which allows redirecting where\n  // to find methods. Currently used by `templatize`.\n  context = context._methodHost || context;\n  let handler = function(e) {\n    if (context[methodName]) {\n      context[methodName](e, e.detail);\n    } else {\n      console.warn('listener method `' + methodName + '` not defined');\n    }\n  };\n  return handler;\n}\n\n/**\n * Element mixin that provides basic template parsing and stamping, including\n * the following template-related features for stamped templates:\n *\n * - Declarative event listeners (`on-eventname=\"listener\"`)\n * - Map of node id's to stamped node instances (`this.$.id`)\n * - Nested template content caching/removal and re-installation (performance\n *   optimization)\n *\n * @mixinFunction\n * @polymer\n * @summary Element class mixin that provides basic template parsing and stamping\n */\nexport const TemplateStamp = dedupingMixin(\n    /**\n     * @template T\n     * @param {function(new:T)} superClass Class to apply mixin to.\n     * @return {function(new:T)} superClass with mixin applied.\n     */\n    (superClass) => {\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_TemplateStamp}\n   */\n  class TemplateStamp extends superClass {\n\n    /**\n     * Scans a template to produce template metadata.\n     *\n     * Template-specific metadata are stored in the object returned, and node-\n     * specific metadata are stored in objects in its flattened `nodeInfoList`\n     * array.  Only nodes in the template that were parsed as nodes of\n     * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object\n     * contains an `index` (`childNodes` index in parent) and optionally\n     * `parent`, which points to node info of its parent (including its index).\n     *\n     * The template metadata object returned from this method has the following\n     * structure (many fields optional):\n     *\n     * ```js\n     *   {\n     *     // Flattened list of node metadata (for nodes that generated metadata)\n     *     nodeInfoList: [\n     *       {\n     *         // `id` attribute for any nodes with id's for generating `$` map\n     *         id: {string},\n     *         // `on-event=\"handler\"` metadata\n     *         events: [\n     *           {\n     *             name: {string},   // event name\n     *             value: {string},  // handler method name\n     *           }, ...\n     *         ],\n     *         // Notes when the template contained a `<slot>` for shady DOM\n     *         // optimization purposes\n     *         hasInsertionPoint: {boolean},\n     *         // For nested `<template>`` nodes, nested template metadata\n     *         templateInfo: {object}, // nested template metadata\n     *         // Metadata to allow efficient retrieval of instanced node\n     *         // corresponding to this metadata\n     *         parentInfo: {number},   // reference to parent nodeInfo>\n     *         parentIndex: {number},  // index in parent's `childNodes` collection\n     *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`\n     *       },\n     *       ...\n     *     ],\n     *     // When true, the template had the `strip-whitespace` attribute\n     *     // or was nested in a template with that setting\n     *     stripWhitespace: {boolean},\n     *     // For nested templates, nested template content is moved into\n     *     // a document fragment stored here; this is an optimization to\n     *     // avoid the cost of nested template cloning\n     *     content: {DocumentFragment}\n     *   }\n     * ```\n     *\n     * This method kicks off a recursive treewalk as follows:\n     *\n     * ```\n     *    _parseTemplate <---------------------+\n     *      _parseTemplateContent              |\n     *        _parseTemplateNode  <------------|--+\n     *          _parseTemplateNestedTemplate --+  |\n     *          _parseTemplateChildNodes ---------+\n     *          _parseTemplateNodeAttributes\n     *            _parseTemplateNodeAttribute\n     *\n     * ```\n     *\n     * These methods may be overridden to add custom metadata about templates\n     * to either `templateInfo` or `nodeInfo`.\n     *\n     * Note that this method may be destructive to the template, in that\n     * e.g. event annotations may be removed after being noted in the\n     * template metadata.\n     *\n     * @param {!HTMLTemplateElement} template Template to parse\n     * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer\n     *   template, for parsing nested templates\n     * @return {!TemplateInfo} Parsed template metadata\n     * @nocollapse\n     */\n    static _parseTemplate(template, outerTemplateInfo) {\n      // since a template may be re-used, memo-ize metadata\n      if (!template._templateInfo) {\n        // TODO(rictic): fix typing\n        let /** ? */ templateInfo = template._templateInfo = {};\n        templateInfo.nodeInfoList = [];\n        templateInfo.nestedTemplate = Boolean(outerTemplateInfo);\n        templateInfo.stripWhiteSpace =\n          (outerTemplateInfo && outerTemplateInfo.stripWhiteSpace) ||\n          (template.hasAttribute && template.hasAttribute('strip-whitespace'));\n         // TODO(rictic): fix typing\n         this._parseTemplateContent(\n             template, templateInfo, /** @type {?} */ ({parent: null}));\n      }\n      return template._templateInfo;\n    }\n\n    /**\n     * See docs for _parseTemplateNode.\n     *\n     * @param {!HTMLTemplateElement} template .\n     * @param {!TemplateInfo} templateInfo .\n     * @param {!NodeInfo} nodeInfo .\n     * @return {boolean} .\n     * @nocollapse\n     */\n    static _parseTemplateContent(template, templateInfo, nodeInfo) {\n      return this._parseTemplateNode(template.content, templateInfo, nodeInfo);\n    }\n\n    /**\n     * Parses template node and adds template and node metadata based on\n     * the current node, and its `childNodes` and `attributes`.\n     *\n     * This method may be overridden to add custom node or template specific\n     * metadata based on this node.\n     *\n     * @param {Node} node Node to parse\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n    static _parseTemplateNode(node, templateInfo, nodeInfo) {\n      let noted = false;\n      let element = /** @type {!HTMLTemplateElement} */ (node);\n      if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {\n        noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;\n      } else if (element.localName === 'slot') {\n        // For ShadyDom optimization, indicating there is an insertion point\n        templateInfo.hasInsertionPoint = true;\n      }\n      fixPlaceholder(element);\n      if (element.firstChild) {\n        this._parseTemplateChildNodes(element, templateInfo, nodeInfo);\n      }\n      if (element.hasAttributes && element.hasAttributes()) {\n        noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;\n      }\n      // Checking `nodeInfo.noted` allows a child node of this node (who gets\n      // access to `parentInfo`) to cause the parent to be noted, which\n      // otherwise has no return path via `_parseTemplateChildNodes` (used by\n      // some optimizations)\n      return noted || nodeInfo.noted;\n    }\n\n    /**\n     * Parses template child nodes for the given root node.\n     *\n     * This method also wraps whitelisted legacy template extensions\n     * (`is=\"dom-if\"` and `is=\"dom-repeat\"`) with their equivalent element\n     * wrappers, collapses text nodes, and strips whitespace from the template\n     * if the `templateInfo.stripWhitespace` setting was provided.\n     *\n     * @param {Node} root Root node whose `childNodes` will be parsed\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {void}\n     */\n    static _parseTemplateChildNodes(root, templateInfo, nodeInfo) {\n      if (root.localName === 'script' || root.localName === 'style') {\n        return;\n      }\n      for (let node=root.firstChild, parentIndex=0, next; node; node=next) {\n        // Wrap templates\n        if (node.localName == 'template') {\n          node = wrapTemplateExtension(node);\n        }\n        // collapse adjacent textNodes: fixes an IE issue that can cause\n        // text nodes to be inexplicably split =(\n        // note that root.normalize() should work but does not so we do this\n        // manually.\n        next = node.nextSibling;\n        if (node.nodeType === Node.TEXT_NODE) {\n          let /** Node */ n = next;\n          while (n && (n.nodeType === Node.TEXT_NODE)) {\n            node.textContent += n.textContent;\n            next = n.nextSibling;\n            root.removeChild(n);\n            n = next;\n          }\n          // optionally strip whitespace\n          if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {\n            root.removeChild(node);\n            continue;\n          }\n        }\n        let childInfo =\n            /** @type {!NodeInfo} */ ({parentIndex, parentInfo: nodeInfo});\n        if (this._parseTemplateNode(node, templateInfo, childInfo)) {\n          childInfo.infoIndex = templateInfo.nodeInfoList.push(childInfo) - 1;\n        }\n        // Increment if not removed\n        if (node.parentNode) {\n          parentIndex++;\n        }\n      }\n    }\n\n    /**\n     * Parses template content for the given nested `<template>`.\n     *\n     * Nested template info is stored as `templateInfo` in the current node's\n     * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.\n     * It will then be the responsibility of the host to set it back to the\n     * template and for users stamping nested templates to use the\n     * `_contentForTemplate` method to retrieve the content for this template\n     * (an optimization to avoid the cost of cloning nested template content).\n     *\n     * @param {HTMLTemplateElement} node Node to parse (a <template>)\n     * @param {TemplateInfo} outerTemplateInfo Template metadata for current template\n     *   that includes the template `node`\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n    static _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {\n      // TODO(rictic): the type of node should be non-null\n      let element = /** @type {!HTMLTemplateElement} */ (node);\n      let templateInfo = this._parseTemplate(element, outerTemplateInfo);\n      let content = templateInfo.content =\n          element.content.ownerDocument.createDocumentFragment();\n      content.appendChild(element.content);\n      nodeInfo.templateInfo = templateInfo;\n      return true;\n    }\n\n    /**\n     * Parses template node attributes and adds node metadata to `nodeInfo`\n     * for nodes of interest.\n     *\n     * @param {Element} node Node to parse\n     * @param {!TemplateInfo} templateInfo Template metadata for current\n     *     template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n    static _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {\n      // Make copy of original attribute list, since the order may change\n      // as attributes are added and removed\n      let noted = false;\n      let attrs = Array.from(node.attributes);\n      for (let i=attrs.length-1, a; (a=attrs[i]); i--) {\n        noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;\n      }\n      return noted;\n    }\n\n    /**\n     * Parses a single template node attribute and adds node metadata to\n     * `nodeInfo` for attributes of interest.\n     *\n     * This implementation adds metadata for `on-event=\"handler\"` attributes\n     * and `id` attributes.\n     *\n     * @param {Element} node Node to parse\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @param {string} name Attribute name\n     * @param {string} value Attribute value\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\n      // events (on-*)\n      if (name.slice(0, 3) === 'on-') {\n        node.removeAttribute(name);\n        nodeInfo.events = nodeInfo.events || [];\n        nodeInfo.events.push({\n          name: name.slice(3),\n          value\n        });\n        return true;\n      }\n      // static id\n      else if (name === 'id') {\n        nodeInfo.id = value;\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Returns the `content` document fragment for a given template.\n     *\n     * For nested templates, Polymer performs an optimization to cache nested\n     * template content to avoid the cost of cloning deeply nested templates.\n     * This method retrieves the cached content for a given template.\n     *\n     * @param {HTMLTemplateElement} template Template to retrieve `content` for\n     * @return {DocumentFragment} Content fragment\n     * @nocollapse\n     */\n    static _contentForTemplate(template) {\n      let templateInfo = /** @type {HTMLTemplateElementWithInfo} */ (template)._templateInfo;\n      return (templateInfo && templateInfo.content) || template.content;\n    }\n\n    /**\n     * Clones the provided template content and returns a document fragment\n     * containing the cloned dom.\n     *\n     * The template is parsed (once and memoized) using this library's\n     * template parsing features, and provides the following value-added\n     * features:\n     * * Adds declarative event listeners for `on-event=\"handler\"` attributes\n     * * Generates an \"id map\" for all nodes with id's under `$` on returned\n     *   document fragment\n     * * Passes template info including `content` back to templates as\n     *   `_templateInfo` (a performance optimization to avoid deep template\n     *   cloning)\n     *\n     * Note that the memoized template parsing process is destructive to the\n     * template: attributes for bindings and declarative event listeners are\n     * removed after being noted in notes, and any nested `<template>.content`\n     * is removed and stored in notes as well.\n     *\n     * @param {!HTMLTemplateElement} template Template to stamp\n     * @param {TemplateInfo=} templateInfo Optional template info associated\n     *   with the template to be stamped; if omitted the template will be\n     *   automatically parsed.\n     * @return {!StampedTemplate} Cloned template content\n     * @override\n     */\n    _stampTemplate(template, templateInfo) {\n      // Polyfill support: bootstrap the template if it has not already been\n      if (template && !template.content &&\n          window.HTMLTemplateElement && HTMLTemplateElement.decorate) {\n        HTMLTemplateElement.decorate(template);\n      }\n      // Accepting the `templateInfo` via an argument allows for creating\n      // instances of the `templateInfo` by the caller, useful for adding\n      // instance-time information to the prototypical data\n      templateInfo = templateInfo || this.constructor._parseTemplate(template);\n      let nodeInfo = templateInfo.nodeInfoList;\n      let content = templateInfo.content || template.content;\n      let dom = /** @type {DocumentFragment} */ (document.importNode(content, true));\n      // NOTE: ShadyDom optimization indicating there is an insertion point\n      dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;\n      let nodes = dom.nodeList = new Array(nodeInfo.length);\n      dom.$ = {};\n      for (let i=0, l=nodeInfo.length, info; (i<l) && (info=nodeInfo[i]); i++) {\n        let node = nodes[i] = findTemplateNode(dom, info);\n        applyIdToMap(this, dom.$, node, info);\n        applyTemplateInfo(this, node, info, templateInfo);\n        applyEventListener(this, node, info);\n      }\n      dom = /** @type {!StampedTemplate} */(dom); // eslint-disable-line no-self-assign\n      return dom;\n    }\n\n    /**\n     * Adds an event listener by method name for the event provided.\n     *\n     * This method generates a handler function that looks up the method\n     * name at handling time.\n     *\n     * @param {!EventTarget} node Node to add listener on\n     * @param {string} eventName Name of event\n     * @param {string} methodName Name of method\n     * @param {*=} context Context the method will be called on (defaults\n     *   to `node`)\n     * @return {Function} Generated handler function\n     * @override\n     */\n    _addMethodEventListenerToNode(node, eventName, methodName, context) {\n      context = context || node;\n      let handler = createNodeEventHandler(context, eventName, methodName);\n      this._addEventListenerToNode(node, eventName, handler);\n      return handler;\n    }\n\n    /**\n     * Override point for adding custom or simulated event handling.\n     *\n     * @param {!EventTarget} node Node to add event listener to\n     * @param {string} eventName Name of event\n     * @param {function(!Event):void} handler Listener function to add\n     * @return {void}\n     * @override\n     */\n    _addEventListenerToNode(node, eventName, handler) {\n      node.addEventListener(eventName, handler);\n    }\n\n    /**\n     * Override point for adding custom or simulated event handling.\n     *\n     * @param {!EventTarget} node Node to remove event listener from\n     * @param {string} eventName Name of event\n     * @param {function(!Event):void} handler Listener function to remove\n     * @return {void}\n     * @override\n     */\n    _removeEventListenerFromNode(node, eventName, handler) {\n      node.removeEventListener(eventName, handler);\n    }\n\n  }\n\n  return TemplateStamp;\n\n});\n"],"mappings":"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ClC,CAAC,MAAM;MACLC,OAAO,CAACC,IAAI,CAAC,mBAAmB,GAAGL,UAAU,GAAG,eAAe,CAAC;IAClE;EACF,CAAC;EACD,OAAOE,OAAO;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMI,aAAa,GAAGtE,aAAa;AACtC;AACJ;AACA;AACA;AACA;AACKuE,UAAU,IAAK;EAElB;AACF;AACA;AACA;AACA;EACE,MAAMD,aAAa,SAASC,UAAU,CAAC;IAErC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,OAAOC,cAAcA,CAACC,QAAQ,EAAEC,iBAAiB,EAAE;MACjD;MACA,IAAI,CAACD,QAAQ,CAACd,aAAa,EAAE;QAC3B;QACA,IAAI,QAASD,YAAY,GAAGe,QAAQ,CAACd,aAAa,GAAG,CAAC,CAAC;QACvDD,YAAY,CAACiB,YAAY,GAAG,EAAE;QAC9BjB,YAAY,CAACkB,cAAc,GAAGC,OAAO,CAACH,iBAAiB,CAAC;QACxDhB,YAAY,CAACoB,eAAe,GACzBJ,iBAAiB,IAAIA,iBAAiB,CAACI,eAAe,IACtDL,QAAQ,CAACM,YAAY,IAAIN,QAAQ,CAACM,YAAY,CAAC,kBAAkB,CAAE;QACrE;QACA,IAAI,CAACC,qBAAqB,CACtBP,QAAQ,EAAEf,YAAY,EAAE,gBAAkB;UAACnB,MAAM,EAAE;QAAI,CAAE,CAAC;MACjE;MACA,OAAOkC,QAAQ,CAACd,aAAa;IAC/B;;IAEA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"},"metadata":{},"sourceType":"module","externalDependencies":[]}