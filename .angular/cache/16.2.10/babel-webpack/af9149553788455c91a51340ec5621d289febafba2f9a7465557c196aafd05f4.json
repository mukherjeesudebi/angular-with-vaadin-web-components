{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2021 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n/**\n * Array of Vaadin custom element classes that have been subscribed to the dir changes.\n */\nconst directionSubscribers = [];\nfunction alignDirs(element, documentDir, elementDir = element.getAttribute('dir')) {\n  if (documentDir) {\n    element.setAttribute('dir', documentDir);\n  } else if (elementDir != null) {\n    element.removeAttribute('dir');\n  }\n}\nfunction getDocumentDir() {\n  return document.documentElement.getAttribute('dir');\n}\nfunction directionUpdater() {\n  const documentDir = getDocumentDir();\n  directionSubscribers.forEach(element => {\n    alignDirs(element, documentDir);\n  });\n}\nconst directionObserver = new MutationObserver(directionUpdater);\ndirectionObserver.observe(document.documentElement, {\n  attributes: true,\n  attributeFilter: ['dir']\n});\n\n/**\n * A mixin to handle `dir` attribute based on the one set on the `<html>` element.\n *\n * @polymerMixin\n */\nexport const DirMixin = superClass => class VaadinDirMixin extends superClass {\n  static get properties() {\n    return {\n      /**\n       * @protected\n       */\n      dir: {\n        type: String,\n        value: '',\n        reflectToAttribute: true,\n        converter: {\n          fromAttribute: attr => {\n            return !attr ? '' : attr;\n          },\n          toAttribute: prop => {\n            return prop === '' ? null : prop;\n          }\n        }\n      }\n    };\n  }\n\n  /**\n   * @return {boolean}\n   * @protected\n   */\n  get __isRTL() {\n    return this.getAttribute('dir') === 'rtl';\n  }\n\n  /** @protected */\n  connectedCallback() {\n    super.connectedCallback();\n    if (!this.hasAttribute('dir') || this.__restoreSubscription) {\n      this.__subscribe();\n      alignDirs(this, getDocumentDir(), null);\n    }\n  }\n\n  /** @protected */\n  attributeChangedCallback(name, oldValue, newValue) {\n    super.attributeChangedCallback(name, oldValue, newValue);\n    if (name !== 'dir') {\n      return;\n    }\n    const documentDir = getDocumentDir();\n\n    // New value equals to the document direction and the element is not subscribed to the changes\n    const newValueEqlDocDir = newValue === documentDir && directionSubscribers.indexOf(this) === -1;\n    // Value was emptied and the element is not subscribed to the changes\n    const newValueEmptied = !newValue && oldValue && directionSubscribers.indexOf(this) === -1;\n    // New value is different and the old equals to document direction and the element is not subscribed to the changes\n    const newDiffValue = newValue !== documentDir && oldValue === documentDir;\n    if (newValueEqlDocDir || newValueEmptied) {\n      this.__subscribe();\n      alignDirs(this, documentDir, newValue);\n    } else if (newDiffValue) {\n      this.__unsubscribe();\n    }\n  }\n\n  /** @protected */\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this.__restoreSubscription = directionSubscribers.includes(this);\n    this.__unsubscribe();\n  }\n\n  /** @protected */\n  _valueToNodeAttribute(node, value, attribute) {\n    // Override default Polymer attribute reflection to match native behavior of HTMLElement.dir property\n    // If the property contains an empty string then it should not create an empty attribute\n    if (attribute === 'dir' && value === '' && !node.hasAttribute('dir')) {\n      return;\n    }\n    super._valueToNodeAttribute(node, value, attribute);\n  }\n\n  /** @protected */\n  _attributeToProperty(attribute, value, type) {\n    // Override default Polymer attribute reflection to match native behavior of HTMLElement.dir property\n    // If the attribute is removed, then the dir property should contain an empty string instead of null\n    if (attribute === 'dir' && !value) {\n      this.dir = '';\n    } else {\n      super._attributeToProperty(attribute, value, type);\n    }\n  }\n\n  /** @private */\n  __subscribe() {\n    if (!directionSubscribers.includes(this)) {\n      directionSubscribers.push(this);\n    }\n  }\n\n  /** @private */\n  __unsubscribe() {\n    if (directionSubscribers.includes(this)) {\n      directionSubscribers.splice(directionSubscribers.indexOf(this), 1);\n    }\n  }\n};","map":{"version":3,"names":["directionSubscribers","alignDirs","element","documentDir","elementDir","getAttribute","setAttribute","removeAttribute","getDocumentDir","document","documentElement","directionUpdater","forEach","directionObserver","MutationObserver","observe","attributes","attributeFilter","DirMixin","superClass","VaadinDirMixin","properties","dir","type","String","value","reflectToAttribute","converter","fromAttribute","attr","toAttribute","prop","__isRTL","connectedCallback","hasAttribute","__restoreSubscription","__subscribe","attributeChangedCallback","name","oldValue","newValue","newValueEqlDocDir","indexOf","newValueEmptied","newDiffValue","__unsubscribe","disconnectedCallback","includes","_valueToNodeAttribute","node","attribute","_attributeToProperty","push","splice"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@vaadin/component-base/src/dir-mixin.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2021 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n/**\n * Array of Vaadin custom element classes that have been subscribed to the dir changes.\n */\nconst directionSubscribers = [];\n\nfunction alignDirs(element, documentDir, elementDir = element.getAttribute('dir')) {\n  if (documentDir) {\n    element.setAttribute('dir', documentDir);\n  } else if (elementDir != null) {\n    element.removeAttribute('dir');\n  }\n}\n\nfunction getDocumentDir() {\n  return document.documentElement.getAttribute('dir');\n}\n\nfunction directionUpdater() {\n  const documentDir = getDocumentDir();\n  directionSubscribers.forEach((element) => {\n    alignDirs(element, documentDir);\n  });\n}\n\nconst directionObserver = new MutationObserver(directionUpdater);\ndirectionObserver.observe(document.documentElement, { attributes: true, attributeFilter: ['dir'] });\n\n/**\n * A mixin to handle `dir` attribute based on the one set on the `<html>` element.\n *\n * @polymerMixin\n */\nexport const DirMixin = (superClass) =>\n  class VaadinDirMixin extends superClass {\n    static get properties() {\n      return {\n        /**\n         * @protected\n         */\n        dir: {\n          type: String,\n          value: '',\n          reflectToAttribute: true,\n          converter: {\n            fromAttribute: (attr) => {\n              return !attr ? '' : attr;\n            },\n            toAttribute: (prop) => {\n              return prop === '' ? null : prop;\n            },\n          },\n        },\n      };\n    }\n\n    /**\n     * @return {boolean}\n     * @protected\n     */\n    get __isRTL() {\n      return this.getAttribute('dir') === 'rtl';\n    }\n\n    /** @protected */\n    connectedCallback() {\n      super.connectedCallback();\n\n      if (!this.hasAttribute('dir') || this.__restoreSubscription) {\n        this.__subscribe();\n        alignDirs(this, getDocumentDir(), null);\n      }\n    }\n\n    /** @protected */\n    attributeChangedCallback(name, oldValue, newValue) {\n      super.attributeChangedCallback(name, oldValue, newValue);\n      if (name !== 'dir') {\n        return;\n      }\n\n      const documentDir = getDocumentDir();\n\n      // New value equals to the document direction and the element is not subscribed to the changes\n      const newValueEqlDocDir = newValue === documentDir && directionSubscribers.indexOf(this) === -1;\n      // Value was emptied and the element is not subscribed to the changes\n      const newValueEmptied = !newValue && oldValue && directionSubscribers.indexOf(this) === -1;\n      // New value is different and the old equals to document direction and the element is not subscribed to the changes\n      const newDiffValue = newValue !== documentDir && oldValue === documentDir;\n\n      if (newValueEqlDocDir || newValueEmptied) {\n        this.__subscribe();\n        alignDirs(this, documentDir, newValue);\n      } else if (newDiffValue) {\n        this.__unsubscribe();\n      }\n    }\n\n    /** @protected */\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      this.__restoreSubscription = directionSubscribers.includes(this);\n      this.__unsubscribe();\n    }\n\n    /** @protected */\n    _valueToNodeAttribute(node, value, attribute) {\n      // Override default Polymer attribute reflection to match native behavior of HTMLElement.dir property\n      // If the property contains an empty string then it should not create an empty attribute\n      if (attribute === 'dir' && value === '' && !node.hasAttribute('dir')) {\n        return;\n      }\n      super._valueToNodeAttribute(node, value, attribute);\n    }\n\n    /** @protected */\n    _attributeToProperty(attribute, value, type) {\n      // Override default Polymer attribute reflection to match native behavior of HTMLElement.dir property\n      // If the attribute is removed, then the dir property should contain an empty string instead of null\n      if (attribute === 'dir' && !value) {\n        this.dir = '';\n      } else {\n        super._attributeToProperty(attribute, value, type);\n      }\n    }\n\n    /** @private */\n    __subscribe() {\n      if (!directionSubscribers.includes(this)) {\n        directionSubscribers.push(this);\n      }\n    }\n\n    /** @private */\n    __unsubscribe() {\n      if (directionSubscribers.includes(this)) {\n        directionSubscribers.splice(directionSubscribers.indexOf(this), 1);\n      }\n    }\n  };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}