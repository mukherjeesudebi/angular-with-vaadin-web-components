{"ast":null,"code":"/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\nimport { timeOut } from '@polymer/polymer/lib/utils/async.js';\nexport const ItemCache = class ItemCache {\n  constructor(grid, parentCache, parentItem) {\n    this.grid = grid;\n    this.parentCache = parentCache;\n    this.parentItem = parentItem;\n    this.itemCaches = {};\n    this.items = {};\n    this.effectiveSize = 0;\n    this.size = 0;\n    this.pendingRequests = {};\n  }\n  isLoading() {\n    return Object.keys(this.pendingRequests).length || Object.keys(this.itemCaches).filter(index => {\n      return this.itemCaches[index].isLoading();\n    })[0];\n  }\n  getItemForIndex(index) {\n    const {\n      cache,\n      scaledIndex\n    } = this.getCacheAndIndex(index);\n    return cache.items[scaledIndex];\n  }\n  updateSize() {\n    this.effectiveSize = !this.parentItem || this.grid._isExpanded(this.parentItem) ? this.size + Object.keys(this.itemCaches).reduce((prev, curr) => {\n      const subCache = this.itemCaches[curr];\n      subCache.updateSize();\n      return prev + subCache.effectiveSize;\n    }, 0) : 0;\n  }\n  ensureSubCacheForScaledIndex(scaledIndex) {\n    if (!this.itemCaches[scaledIndex]) {\n      const subCache = new ItemCache(this.grid, this, this.items[scaledIndex]);\n      this.itemCaches[scaledIndex] = subCache;\n      this.grid._loadPage(0, subCache);\n    }\n  }\n  getCacheAndIndex(index) {\n    let thisLevelIndex = index;\n    const keys = Object.keys(this.itemCaches);\n    for (var i = 0; i < keys.length; i++) {\n      const expandedIndex = Number(keys[i]);\n      const subCache = this.itemCaches[expandedIndex];\n      if (thisLevelIndex <= expandedIndex) {\n        return {\n          cache: this,\n          scaledIndex: thisLevelIndex\n        };\n      } else if (thisLevelIndex <= expandedIndex + subCache.effectiveSize) {\n        return subCache.getCacheAndIndex(thisLevelIndex - expandedIndex - 1);\n      }\n      thisLevelIndex -= subCache.effectiveSize;\n    }\n    return {\n      cache: this,\n      scaledIndex: thisLevelIndex\n    };\n  }\n};\n\n/**\n * @polymerMixin\n */\nexport const DataProviderMixin = superClass => class DataProviderMixin extends superClass {\n  static get properties() {\n    return {\n      /**\n       * Number of items fetched at a time from the dataprovider.\n       */\n      pageSize: {\n        type: Number,\n        value: 50,\n        observer: '_pageSizeChanged'\n      },\n      /**\n       * Function that provides items lazily. Receives arguments `params`, `callback`\n       *\n       * `params.page` Requested page index\n       *\n       * `params.pageSize` Current page size\n       *\n       * `params.filters` Currently applied filters\n       *\n       * `params.sortOrders` Currently applied sorting orders\n       *\n       * `params.parentItem` When tree is used, and sublevel items\n       * are requested, reference to parent item of the requested sublevel.\n       * Otherwise `undefined`.\n       *\n       * `callback(items, size)` Callback function with arguments:\n       *   - `items` Current page of items\n       *   - `size` Total number of items. When tree sublevel items\n       *     are requested, total number of items in the requested sublevel.\n       *     Optional when tree is not used, required for tree.\n       */\n      dataProvider: {\n        type: Object,\n        notify: true,\n        observer: '_dataProviderChanged'\n      },\n      /**\n       * `true` while data is being requested from the data provider.\n       */\n      loading: {\n        type: Boolean,\n        notify: true,\n        readOnly: true,\n        reflectToAttribute: true\n      },\n      _cache: {\n        type: Object,\n        value: function () {\n          const cache = new ItemCache(this);\n          return cache;\n        }\n      },\n      /**\n       * Path to an item sub-property that identifies the item.\n       */\n      itemIdPath: {\n        type: String,\n        value: null\n      },\n      /**\n       * An array that contains the expanded items.\n       */\n      expandedItems: {\n        type: Object,\n        notify: true,\n        value: () => []\n      }\n    };\n  }\n  static get observers() {\n    return ['_sizeChanged(size)', '_expandedItemsChanged(expandedItems.*)'];\n  }\n  _sizeChanged(size) {\n    const delta = size - this._cache.size;\n    this._cache.size += delta;\n    this._cache.effectiveSize += delta;\n    this._effectiveSize = this._cache.effectiveSize;\n  }\n  _updateRowItem(item, el) {\n    el.children.forEach(cell => {\n      cell._instance && (cell._instance.item = item);\n    });\n  }\n  _getItem(index, el) {\n    if (index >= this._effectiveSize) {\n      return;\n    }\n    el.index = index;\n    const {\n      cache,\n      scaledIndex\n    } = this._cache.getCacheAndIndex(index);\n    const item = cache.items[scaledIndex];\n    if (item) {\n      this._toggleAttribute('loading', false, el);\n      this._updateItem(el, item);\n      if (this._isExpanded(item)) {\n        cache.ensureSubCacheForScaledIndex(scaledIndex);\n      }\n    } else {\n      this._toggleAttribute('loading', true, el);\n      this._loadPage(this._getPageForIndex(scaledIndex), cache);\n    }\n  }\n  _pagesForPhysicalItems() {\n    // TODO: potentially heavy operation to run first visible index,\n    // reconsider if performance issues occur on data binding / scrolling.\n    // TODO: _vidxOffset shouldn't be read from here.\n    const firstVisiblePage = this._getPageForIndex(this._firstVisibleIndex + this._vidxOffset);\n    return [firstVisiblePage].concat(this._physicalItems.filter(row => row.index).items(row => this._getPageForIndex(row.index))).reduce((prev, curr) => {\n      if (prev.indexOf(curr) === -1) {\n        prev.push(curr);\n      }\n      return prev;\n    }, []);\n  }\n  _expandedInstanceChangedCallback(inst, value) {\n    if (inst.item === undefined) {\n      return;\n    }\n    if (value) {\n      this.expandItem(inst.item);\n    } else {\n      this.collapseItem(inst.item);\n    }\n  }\n\n  /**\n   * Returns a value that identifies the item. Uses `itemIdPath` if available.\n   * Can be customized by overriding.\n   */\n  getItemId(item) {\n    return this.itemIdPath ? this.get(this.itemIdPath, item) : item;\n  }\n  _isExpanded(item) {\n    return this.expandedItems && this._getItemIndexInArray(item, this.expandedItems) > -1;\n  }\n  _expandedItemsChanged(e) {\n    this._cache.updateSize();\n    this._effectiveSize = this._cache.effectiveSize;\n    this._assignModels();\n  }\n\n  /**\n   * Expands the given item tree.\n   */\n  expandItem(item) {\n    if (!this._isExpanded(item)) {\n      this.push('expandedItems', item);\n    }\n  }\n\n  /**\n   * Collapses the given item tree.\n   */\n  collapseItem(item) {\n    if (this._isExpanded(item)) {\n      this.splice('expandedItems', this._getItemIndexInArray(item, this.expandedItems), 1);\n    }\n  }\n  _getIndexLevel(index) {\n    let {\n      cache\n    } = this._cache.getCacheAndIndex(index);\n    let level = 0;\n    while (cache.parentCache) {\n      cache = cache.parentCache;\n      level++;\n    }\n    return level;\n  }\n  _canPopulate() {\n    return this._hasData && this._columnTree;\n  }\n  _loadPage(page, cache) {\n    // make sure same page isn't requested multiple times.\n    if (!cache.pendingRequests[page] && this.dataProvider) {\n      this._setLoading(true);\n      cache.pendingRequests[page] = true;\n      const params = {\n        page,\n        pageSize: this.pageSize,\n        sortOrders: this._mapSorters(),\n        filters: this._mapFilters(),\n        parentItem: cache.parentItem\n      };\n      this.dataProvider(params, (items, size) => {\n        if (size !== undefined) {\n          cache.size = size;\n        } else {\n          if (params.parentItem) {\n            cache.size = items.length;\n          }\n        }\n\n        // Populate the cache with new items\n        items.forEach((item, itemsIndex) => {\n          const itemIndex = page * this.pageSize + itemsIndex;\n          cache.items[itemIndex] = item;\n          if (this._isExpanded(item)) {\n            // Force synchronous data request for expanded item sub-cache\n            cache.ensureSubCacheForScaledIndex(itemIndex);\n          }\n        });\n        this._hasData = true;\n        delete cache.pendingRequests[page];\n        if (!this._cache.isLoading()) {\n          // All active requests have finished, update the effective size and rows\n          this._setLoading(false);\n          this._cache.updateSize();\n          this._effectiveSize = this._cache.effectiveSize;\n          Array.from(this.$.items.children).filter(row => !row.hidden).forEach(row => {\n            const cachedItem = this._cache.getItemForIndex(row.index);\n            if (cachedItem) {\n              this._toggleAttribute('loading', false, row);\n              this._updateItem(row, cachedItem);\n            }\n          });\n          this._increasePoolIfNeeded(0);\n        }\n        this.__setInitialColumnWidths();\n      });\n    }\n  }\n  _getPageForIndex(index) {\n    return Math.floor(index / this.pageSize);\n  }\n\n  /**\n   * Clears the cached pages and reloads data from dataprovider when needed.\n   */\n  clearCache() {\n    this._cache = new ItemCache(this);\n    Array.from(this.$.items.children).forEach(row => {\n      Array.from(row.children).forEach(cell => {\n        // Force data system to pick up subproperty changes\n        cell._instance && cell._instance._setPendingProperty('item', {}, false);\n      });\n    });\n    this._cache.size = this.size || 0;\n    this._cache.updateSize();\n    this._hasData = false;\n    this._assignModels();\n    if (!this._effectiveSize) {\n      this._loadPage(0, this._cache);\n    }\n  }\n  _flushItemsDebouncer() {\n    if (this._debouncerLoad) {\n      this._debouncerLoad.flush();\n    }\n  }\n  _pageSizeChanged(pageSize, oldPageSize) {\n    if (oldPageSize !== undefined && pageSize !== oldPageSize) {\n      this.clearCache();\n    }\n  }\n  _checkSize() {\n    if (this.size === undefined && this._effectiveSize === 0) {\n      console.warn('The <vaadin-grid> needs the total number of items' + ' in order to display rows. Set the total number of items' + ' to the `size` property, or provide the total number of items' + ' in the second argument of the `dataProvider`’s `callback` call.');\n    }\n  }\n  _dataProviderChanged(dataProvider, oldDataProvider) {\n    if (oldDataProvider !== undefined) {\n      this.clearCache();\n    }\n    if (dataProvider && this.items && this.items.length) {\n      // Fixes possibly invalid cached lastVisibleIndex value in <iron-list>\n      this._scrollToIndex(this._firstVisibleIndex);\n    }\n    this._ensureFirstPageLoaded();\n    this._debouncerCheckSize = Debouncer.debounce(this._debouncerCheckSize, timeOut.after(2000), this._checkSize.bind(this));\n    this._scrollHandler();\n  }\n  _ensureFirstPageLoaded() {\n    if (!this._hasData) {\n      // load data before adding rows to make sure they have content when\n      // rendered for the first time.\n      this._loadPage(0, this._cache, () => {\n        const hadData = this._hasData;\n        this._hasData = true;\n        if (!hadData) {\n          this.notifyResize();\n        }\n      });\n    }\n  }\n  _itemsEqual(item1, item2) {\n    return this.getItemId(item1) === this.getItemId(item2);\n  }\n  _getItemIndexInArray(item, array) {\n    let result = -1;\n    array.forEach((i, idx) => {\n      if (this._itemsEqual(i, item)) {\n        result = idx;\n      }\n    });\n    return result;\n  }\n};","map":{"version":3,"names":["Debouncer","timeOut","ItemCache","constructor","grid","parentCache","parentItem","itemCaches","items","effectiveSize","size","pendingRequests","isLoading","Object","keys","length","filter","index","getItemForIndex","cache","scaledIndex","getCacheAndIndex","updateSize","_isExpanded","reduce","prev","curr","subCache","ensureSubCacheForScaledIndex","_loadPage","thisLevelIndex","i","expandedIndex","Number","DataProviderMixin","superClass","properties","pageSize","type","value","observer","dataProvider","notify","loading","Boolean","readOnly","reflectToAttribute","_cache","itemIdPath","String","expandedItems","observers","_sizeChanged","delta","_effectiveSize","_updateRowItem","item","el","children","forEach","cell","_instance","_getItem","_toggleAttribute","_updateItem","_getPageForIndex","_pagesForPhysicalItems","firstVisiblePage","_firstVisibleIndex","_vidxOffset","concat","_physicalItems","row","indexOf","push","_expandedInstanceChangedCallback","inst","undefined","expandItem","collapseItem","getItemId","get","_getItemIndexInArray","_expandedItemsChanged","e","_assignModels","splice","_getIndexLevel","level","_canPopulate","_hasData","_columnTree","page","_setLoading","params","sortOrders","_mapSorters","filters","_mapFilters","itemsIndex","itemIndex","Array","from","$","hidden","cachedItem","_increasePoolIfNeeded","__setInitialColumnWidths","Math","floor","clearCache","_setPendingProperty","_flushItemsDebouncer","_debouncerLoad","flush","_pageSizeChanged","oldPageSize","_checkSize","console","warn","_dataProviderChanged","oldDataProvider","_scrollToIndex","_ensureFirstPageLoaded","_debouncerCheckSize","debounce","after","bind","_scrollHandler","hadData","notifyResize","_itemsEqual","item1","item2","array","result","idx"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@vaadin/vaadin-grid/src/vaadin-grid-data-provider-mixin.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\n\nimport { timeOut } from '@polymer/polymer/lib/utils/async.js';\n\nexport const ItemCache = class ItemCache {\n\n  constructor(grid, parentCache, parentItem) {\n    this.grid = grid;\n    this.parentCache = parentCache;\n    this.parentItem = parentItem;\n    this.itemCaches = {};\n    this.items = {};\n    this.effectiveSize = 0;\n    this.size = 0;\n    this.pendingRequests = {};\n  }\n\n  isLoading() {\n    return Object.keys(this.pendingRequests).length || Object.keys(this.itemCaches).filter(index => {\n      return this.itemCaches[index].isLoading();\n    })[0];\n  }\n\n  getItemForIndex(index) {\n    const {cache, scaledIndex} = this.getCacheAndIndex(index);\n    return cache.items[scaledIndex];\n  }\n\n  updateSize() {\n    this.effectiveSize = (!this.parentItem || this.grid._isExpanded(this.parentItem)) ?\n      this.size + Object.keys(this.itemCaches).reduce((prev, curr) => {\n        const subCache = this.itemCaches[curr];\n        subCache.updateSize();\n        return prev + subCache.effectiveSize;\n      }, 0) :\n      0;\n  }\n\n  ensureSubCacheForScaledIndex(scaledIndex) {\n    if (!this.itemCaches[scaledIndex]) {\n      const subCache = new ItemCache(this.grid, this, this.items[scaledIndex]);\n      this.itemCaches[scaledIndex] = subCache;\n      this.grid._loadPage(0, subCache);\n    }\n  }\n\n  getCacheAndIndex(index) {\n    let thisLevelIndex = index;\n    const keys = Object.keys(this.itemCaches);\n    for (var i = 0; i < keys.length; i++) {\n      const expandedIndex = Number(keys[i]);\n      const subCache = this.itemCaches[expandedIndex];\n      if (thisLevelIndex <= expandedIndex) {\n        return {cache: this, scaledIndex: thisLevelIndex};\n      } else if (thisLevelIndex <= expandedIndex + subCache.effectiveSize) {\n        return subCache.getCacheAndIndex(thisLevelIndex - expandedIndex - 1);\n      }\n      thisLevelIndex -= subCache.effectiveSize;\n    }\n    return {cache: this, scaledIndex: thisLevelIndex};\n  }\n\n};\n\n/**\n * @polymerMixin\n */\nexport const DataProviderMixin = superClass => class DataProviderMixin extends superClass {\n\n  static get properties() {\n    return {\n\n      /**\n       * Number of items fetched at a time from the dataprovider.\n       */\n      pageSize: {\n        type: Number,\n        value: 50,\n        observer: '_pageSizeChanged'\n      },\n\n      /**\n       * Function that provides items lazily. Receives arguments `params`, `callback`\n       *\n       * `params.page` Requested page index\n       *\n       * `params.pageSize` Current page size\n       *\n       * `params.filters` Currently applied filters\n       *\n       * `params.sortOrders` Currently applied sorting orders\n       *\n       * `params.parentItem` When tree is used, and sublevel items\n       * are requested, reference to parent item of the requested sublevel.\n       * Otherwise `undefined`.\n       *\n       * `callback(items, size)` Callback function with arguments:\n       *   - `items` Current page of items\n       *   - `size` Total number of items. When tree sublevel items\n       *     are requested, total number of items in the requested sublevel.\n       *     Optional when tree is not used, required for tree.\n       */\n      dataProvider: {\n        type: Object,\n        notify: true,\n        observer: '_dataProviderChanged'\n      },\n\n      /**\n       * `true` while data is being requested from the data provider.\n       */\n      loading: {\n        type: Boolean,\n        notify: true,\n        readOnly: true,\n        reflectToAttribute: true\n      },\n\n      _cache: {\n        type: Object,\n        value: function() {\n          const cache = new ItemCache(this);\n          return cache;\n        }\n      },\n\n      /**\n       * Path to an item sub-property that identifies the item.\n       */\n      itemIdPath: {\n        type: String,\n        value: null\n      },\n\n      /**\n       * An array that contains the expanded items.\n       */\n      expandedItems: {\n        type: Object,\n        notify: true,\n        value: () => []\n      }\n\n    };\n  }\n\n  static get observers() {\n    return [\n      '_sizeChanged(size)',\n      '_expandedItemsChanged(expandedItems.*)'\n    ];\n  }\n\n  _sizeChanged(size) {\n    const delta = size - this._cache.size;\n    this._cache.size += delta;\n    this._cache.effectiveSize += delta;\n    this._effectiveSize = this._cache.effectiveSize;\n  }\n\n  _updateRowItem(item, el) {\n    el.children.forEach(cell => {\n      cell._instance && (cell._instance.item = item);\n    });\n  }\n\n  _getItem(index, el) {\n    if (index >= this._effectiveSize) {\n      return;\n    }\n\n    el.index = index;\n    const {cache, scaledIndex} = this._cache.getCacheAndIndex(index);\n    const item = cache.items[scaledIndex];\n    if (item) {\n      this._toggleAttribute('loading', false, el);\n      this._updateItem(el, item);\n      if (this._isExpanded(item)) {\n        cache.ensureSubCacheForScaledIndex(scaledIndex);\n      }\n    } else {\n      this._toggleAttribute('loading', true, el);\n      this._loadPage(this._getPageForIndex(scaledIndex), cache);\n    }\n\n  }\n\n  _pagesForPhysicalItems() {\n    // TODO: potentially heavy operation to run first visible index,\n    // reconsider if performance issues occur on data binding / scrolling.\n    // TODO: _vidxOffset shouldn't be read from here.\n    const firstVisiblePage = this._getPageForIndex(this._firstVisibleIndex + this._vidxOffset);\n\n    return [firstVisiblePage].concat(\n      this._physicalItems\n        .filter(row => row.index)\n        .items(row => this._getPageForIndex(row.index))\n    ).reduce((prev, curr) => {\n      if (prev.indexOf(curr) === -1) {\n        prev.push(curr);\n      }\n\n      return prev;\n    }, []);\n  }\n\n  _expandedInstanceChangedCallback(inst, value) {\n    if (inst.item === undefined) {\n      return;\n    }\n    if (value) {\n      this.expandItem(inst.item);\n    } else {\n      this.collapseItem(inst.item);\n    }\n  }\n\n  /**\n   * Returns a value that identifies the item. Uses `itemIdPath` if available.\n   * Can be customized by overriding.\n   */\n  getItemId(item) {\n    return this.itemIdPath ? this.get(this.itemIdPath, item) : item;\n  }\n\n  _isExpanded(item) {\n    return this.expandedItems && this._getItemIndexInArray(item, this.expandedItems) > -1;\n  }\n\n  _expandedItemsChanged(e) {\n    this._cache.updateSize();\n    this._effectiveSize = this._cache.effectiveSize;\n    this._assignModels();\n  }\n\n  /**\n   * Expands the given item tree.\n   */\n  expandItem(item) {\n    if (!this._isExpanded(item)) {\n      this.push('expandedItems', item);\n    }\n  }\n\n  /**\n   * Collapses the given item tree.\n   */\n  collapseItem(item) {\n    if (this._isExpanded(item)) {\n      this.splice('expandedItems', this._getItemIndexInArray(item, this.expandedItems), 1);\n    }\n  }\n\n  _getIndexLevel(index) {\n    let {cache} = this._cache.getCacheAndIndex(index);\n    let level = 0;\n    while (cache.parentCache) {\n      cache = cache.parentCache;\n      level++;\n    }\n    return level;\n  }\n\n  _canPopulate() {\n    return this._hasData && this._columnTree;\n  }\n\n  _loadPage(page, cache) {\n    // make sure same page isn't requested multiple times.\n    if (!cache.pendingRequests[page] && this.dataProvider) {\n      this._setLoading(true);\n      cache.pendingRequests[page] = true;\n      const params = {\n        page,\n        pageSize: this.pageSize,\n        sortOrders: this._mapSorters(),\n        filters: this._mapFilters(),\n        parentItem: cache.parentItem\n      };\n\n      this.dataProvider(params, (items, size) => {\n        if (size !== undefined) {\n          cache.size = size;\n        } else {\n          if (params.parentItem) {\n            cache.size = items.length;\n          }\n        }\n\n        // Populate the cache with new items\n        items.forEach((item, itemsIndex) => {\n          const itemIndex = page * this.pageSize + itemsIndex;\n          cache.items[itemIndex] = item;\n          if (this._isExpanded(item)) {\n            // Force synchronous data request for expanded item sub-cache\n            cache.ensureSubCacheForScaledIndex(itemIndex);\n          }\n        });\n\n        this._hasData = true;\n\n        delete cache.pendingRequests[page];\n\n        if (!this._cache.isLoading()) {\n          // All active requests have finished, update the effective size and rows\n          this._setLoading(false);\n          this._cache.updateSize();\n          this._effectiveSize = this._cache.effectiveSize;\n\n          Array.from(this.$.items.children)\n            .filter(row => !row.hidden)\n            .forEach(row => {\n              const cachedItem = this._cache.getItemForIndex(row.index);\n              if (cachedItem) {\n                this._toggleAttribute('loading', false, row);\n                this._updateItem(row, cachedItem);\n              }\n            });\n\n          this._increasePoolIfNeeded(0);\n        }\n\n        this.__setInitialColumnWidths();\n      });\n    }\n  }\n\n  _getPageForIndex(index) {\n    return Math.floor(index / this.pageSize);\n  }\n\n  /**\n   * Clears the cached pages and reloads data from dataprovider when needed.\n   */\n  clearCache() {\n    this._cache = new ItemCache(this);\n    Array.from(this.$.items.children).forEach(row => {\n      Array.from(row.children).forEach(cell => {\n        // Force data system to pick up subproperty changes\n        cell._instance && cell._instance._setPendingProperty('item', {}, false);\n      });\n    });\n    this._cache.size = this.size || 0;\n    this._cache.updateSize();\n    this._hasData = false;\n    this._assignModels();\n\n    if (!this._effectiveSize) {\n      this._loadPage(0, this._cache);\n    }\n  }\n\n  _flushItemsDebouncer() {\n    if (this._debouncerLoad) {\n      this._debouncerLoad.flush();\n    }\n  }\n\n  _pageSizeChanged(pageSize, oldPageSize) {\n    if (oldPageSize !== undefined && pageSize !== oldPageSize) {\n      this.clearCache();\n    }\n  }\n\n  _checkSize() {\n    if (this.size === undefined && this._effectiveSize === 0) {\n      console.warn(\n        'The <vaadin-grid> needs the total number of items' +\n        ' in order to display rows. Set the total number of items' +\n        ' to the `size` property, or provide the total number of items' +\n        ' in the second argument of the `dataProvider`’s `callback` call.'\n      );\n    }\n  }\n\n  _dataProviderChanged(dataProvider, oldDataProvider) {\n    if (oldDataProvider !== undefined) {\n      this.clearCache();\n    }\n\n    if (dataProvider && this.items && this.items.length) {\n      // Fixes possibly invalid cached lastVisibleIndex value in <iron-list>\n      this._scrollToIndex(this._firstVisibleIndex);\n    }\n\n    this._ensureFirstPageLoaded();\n\n    this._debouncerCheckSize = Debouncer.debounce(\n      this._debouncerCheckSize,\n      timeOut.after(2000),\n      this._checkSize.bind(this));\n\n    this._scrollHandler();\n  }\n\n  _ensureFirstPageLoaded() {\n    if (!this._hasData) {\n      // load data before adding rows to make sure they have content when\n      // rendered for the first time.\n      this._loadPage(0, this._cache, () => {\n        const hadData = this._hasData;\n        this._hasData = true;\n        if (!hadData) {\n          this.notifyResize();\n        }\n      });\n    }\n  }\n\n  _itemsEqual(item1, item2) {\n    return this.getItemId(item1) === this.getItemId(item2);\n  }\n\n  _getItemIndexInArray(item, array) {\n    let result = -1;\n    array.forEach((i, idx) => {\n      if (this._itemsEqual(i, item)) {\n        result = idx;\n      }\n    });\n    return result;\n  }\n\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}