{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2021 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n// We consider the keyboard to be active if the window has received a keydown\n// event since the last mousedown event.\nlet keyboardActive = false;\n\n// Listen for top-level keydown and mousedown events.\n// Use capture phase so we detect events even if they're handled.\nwindow.addEventListener('keydown', () => {\n  keyboardActive = true;\n}, {\n  capture: true\n});\nwindow.addEventListener('mousedown', () => {\n  keyboardActive = false;\n}, {\n  capture: true\n});\n\n/**\n * Returns the actually focused element by traversing shadow\n * trees recursively to ensure it's the leaf element.\n *\n * @return {Element}\n */\nexport function getDeepActiveElement() {\n  let host = document.activeElement || document.body;\n  while (host.shadowRoot && host.shadowRoot.activeElement) {\n    host = host.shadowRoot.activeElement;\n  }\n  return host;\n}\n\n/**\n * Returns true if the window has received a keydown\n * event since the last mousedown event.\n *\n * @return {boolean}\n */\nexport function isKeyboardActive() {\n  return keyboardActive;\n}\n\n/**\n * Returns true if the element is hidden directly with `display: none` or `visibility: hidden`,\n * false otherwise.\n *\n * The method doesn't traverse the element's ancestors, it only checks for the CSS properties\n * set directly to or inherited by the element.\n *\n * @param {HTMLElement} element\n * @return {boolean}\n */\nfunction isElementHiddenDirectly(element) {\n  // Check inline style first to save a re-flow.\n  const style = element.style;\n  if (style.visibility === 'hidden' || style.display === 'none') {\n    return true;\n  }\n  const computedStyle = window.getComputedStyle(element);\n  if (computedStyle.visibility === 'hidden' || computedStyle.display === 'none') {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns if element `a` has lower tab order compared to element `b`\n * (both elements are assumed to be focusable and tabbable).\n * Elements with tabindex = 0 have lower tab order compared to elements\n * with tabindex > 0.\n * If both have same tabindex, it returns false.\n *\n * @param {HTMLElement} a\n * @param {HTMLElement} b\n * @return {boolean}\n */\nfunction hasLowerTabOrder(a, b) {\n  // Normalize tabIndexes\n  // e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`\n  const ati = Math.max(a.tabIndex, 0);\n  const bti = Math.max(b.tabIndex, 0);\n  return ati === 0 || bti === 0 ? bti > ati : ati > bti;\n}\n\n/**\n * Merge sort iterator, merges the two arrays into one, sorted by tabindex.\n *\n * @param {HTMLElement[]} left\n * @param {HTMLElement[]} right\n * @return {HTMLElement[]}\n */\nfunction mergeSortByTabIndex(left, right) {\n  const result = [];\n  while (left.length > 0 && right.length > 0) {\n    if (hasLowerTabOrder(left[0], right[0])) {\n      result.push(right.shift());\n    } else {\n      result.push(left.shift());\n    }\n  }\n  return result.concat(left, right);\n}\n\n/**\n * Sorts an array of elements by tabindex. Returns a new array.\n *\n * @param {HTMLElement[]} elements\n * @return {HTMLElement[]}\n */\nfunction sortElementsByTabIndex(elements) {\n  // Implement a merge sort as Array.prototype.sort does a non-stable sort\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n  const len = elements.length;\n  if (len < 2) {\n    return elements;\n  }\n  const pivot = Math.ceil(len / 2);\n  const left = sortElementsByTabIndex(elements.slice(0, pivot));\n  const right = sortElementsByTabIndex(elements.slice(pivot));\n  return mergeSortByTabIndex(left, right);\n}\n\n/**\n * Returns true if the element is hidden, false otherwise.\n *\n * An element is treated as hidden when any of the following conditions are met:\n * - the element itself or one of its ancestors has `display: none`.\n * - the element has or inherits `visibility: hidden`.\n *\n * @param {HTMLElement} element\n * @return {boolean}\n */\nexport function isElementHidden(element) {\n  // `offsetParent` is `null` when the element itself\n  // or one of its ancestors is hidden with `display: none`.\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent\n  // However `offsetParent` is also null when the element is using fixed\n  // positioning, so additionally check if the element takes up layout space.\n  if (element.offsetParent === null && element.clientWidth === 0 && element.clientHeight === 0) {\n    return true;\n  }\n  return isElementHiddenDirectly(element);\n}\n\n/**\n * Returns true if the element is focusable, otherwise false.\n *\n * The list of focusable elements is taken from http://stackoverflow.com/a/1600194/4228703.\n * However, there isn't a definite list, it's up to the browser.\n * The only standard we have is DOM Level 2 HTML https://www.w3.org/TR/DOM-Level-2-HTML/html.html,\n * according to which the only elements that have a `focus()` method are:\n * - HTMLInputElement\n * - HTMLSelectElement\n * - HTMLTextAreaElement\n * - HTMLAnchorElement\n *\n * This notably omits HTMLButtonElement and HTMLAreaElement.\n * Referring to these tests with tabbables in different browsers\n * http://allyjs.io/data-tables/focusable.html\n *\n * @param {HTMLElement} element\n * @return {boolean}\n */\nexport function isElementFocusable(element) {\n  // The element cannot be focused if its `tabindex` attribute is set to `-1`.\n  if (element.matches('[tabindex=\"-1\"]')) {\n    return false;\n  }\n\n  // Elements that cannot be focused if they have a `disabled` attribute.\n  if (element.matches('input, select, textarea, button, object')) {\n    return element.matches(':not([disabled])');\n  }\n\n  // Elements that can be focused even if they have a `disabled` attribute.\n  return element.matches('a[href], area[href], iframe, [tabindex], [contentEditable]');\n}\n\n/**\n * Returns true if the element is focused, false otherwise.\n *\n * @param {HTMLElement} element\n * @return {boolean}\n */\nexport function isElementFocused(element) {\n  return element.getRootNode().activeElement === element;\n}\n\n/**\n * Returns the normalized element tabindex. If not focusable, returns -1.\n * It checks for the attribute \"tabindex\" instead of the element property\n * `tabIndex` since browsers assign different values to it.\n * e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`\n *\n * @param {HTMLElement} element\n * @return {number}\n */\nfunction normalizeTabIndex(element) {\n  if (!isElementFocusable(element)) {\n    return -1;\n  }\n  const tabIndex = element.getAttribute('tabindex') || 0;\n  return Number(tabIndex);\n}\n\n/**\n * Searches for nodes that are tabbable and adds them to the `result` array.\n * Returns if the `result` array needs to be sorted by tabindex.\n *\n * @param {Node} node The starting point for the search; added to `result` if tabbable.\n * @param {HTMLElement[]} result\n * @return {boolean}\n * @private\n */\nfunction collectFocusableNodes(node, result) {\n  if (node.nodeType !== Node.ELEMENT_NODE || isElementHiddenDirectly(node)) {\n    // Don't traverse children if the node is not an HTML element or not visible.\n    return false;\n  }\n  const element = /** @type {HTMLElement} */node;\n  const tabIndex = normalizeTabIndex(element);\n  let needsSort = tabIndex > 0;\n  if (tabIndex >= 0) {\n    result.push(element);\n  }\n  let children = [];\n  if (element.localName === 'slot') {\n    children = element.assignedNodes({\n      flatten: true\n    });\n  } else {\n    // Use shadow root if possible, will check for distributed nodes.\n    children = (element.shadowRoot || element).children;\n  }\n  [...children].forEach(child => {\n    // Ensure method is always invoked to collect focusable children.\n    needsSort = collectFocusableNodes(child, result) || needsSort;\n  });\n  return needsSort;\n}\n\n/**\n * Returns a tab-ordered array of focusable elements for a root element.\n * The resulting array will include the root element if it is focusable.\n *\n * The method traverses nodes in shadow DOM trees too if any.\n *\n * @param {HTMLElement} element\n * @return {HTMLElement[]}\n */\nexport function getFocusableElements(element) {\n  const focusableElements = [];\n  const needsSortByTabIndex = collectFocusableNodes(element, focusableElements);\n  // If there is at least one element with tabindex > 0,\n  // we need to sort the final array by tabindex.\n  if (needsSortByTabIndex) {\n    return sortElementsByTabIndex(focusableElements);\n  }\n  return focusableElements;\n}","map":{"version":3,"names":["keyboardActive","window","addEventListener","capture","getDeepActiveElement","host","document","activeElement","body","shadowRoot","isKeyboardActive","isElementHiddenDirectly","element","style","visibility","display","computedStyle","getComputedStyle","hasLowerTabOrder","a","b","ati","Math","max","tabIndex","bti","mergeSortByTabIndex","left","right","result","length","push","shift","concat","sortElementsByTabIndex","elements","len","pivot","ceil","slice","isElementHidden","offsetParent","clientWidth","clientHeight","isElementFocusable","matches","isElementFocused","getRootNode","normalizeTabIndex","getAttribute","Number","collectFocusableNodes","node","nodeType","Node","ELEMENT_NODE","needsSort","children","localName","assignedNodes","flatten","forEach","child","getFocusableElements","focusableElements","needsSortByTabIndex"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@vaadin/a11y-base/src/focus-utils.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2021 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n// We consider the keyboard to be active if the window has received a keydown\n// event since the last mousedown event.\nlet keyboardActive = false;\n\n// Listen for top-level keydown and mousedown events.\n// Use capture phase so we detect events even if they're handled.\nwindow.addEventListener(\n  'keydown',\n  () => {\n    keyboardActive = true;\n  },\n  { capture: true },\n);\n\nwindow.addEventListener(\n  'mousedown',\n  () => {\n    keyboardActive = false;\n  },\n  { capture: true },\n);\n\n/**\n * Returns the actually focused element by traversing shadow\n * trees recursively to ensure it's the leaf element.\n *\n * @return {Element}\n */\nexport function getDeepActiveElement() {\n  let host = document.activeElement || document.body;\n  while (host.shadowRoot && host.shadowRoot.activeElement) {\n    host = host.shadowRoot.activeElement;\n  }\n  return host;\n}\n\n/**\n * Returns true if the window has received a keydown\n * event since the last mousedown event.\n *\n * @return {boolean}\n */\nexport function isKeyboardActive() {\n  return keyboardActive;\n}\n\n/**\n * Returns true if the element is hidden directly with `display: none` or `visibility: hidden`,\n * false otherwise.\n *\n * The method doesn't traverse the element's ancestors, it only checks for the CSS properties\n * set directly to or inherited by the element.\n *\n * @param {HTMLElement} element\n * @return {boolean}\n */\nfunction isElementHiddenDirectly(element) {\n  // Check inline style first to save a re-flow.\n  const style = element.style;\n  if (style.visibility === 'hidden' || style.display === 'none') {\n    return true;\n  }\n\n  const computedStyle = window.getComputedStyle(element);\n  if (computedStyle.visibility === 'hidden' || computedStyle.display === 'none') {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Returns if element `a` has lower tab order compared to element `b`\n * (both elements are assumed to be focusable and tabbable).\n * Elements with tabindex = 0 have lower tab order compared to elements\n * with tabindex > 0.\n * If both have same tabindex, it returns false.\n *\n * @param {HTMLElement} a\n * @param {HTMLElement} b\n * @return {boolean}\n */\nfunction hasLowerTabOrder(a, b) {\n  // Normalize tabIndexes\n  // e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`\n  const ati = Math.max(a.tabIndex, 0);\n  const bti = Math.max(b.tabIndex, 0);\n  return ati === 0 || bti === 0 ? bti > ati : ati > bti;\n}\n\n/**\n * Merge sort iterator, merges the two arrays into one, sorted by tabindex.\n *\n * @param {HTMLElement[]} left\n * @param {HTMLElement[]} right\n * @return {HTMLElement[]}\n */\nfunction mergeSortByTabIndex(left, right) {\n  const result = [];\n  while (left.length > 0 && right.length > 0) {\n    if (hasLowerTabOrder(left[0], right[0])) {\n      result.push(right.shift());\n    } else {\n      result.push(left.shift());\n    }\n  }\n\n  return result.concat(left, right);\n}\n\n/**\n * Sorts an array of elements by tabindex. Returns a new array.\n *\n * @param {HTMLElement[]} elements\n * @return {HTMLElement[]}\n */\nfunction sortElementsByTabIndex(elements) {\n  // Implement a merge sort as Array.prototype.sort does a non-stable sort\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n  const len = elements.length;\n  if (len < 2) {\n    return elements;\n  }\n  const pivot = Math.ceil(len / 2);\n  const left = sortElementsByTabIndex(elements.slice(0, pivot));\n  const right = sortElementsByTabIndex(elements.slice(pivot));\n\n  return mergeSortByTabIndex(left, right);\n}\n\n/**\n * Returns true if the element is hidden, false otherwise.\n *\n * An element is treated as hidden when any of the following conditions are met:\n * - the element itself or one of its ancestors has `display: none`.\n * - the element has or inherits `visibility: hidden`.\n *\n * @param {HTMLElement} element\n * @return {boolean}\n */\nexport function isElementHidden(element) {\n  // `offsetParent` is `null` when the element itself\n  // or one of its ancestors is hidden with `display: none`.\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent\n  // However `offsetParent` is also null when the element is using fixed\n  // positioning, so additionally check if the element takes up layout space.\n  if (element.offsetParent === null && element.clientWidth === 0 && element.clientHeight === 0) {\n    return true;\n  }\n\n  return isElementHiddenDirectly(element);\n}\n\n/**\n * Returns true if the element is focusable, otherwise false.\n *\n * The list of focusable elements is taken from http://stackoverflow.com/a/1600194/4228703.\n * However, there isn't a definite list, it's up to the browser.\n * The only standard we have is DOM Level 2 HTML https://www.w3.org/TR/DOM-Level-2-HTML/html.html,\n * according to which the only elements that have a `focus()` method are:\n * - HTMLInputElement\n * - HTMLSelectElement\n * - HTMLTextAreaElement\n * - HTMLAnchorElement\n *\n * This notably omits HTMLButtonElement and HTMLAreaElement.\n * Referring to these tests with tabbables in different browsers\n * http://allyjs.io/data-tables/focusable.html\n *\n * @param {HTMLElement} element\n * @return {boolean}\n */\nexport function isElementFocusable(element) {\n  // The element cannot be focused if its `tabindex` attribute is set to `-1`.\n  if (element.matches('[tabindex=\"-1\"]')) {\n    return false;\n  }\n\n  // Elements that cannot be focused if they have a `disabled` attribute.\n  if (element.matches('input, select, textarea, button, object')) {\n    return element.matches(':not([disabled])');\n  }\n\n  // Elements that can be focused even if they have a `disabled` attribute.\n  return element.matches('a[href], area[href], iframe, [tabindex], [contentEditable]');\n}\n\n/**\n * Returns true if the element is focused, false otherwise.\n *\n * @param {HTMLElement} element\n * @return {boolean}\n */\nexport function isElementFocused(element) {\n  return element.getRootNode().activeElement === element;\n}\n\n/**\n * Returns the normalized element tabindex. If not focusable, returns -1.\n * It checks for the attribute \"tabindex\" instead of the element property\n * `tabIndex` since browsers assign different values to it.\n * e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`\n *\n * @param {HTMLElement} element\n * @return {number}\n */\nfunction normalizeTabIndex(element) {\n  if (!isElementFocusable(element)) {\n    return -1;\n  }\n\n  const tabIndex = element.getAttribute('tabindex') || 0;\n  return Number(tabIndex);\n}\n\n/**\n * Searches for nodes that are tabbable and adds them to the `result` array.\n * Returns if the `result` array needs to be sorted by tabindex.\n *\n * @param {Node} node The starting point for the search; added to `result` if tabbable.\n * @param {HTMLElement[]} result\n * @return {boolean}\n * @private\n */\nfunction collectFocusableNodes(node, result) {\n  if (node.nodeType !== Node.ELEMENT_NODE || isElementHiddenDirectly(node)) {\n    // Don't traverse children if the node is not an HTML element or not visible.\n    return false;\n  }\n\n  const element = /** @type {HTMLElement} */ (node);\n  const tabIndex = normalizeTabIndex(element);\n  let needsSort = tabIndex > 0;\n  if (tabIndex >= 0) {\n    result.push(element);\n  }\n\n  let children = [];\n  if (element.localName === 'slot') {\n    children = element.assignedNodes({ flatten: true });\n  } else {\n    // Use shadow root if possible, will check for distributed nodes.\n    children = (element.shadowRoot || element).children;\n  }\n  [...children].forEach((child) => {\n    // Ensure method is always invoked to collect focusable children.\n    needsSort = collectFocusableNodes(child, result) || needsSort;\n  });\n  return needsSort;\n}\n\n/**\n * Returns a tab-ordered array of focusable elements for a root element.\n * The resulting array will include the root element if it is focusable.\n *\n * The method traverses nodes in shadow DOM trees too if any.\n *\n * @param {HTMLElement} element\n * @return {HTMLElement[]}\n */\nexport function getFocusableElements(element) {\n  const focusableElements = [];\n  const needsSortByTabIndex = collectFocusableNodes(element, focusableElements);\n  // If there is at least one element with tabindex > 0,\n  // we need to sort the final array by tabindex.\n  if (needsSortByTabIndex) {\n    return sortElementsByTabIndex(focusableElements);\n  }\n  return focusableElements;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}