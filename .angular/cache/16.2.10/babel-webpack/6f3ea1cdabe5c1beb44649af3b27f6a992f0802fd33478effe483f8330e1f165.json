{"ast":null,"code":"/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nconst debouncerQueue = new Set();\n\n/**\n * @summary Collapse multiple callbacks into one invocation after a timer.\n */\nexport class Debouncer {\n  /**\n   * Creates a debouncer if no debouncer is passed as a parameter\n   * or it cancels an active debouncer otherwise. The following\n   * example shows how a debouncer can be called multiple times within a\n   * microtask and \"debounced\" such that the provided callback function is\n   * called once. Add this method to a custom element:\n   *\n   * ```js\n   * import {microTask} from '@vaadin/component-base/src/async.js';\n   * import {Debouncer} from '@vaadin/component-base/src/debounce.js';\n   * // ...\n   *\n   * _debounceWork() {\n   *   this._debounceJob = Debouncer.debounce(this._debounceJob,\n   *       microTask, () => this._doWork());\n   * }\n   * ```\n   *\n   * If the `_debounceWork` method is called multiple times within the same\n   * microtask, the `_doWork` function will be called only once at the next\n   * microtask checkpoint.\n   *\n   * Note: In testing it is often convenient to avoid asynchrony. To accomplish\n   * this with a debouncer, you can use `enqueueDebouncer` and\n   * `flush`. For example, extend the above example by adding\n   * `enqueueDebouncer(this._debounceJob)` at the end of the\n   * `_debounceWork` method. Then in a test, call `flush` to ensure\n   * the debouncer has completed.\n   *\n   * @param {Debouncer?} debouncer Debouncer object.\n   * @param {!AsyncInterface} asyncModule Object with Async interface\n   * @param {function()} callback Callback to run.\n   * @return {!Debouncer} Returns a debouncer object.\n   */\n  static debounce(debouncer, asyncModule, callback) {\n    if (debouncer instanceof Debouncer) {\n      // Cancel the async callback, but leave in debouncerQueue if it was\n      // enqueued, to maintain 1.x flush order\n      debouncer._cancelAsync();\n    } else {\n      debouncer = new Debouncer();\n    }\n    debouncer.setConfig(asyncModule, callback);\n    return debouncer;\n  }\n  constructor() {\n    this._asyncModule = null;\n    this._callback = null;\n    this._timer = null;\n  }\n\n  /**\n   * Sets the scheduler; that is, a module with the Async interface,\n   * a callback and optional arguments to be passed to the run function\n   * from the async module.\n   *\n   * @param {!AsyncInterface} asyncModule Object with Async interface.\n   * @param {function()} callback Callback to run.\n   * @return {void}\n   */\n  setConfig(asyncModule, callback) {\n    this._asyncModule = asyncModule;\n    this._callback = callback;\n    this._timer = this._asyncModule.run(() => {\n      this._timer = null;\n      debouncerQueue.delete(this);\n      this._callback();\n    });\n  }\n\n  /**\n   * Cancels an active debouncer and returns a reference to itself.\n   *\n   * @return {void}\n   */\n  cancel() {\n    if (this.isActive()) {\n      this._cancelAsync();\n      // Canceling a debouncer removes its spot from the flush queue,\n      // so if a debouncer is manually canceled and re-debounced, it\n      // will reset its flush order (this is a very minor difference from 1.x)\n      // Re-debouncing via the `debounce` API retains the 1.x FIFO flush order\n      debouncerQueue.delete(this);\n    }\n  }\n\n  /**\n   * Cancels a debouncer's async callback.\n   *\n   * @return {void}\n   */\n  _cancelAsync() {\n    if (this.isActive()) {\n      this._asyncModule.cancel( /** @type {number} */this._timer);\n      this._timer = null;\n    }\n  }\n\n  /**\n   * Flushes an active debouncer and returns a reference to itself.\n   *\n   * @return {void}\n   */\n  flush() {\n    if (this.isActive()) {\n      this.cancel();\n      this._callback();\n    }\n  }\n\n  /**\n   * Returns true if the debouncer is active.\n   *\n   * @return {boolean} True if active.\n   */\n  isActive() {\n    return this._timer != null;\n  }\n}\n\n/**\n * Adds a `Debouncer` to a list of globally flushable tasks.\n *\n * @param {!Debouncer} debouncer Debouncer to enqueue\n * @return {void}\n */\nexport function enqueueDebouncer(debouncer) {\n  debouncerQueue.add(debouncer);\n}\n\n/**\n * Flushes any enqueued debouncers\n *\n * @return {boolean} Returns whether any debouncers were flushed\n */\nexport function flushDebouncers() {\n  const didFlush = Boolean(debouncerQueue.size);\n  // If new debouncers are added while flushing, Set.forEach will ensure\n  // newly added ones are also flushed\n  debouncerQueue.forEach(debouncer => {\n    try {\n      debouncer.flush();\n    } catch (e) {\n      setTimeout(() => {\n        throw e;\n      });\n    }\n  });\n  return didFlush;\n}\nexport const flush = () => {\n  let debouncers;\n  do {\n    debouncers = flushDebouncers();\n  } while (debouncers);\n};","map":{"version":3,"names":["debouncerQueue","Set","Debouncer","debounce","debouncer","asyncModule","callback","_cancelAsync","setConfig","constructor","_asyncModule","_callback","_timer","run","delete","cancel","isActive","flush","enqueueDebouncer","add","flushDebouncers","didFlush","Boolean","size","forEach","e","setTimeout","debouncers"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@vaadin/component-base/src/debounce.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nconst debouncerQueue = new Set();\n\n/**\n * @summary Collapse multiple callbacks into one invocation after a timer.\n */\nexport class Debouncer {\n  /**\n   * Creates a debouncer if no debouncer is passed as a parameter\n   * or it cancels an active debouncer otherwise. The following\n   * example shows how a debouncer can be called multiple times within a\n   * microtask and \"debounced\" such that the provided callback function is\n   * called once. Add this method to a custom element:\n   *\n   * ```js\n   * import {microTask} from '@vaadin/component-base/src/async.js';\n   * import {Debouncer} from '@vaadin/component-base/src/debounce.js';\n   * // ...\n   *\n   * _debounceWork() {\n   *   this._debounceJob = Debouncer.debounce(this._debounceJob,\n   *       microTask, () => this._doWork());\n   * }\n   * ```\n   *\n   * If the `_debounceWork` method is called multiple times within the same\n   * microtask, the `_doWork` function will be called only once at the next\n   * microtask checkpoint.\n   *\n   * Note: In testing it is often convenient to avoid asynchrony. To accomplish\n   * this with a debouncer, you can use `enqueueDebouncer` and\n   * `flush`. For example, extend the above example by adding\n   * `enqueueDebouncer(this._debounceJob)` at the end of the\n   * `_debounceWork` method. Then in a test, call `flush` to ensure\n   * the debouncer has completed.\n   *\n   * @param {Debouncer?} debouncer Debouncer object.\n   * @param {!AsyncInterface} asyncModule Object with Async interface\n   * @param {function()} callback Callback to run.\n   * @return {!Debouncer} Returns a debouncer object.\n   */\n  static debounce(debouncer, asyncModule, callback) {\n    if (debouncer instanceof Debouncer) {\n      // Cancel the async callback, but leave in debouncerQueue if it was\n      // enqueued, to maintain 1.x flush order\n      debouncer._cancelAsync();\n    } else {\n      debouncer = new Debouncer();\n    }\n    debouncer.setConfig(asyncModule, callback);\n    return debouncer;\n  }\n\n  constructor() {\n    this._asyncModule = null;\n    this._callback = null;\n    this._timer = null;\n  }\n\n  /**\n   * Sets the scheduler; that is, a module with the Async interface,\n   * a callback and optional arguments to be passed to the run function\n   * from the async module.\n   *\n   * @param {!AsyncInterface} asyncModule Object with Async interface.\n   * @param {function()} callback Callback to run.\n   * @return {void}\n   */\n  setConfig(asyncModule, callback) {\n    this._asyncModule = asyncModule;\n    this._callback = callback;\n    this._timer = this._asyncModule.run(() => {\n      this._timer = null;\n      debouncerQueue.delete(this);\n      this._callback();\n    });\n  }\n\n  /**\n   * Cancels an active debouncer and returns a reference to itself.\n   *\n   * @return {void}\n   */\n  cancel() {\n    if (this.isActive()) {\n      this._cancelAsync();\n      // Canceling a debouncer removes its spot from the flush queue,\n      // so if a debouncer is manually canceled and re-debounced, it\n      // will reset its flush order (this is a very minor difference from 1.x)\n      // Re-debouncing via the `debounce` API retains the 1.x FIFO flush order\n      debouncerQueue.delete(this);\n    }\n  }\n\n  /**\n   * Cancels a debouncer's async callback.\n   *\n   * @return {void}\n   */\n  _cancelAsync() {\n    if (this.isActive()) {\n      this._asyncModule.cancel(/** @type {number} */ (this._timer));\n      this._timer = null;\n    }\n  }\n\n  /**\n   * Flushes an active debouncer and returns a reference to itself.\n   *\n   * @return {void}\n   */\n  flush() {\n    if (this.isActive()) {\n      this.cancel();\n      this._callback();\n    }\n  }\n\n  /**\n   * Returns true if the debouncer is active.\n   *\n   * @return {boolean} True if active.\n   */\n  isActive() {\n    return this._timer != null;\n  }\n}\n\n/**\n * Adds a `Debouncer` to a list of globally flushable tasks.\n *\n * @param {!Debouncer} debouncer Debouncer to enqueue\n * @return {void}\n */\nexport function enqueueDebouncer(debouncer) {\n  debouncerQueue.add(debouncer);\n}\n\n/**\n * Flushes any enqueued debouncers\n *\n * @return {boolean} Returns whether any debouncers were flushed\n */\nexport function flushDebouncers() {\n  const didFlush = Boolean(debouncerQueue.size);\n  // If new debouncers are added while flushing, Set.forEach will ensure\n  // newly added ones are also flushed\n  debouncerQueue.forEach((debouncer) => {\n    try {\n      debouncer.flush();\n    } catch (e) {\n      setTimeout(() => {\n        throw e;\n      });\n    }\n  });\n  return didFlush;\n}\n\nexport const flush = () => {\n  let debouncers;\n  do {\n    debouncers = flushDebouncers();\n  } while (debouncers);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}