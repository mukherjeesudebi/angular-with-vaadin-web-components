{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2022 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { SlotController } from './slot-controller.js';\n\n/**\n * A controller that observes slotted element mutations, especially ID attribute\n * and the text content, and fires an event to notify host element about those.\n */\nexport class SlotChildObserveController extends SlotController {\n  constructor(host, slot, tagName, config = {}) {\n    super(host, slot, tagName, {\n      ...config,\n      useUniqueId: true\n    });\n  }\n\n  /**\n   * Override to initialize the newly added custom node.\n   *\n   * @param {Node} node\n   * @protected\n   * @override\n   */\n  initCustomNode(node) {\n    this.__updateNodeId(node);\n    this.__notifyChange(node);\n  }\n\n  /**\n   * Override to notify the controller host about removal of\n   * the custom node, and to apply the default one if needed.\n   *\n   * @param {Node} _node\n   * @protected\n   * @override\n   */\n  teardownNode(_node) {\n    const node = this.getSlotChild();\n\n    // Custom node is added to the slot\n    if (node && node !== this.defaultNode) {\n      this.__notifyChange(node);\n    } else {\n      this.restoreDefaultNode();\n      this.updateDefaultNode(this.node);\n    }\n  }\n\n  /**\n   * Override method inherited from `SlotMixin`\n   * to set ID attribute on the default node.\n   *\n   * @return {Node}\n   * @protected\n   * @override\n   */\n  attachDefaultNode() {\n    const node = super.attachDefaultNode();\n    if (node) {\n      this.__updateNodeId(node);\n    }\n    return node;\n  }\n\n  /**\n   * Override to restore default node when a custom one is removed.\n   *\n   * @protected\n   */\n  restoreDefaultNode() {\n    // To be implemented\n  }\n\n  /**\n   * Override to update default node text on property change.\n   *\n   * @param {Node} node\n   * @protected\n   */\n  updateDefaultNode(node) {\n    this.__notifyChange(node);\n  }\n\n  /**\n   * Setup the mutation observer on the node to update ID and notify host.\n   * Node doesn't get observed automatically until this method is called.\n   *\n   * @param {Node} node\n   * @protected\n   */\n  observeNode(node) {\n    // Stop observing the previous node, if any.\n    if (this.__nodeObserver) {\n      this.__nodeObserver.disconnect();\n    }\n    this.__nodeObserver = new MutationObserver(mutations => {\n      mutations.forEach(mutation => {\n        const target = mutation.target;\n\n        // Ensure the mutation target is the currently connected node\n        // to ignore async mutations dispatched for removed element.\n        const isCurrentNodeMutation = target === this.node;\n        if (mutation.type === 'attributes') {\n          // We use attributeFilter to only observe ID mutation,\n          // no need to check for attribute name separately.\n          if (isCurrentNodeMutation) {\n            this.__updateNodeId(target);\n          }\n        } else if (isCurrentNodeMutation || target.parentElement === this.node) {\n          // Node text content has changed.\n          this.__notifyChange(this.node);\n        }\n      });\n    });\n\n    // Observe changes to node ID attribute, text content and children.\n    this.__nodeObserver.observe(node, {\n      attributes: true,\n      attributeFilter: ['id'],\n      childList: true,\n      subtree: true,\n      characterData: true\n    });\n  }\n\n  /**\n   * Returns true if a node is an HTML element with children,\n   * or is a defined custom element, or has non-empty text.\n   *\n   * @param {Node} node\n   * @return {boolean}\n   * @private\n   */\n  __hasContent(node) {\n    if (!node) {\n      return false;\n    }\n    return node.nodeType === Node.ELEMENT_NODE && (customElements.get(node.localName) || node.children.length > 0) || node.textContent && node.textContent.trim() !== '';\n  }\n\n  /**\n   * Fire an event to notify the controller host about node changes.\n   *\n   * @param {Node} node\n   * @private\n   */\n  __notifyChange(node) {\n    this.dispatchEvent(new CustomEvent('slot-content-changed', {\n      detail: {\n        hasContent: this.__hasContent(node),\n        node\n      }\n    }));\n  }\n\n  /**\n   * Set default ID on the node in case it is an HTML element.\n   *\n   * @param {Node} node\n   * @private\n   */\n  __updateNodeId(node) {\n    // When in multiple mode, only set ID attribute on the element in default slot.\n    const isFirstNode = !this.nodes || node === this.nodes[0];\n    if (node.nodeType === Node.ELEMENT_NODE && (!this.multiple || isFirstNode) && !node.id) {\n      node.id = this.defaultId;\n    }\n  }\n}","map":{"version":3,"names":["SlotController","SlotChildObserveController","constructor","host","slot","tagName","config","useUniqueId","initCustomNode","node","__updateNodeId","__notifyChange","teardownNode","_node","getSlotChild","defaultNode","restoreDefaultNode","updateDefaultNode","attachDefaultNode","observeNode","__nodeObserver","disconnect","MutationObserver","mutations","forEach","mutation","target","isCurrentNodeMutation","type","parentElement","observe","attributes","attributeFilter","childList","subtree","characterData","__hasContent","nodeType","Node","ELEMENT_NODE","customElements","get","localName","children","length","textContent","trim","dispatchEvent","CustomEvent","detail","hasContent","isFirstNode","nodes","multiple","id","defaultId"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@vaadin/component-base/src/slot-child-observe-controller.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2022 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { SlotController } from './slot-controller.js';\n\n/**\n * A controller that observes slotted element mutations, especially ID attribute\n * and the text content, and fires an event to notify host element about those.\n */\nexport class SlotChildObserveController extends SlotController {\n  constructor(host, slot, tagName, config = {}) {\n    super(host, slot, tagName, { ...config, useUniqueId: true });\n  }\n\n  /**\n   * Override to initialize the newly added custom node.\n   *\n   * @param {Node} node\n   * @protected\n   * @override\n   */\n  initCustomNode(node) {\n    this.__updateNodeId(node);\n    this.__notifyChange(node);\n  }\n\n  /**\n   * Override to notify the controller host about removal of\n   * the custom node, and to apply the default one if needed.\n   *\n   * @param {Node} _node\n   * @protected\n   * @override\n   */\n  teardownNode(_node) {\n    const node = this.getSlotChild();\n\n    // Custom node is added to the slot\n    if (node && node !== this.defaultNode) {\n      this.__notifyChange(node);\n    } else {\n      this.restoreDefaultNode();\n      this.updateDefaultNode(this.node);\n    }\n  }\n\n  /**\n   * Override method inherited from `SlotMixin`\n   * to set ID attribute on the default node.\n   *\n   * @return {Node}\n   * @protected\n   * @override\n   */\n  attachDefaultNode() {\n    const node = super.attachDefaultNode();\n\n    if (node) {\n      this.__updateNodeId(node);\n    }\n\n    return node;\n  }\n\n  /**\n   * Override to restore default node when a custom one is removed.\n   *\n   * @protected\n   */\n  restoreDefaultNode() {\n    // To be implemented\n  }\n\n  /**\n   * Override to update default node text on property change.\n   *\n   * @param {Node} node\n   * @protected\n   */\n  updateDefaultNode(node) {\n    this.__notifyChange(node);\n  }\n\n  /**\n   * Setup the mutation observer on the node to update ID and notify host.\n   * Node doesn't get observed automatically until this method is called.\n   *\n   * @param {Node} node\n   * @protected\n   */\n  observeNode(node) {\n    // Stop observing the previous node, if any.\n    if (this.__nodeObserver) {\n      this.__nodeObserver.disconnect();\n    }\n\n    this.__nodeObserver = new MutationObserver((mutations) => {\n      mutations.forEach((mutation) => {\n        const target = mutation.target;\n\n        // Ensure the mutation target is the currently connected node\n        // to ignore async mutations dispatched for removed element.\n        const isCurrentNodeMutation = target === this.node;\n\n        if (mutation.type === 'attributes') {\n          // We use attributeFilter to only observe ID mutation,\n          // no need to check for attribute name separately.\n          if (isCurrentNodeMutation) {\n            this.__updateNodeId(target);\n          }\n        } else if (isCurrentNodeMutation || target.parentElement === this.node) {\n          // Node text content has changed.\n          this.__notifyChange(this.node);\n        }\n      });\n    });\n\n    // Observe changes to node ID attribute, text content and children.\n    this.__nodeObserver.observe(node, {\n      attributes: true,\n      attributeFilter: ['id'],\n      childList: true,\n      subtree: true,\n      characterData: true,\n    });\n  }\n\n  /**\n   * Returns true if a node is an HTML element with children,\n   * or is a defined custom element, or has non-empty text.\n   *\n   * @param {Node} node\n   * @return {boolean}\n   * @private\n   */\n  __hasContent(node) {\n    if (!node) {\n      return false;\n    }\n\n    return (\n      (node.nodeType === Node.ELEMENT_NODE && (customElements.get(node.localName) || node.children.length > 0)) ||\n      (node.textContent && node.textContent.trim() !== '')\n    );\n  }\n\n  /**\n   * Fire an event to notify the controller host about node changes.\n   *\n   * @param {Node} node\n   * @private\n   */\n  __notifyChange(node) {\n    this.dispatchEvent(\n      new CustomEvent('slot-content-changed', {\n        detail: { hasContent: this.__hasContent(node), node },\n      }),\n    );\n  }\n\n  /**\n   * Set default ID on the node in case it is an HTML element.\n   *\n   * @param {Node} node\n   * @private\n   */\n  __updateNodeId(node) {\n    // When in multiple mode, only set ID attribute on the element in default slot.\n    const isFirstNode = !this.nodes || node === this.nodes[0];\n    if (node.nodeType === Node.ELEMENT_NODE && (!this.multiple || isFirstNode) && !node.id) {\n      node.id = this.defaultId;\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}