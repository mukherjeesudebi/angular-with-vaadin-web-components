{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2016 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { isElementHidden } from '@vaadin/a11y-base';\nimport { animationFrame, microTask, timeOut } from '@vaadin/component-base/src/async.js';\nimport { Debouncer } from '@vaadin/component-base/src/debounce.js';\nimport { getNormalizedScrollLeft } from '@vaadin/component-base/src/dir-utils.js';\nimport { ResizeMixin } from '@vaadin/component-base/src/resize-mixin.js';\nconst timeouts = {\n  SCROLLING: 500,\n  UPDATE_CONTENT_VISIBILITY: 100\n};\n\n/**\n * @polymerMixin\n */\nexport const ScrollMixin = superClass => class ScrollMixin extends ResizeMixin(superClass) {\n  static get properties() {\n    return {\n      /**\n       * Allows you to choose between modes for rendering columns in the grid:\n       *\n       * \"eager\" (default): All columns are rendered upfront, regardless of their visibility within the viewport.\n       * This mode should generally be preferred, as it avoids the limitations imposed by the \"lazy\" mode.\n       * Use this mode unless the grid has a large number of columns and performance outweighs the limitations\n       * in priority.\n       *\n       * \"lazy\": Optimizes the rendering of cells when there are multiple columns in the grid by virtualizing\n       * horizontal scrolling. In this mode, body cells are rendered only when their corresponding columns are\n       * inside the visible viewport.\n       *\n       * Using \"lazy\" rendering should be used only if you're dealing with a large number of columns and performance\n       * is your highest priority. For most use cases, the default \"eager\" mode is recommended due to the\n       * limitations imposed by the \"lazy\" mode.\n       *\n       * When using the \"lazy\" mode, keep the following limitations in mind:\n       *\n       * - Row Height: When only a number of columns are visible at once, the height of a row can only be that of\n       * the highest cell currently visible on that row. Make sure each cell on a single row has the same height\n       * as all other cells on that row. If row cells have different heights, users may experience jumpiness when\n       * scrolling the grid horizontally as lazily rendered cells with different heights are scrolled into view.\n       *\n       * - Auto-width Columns: For the columns that are initially outside the visible viewport but still use auto-width,\n       * only the header content is taken into account when calculating the column width because the body cells\n       * of the columns outside the viewport are not initially rendered.\n       *\n       * - Screen Reader Compatibility: Screen readers may not be able to associate the focused cells with the correct\n       * headers when only a subset of the body cells on a row is rendered.\n       *\n       * - Keyboard Navigation: Tabbing through focusable elements inside the grid body may not work as expected because\n       * some of the columns that would include focusable elements in the body cells may be outside the visible viewport\n       * and thus not rendered.\n       *\n       * @attr {eager|lazy} column-rendering\n       * @type {!ColumnRendering}\n       */\n      columnRendering: {\n        type: String,\n        value: 'eager'\n      },\n      /**\n       * Cached array of frozen cells\n       * @private\n       */\n      _frozenCells: {\n        type: Array,\n        value: () => []\n      },\n      /**\n       * Cached array of cells frozen to end\n       * @private\n       */\n      _frozenToEndCells: {\n        type: Array,\n        value: () => []\n      },\n      /** @private */\n      _rowWithFocusedElement: Element\n    };\n  }\n  static get observers() {\n    return ['__columnRenderingChanged(_columnTree, columnRendering)'];\n  }\n\n  /** @private */\n  get _scrollLeft() {\n    return this.$.table.scrollLeft;\n  }\n\n  /** @private */\n  get _scrollTop() {\n    return this.$.table.scrollTop;\n  }\n\n  /**\n   * Override (from iron-scroll-target-behavior) to avoid document scroll\n   * @private\n   */\n  set _scrollTop(top) {\n    this.$.table.scrollTop = top;\n  }\n\n  /** @protected */\n  get _lazyColumns() {\n    return this.columnRendering === 'lazy';\n  }\n\n  /** @protected */\n  ready() {\n    super.ready();\n    this.scrollTarget = this.$.table;\n    this.$.items.addEventListener('focusin', e => {\n      const itemsIndex = e.composedPath().indexOf(this.$.items);\n      this._rowWithFocusedElement = e.composedPath()[itemsIndex - 1];\n    });\n    this.$.items.addEventListener('focusout', () => {\n      this._rowWithFocusedElement = undefined;\n    });\n    this.$.table.addEventListener('scroll', () => this._afterScroll());\n  }\n\n  /**\n   * @protected\n   * @override\n   */\n  _onResize() {\n    this._updateOverflow();\n    this.__updateHorizontalScrollPosition();\n\n    // For Firefox, manually restore last scroll position when grid becomes\n    // visible again. This solves an issue where switching visibility of two\n    // grids causes Firefox trying to synchronize the scroll positions between\n    // the two grid's table elements.\n    // See https://github.com/vaadin/web-components/issues/5796\n    if (this._firefox) {\n      const isVisible = !isElementHidden(this);\n      if (isVisible && this.__previousVisible === false) {\n        this._scrollTop = this.__memorizedScrollTop || 0;\n      }\n      this.__previousVisible = isVisible;\n    }\n  }\n\n  /**\n   * Scroll to a flat index in the grid. The method doesn't take into account\n   * the hierarchy of the items.\n   *\n   * @param {number} index Row index to scroll to\n   * @protected\n   */\n  _scrollToFlatIndex(index) {\n    index = Math.min(this._effectiveSize - 1, Math.max(0, index));\n    this.__virtualizer.scrollToIndex(index);\n    this.__scrollIntoViewport(index);\n  }\n\n  /**\n   * Makes sure the row with the given index (if found in the DOM) is fully\n   * inside the visible viewport, taking header/footer into account.\n   * @private\n   */\n  __scrollIntoViewport(index) {\n    const rowElement = [...this.$.items.children].find(child => child.index === index);\n    if (rowElement) {\n      const dstRect = rowElement.getBoundingClientRect();\n      const footerTop = this.$.footer.getBoundingClientRect().top;\n      const headerBottom = this.$.header.getBoundingClientRect().bottom;\n      if (dstRect.bottom > footerTop) {\n        this.$.table.scrollTop += dstRect.bottom - footerTop;\n      } else if (dstRect.top < headerBottom) {\n        this.$.table.scrollTop -= headerBottom - dstRect.top;\n      }\n    }\n  }\n\n  /** @private */\n  _scheduleScrolling() {\n    if (!this._scrollingFrame) {\n      // Defer setting state attributes to avoid Edge hiccups\n      this._scrollingFrame = requestAnimationFrame(() => this.$.scroller.toggleAttribute('scrolling', true));\n    }\n    this._debounceScrolling = Debouncer.debounce(this._debounceScrolling, timeOut.after(timeouts.SCROLLING), () => {\n      cancelAnimationFrame(this._scrollingFrame);\n      delete this._scrollingFrame;\n      this.$.scroller.toggleAttribute('scrolling', false);\n    });\n  }\n\n  /** @private */\n  _afterScroll() {\n    this.__updateHorizontalScrollPosition();\n    if (!this.hasAttribute('reordering')) {\n      this._scheduleScrolling();\n    }\n    if (!this.hasAttribute('navigating')) {\n      this._hideTooltip(true);\n    }\n    this._updateOverflow();\n    this._debounceColumnContentVisibility = Debouncer.debounce(this._debounceColumnContentVisibility, timeOut.after(timeouts.UPDATE_CONTENT_VISIBILITY), () => {\n      // If horizontal scroll position changed and lazy column rendering is enabled,\n      // update the visible columns.\n      if (this._lazyColumns && this.__cachedScrollLeft !== this._scrollLeft) {\n        this.__cachedScrollLeft = this._scrollLeft;\n        this.__updateColumnsBodyContentHidden();\n      }\n    });\n\n    // Memorize last scroll position in Firefox\n    if (this._firefox) {\n      const isVisible = !isElementHidden(this);\n      if (isVisible && this.__previousVisible !== false) {\n        this.__memorizedScrollTop = this._scrollTop;\n      }\n    }\n  }\n\n  /** @private */\n  __updateColumnsBodyContentHidden() {\n    if (!this._columnTree) {\n      return;\n    }\n    const columnsInOrder = this._getColumnsInOrder();\n\n    // Return if sizer cells are not yet assigned to columns\n    if (!columnsInOrder[0] || !columnsInOrder[0]._sizerCell) {\n      return;\n    }\n    let bodyContentHiddenChanged = false;\n\n    // Remove the column cells from the DOM if the column is outside the viewport.\n    // Add the column cells to the DOM if the column is inside the viewport.\n    //\n    // Update the _bodyContentHidden property of the column to reflect the current\n    // visibility state and make it run renderers for the cells if necessary.\n    columnsInOrder.forEach(column => {\n      const bodyContentHidden = this._lazyColumns && !this.__isColumnInViewport(column);\n      if (column._bodyContentHidden !== bodyContentHidden) {\n        bodyContentHiddenChanged = true;\n        column._cells.forEach(cell => {\n          if (cell !== column._sizerCell) {\n            if (bodyContentHidden) {\n              cell.remove();\n            } else if (cell.__parentRow) {\n              // Add the cell to the correct DOM position in the row\n              const followingColumnCell = [...cell.__parentRow.children].find(child => columnsInOrder.indexOf(child._column) > columnsInOrder.indexOf(column));\n              cell.__parentRow.insertBefore(cell, followingColumnCell);\n            }\n          }\n        });\n      }\n      column._bodyContentHidden = bodyContentHidden;\n    });\n    if (bodyContentHiddenChanged) {\n      // Frozen columns may have changed their visibility\n      this._frozenCellsChanged();\n    }\n    if (this._lazyColumns) {\n      // Calculate the offset to apply to the body cells\n      const lastFrozenColumn = [...columnsInOrder].reverse().find(column => column.frozen);\n      const lastFrozenColumnEnd = this.__getColumnEnd(lastFrozenColumn);\n      const firstVisibleColumn = columnsInOrder.find(column => !column.frozen && !column._bodyContentHidden);\n      this.__lazyColumnsStart = this.__getColumnStart(firstVisibleColumn) - lastFrozenColumnEnd;\n      this.$.items.style.setProperty('--_grid-lazy-columns-start', `${this.__lazyColumnsStart}px`);\n\n      // Make sure the body has a focusable element in lazy columns mode\n      this._resetKeyboardNavigation();\n    }\n  }\n\n  /** @private */\n  __getColumnEnd(column) {\n    if (!column) {\n      return this.__isRTL ? this.$.table.clientWidth : 0;\n    }\n    return column._sizerCell.offsetLeft + (this.__isRTL ? 0 : column._sizerCell.offsetWidth);\n  }\n\n  /** @private */\n  __getColumnStart(column) {\n    if (!column) {\n      return this.__isRTL ? this.$.table.clientWidth : 0;\n    }\n    return column._sizerCell.offsetLeft + (this.__isRTL ? column._sizerCell.offsetWidth : 0);\n  }\n\n  /**\n   * Returns true if the given column is horizontally inside the viewport.\n   * @private\n   */\n  __isColumnInViewport(column) {\n    if (column.frozen || column.frozenToEnd) {\n      // Assume frozen columns to always be inside the viewport\n      return true;\n    }\n\n    // Check if the column's sizer cell is inside the viewport\n    return this.__isHorizontallyInViewport(column._sizerCell);\n  }\n\n  /** @private */\n  __isHorizontallyInViewport(element) {\n    return element.offsetLeft + element.offsetWidth >= this._scrollLeft && element.offsetLeft <= this._scrollLeft + this.clientWidth;\n  }\n\n  /** @private */\n  __columnRenderingChanged(_columnTree, columnRendering) {\n    if (columnRendering === 'eager') {\n      this.$.scroller.removeAttribute('column-rendering');\n    } else {\n      this.$.scroller.setAttribute('column-rendering', columnRendering);\n    }\n    this.__updateColumnsBodyContentHidden();\n  }\n\n  /** @private */\n  _updateOverflow() {\n    this._debounceOverflow = Debouncer.debounce(this._debounceOverflow, animationFrame, () => {\n      this.__doUpdateOverflow();\n    });\n  }\n\n  /** @private */\n  __doUpdateOverflow() {\n    // Set overflow styling attributes\n    let overflow = '';\n    const table = this.$.table;\n    if (table.scrollTop < table.scrollHeight - table.clientHeight) {\n      overflow += ' bottom';\n    }\n    if (table.scrollTop > 0) {\n      overflow += ' top';\n    }\n    const scrollLeft = getNormalizedScrollLeft(table, this.getAttribute('dir'));\n    if (scrollLeft > 0) {\n      overflow += ' start';\n    }\n    if (scrollLeft < table.scrollWidth - table.clientWidth) {\n      overflow += ' end';\n    }\n    if (this.__isRTL) {\n      overflow = overflow.replace(/start|end/giu, matched => {\n        return matched === 'start' ? 'end' : 'start';\n      });\n    }\n\n    // TODO: Remove \"right\" and \"left\" values in the next major.\n    if (table.scrollLeft < table.scrollWidth - table.clientWidth) {\n      overflow += ' right';\n    }\n    if (table.scrollLeft > 0) {\n      overflow += ' left';\n    }\n    const value = overflow.trim();\n    if (value.length > 0 && this.getAttribute('overflow') !== value) {\n      this.setAttribute('overflow', value);\n    } else if (value.length === 0 && this.hasAttribute('overflow')) {\n      this.removeAttribute('overflow');\n    }\n  }\n\n  /** @protected */\n  _frozenCellsChanged() {\n    this._debouncerCacheElements = Debouncer.debounce(this._debouncerCacheElements, microTask, () => {\n      Array.from(this.shadowRoot.querySelectorAll('[part~=\"cell\"]')).forEach(cell => {\n        cell.style.transform = '';\n      });\n      this._frozenCells = Array.prototype.slice.call(this.$.table.querySelectorAll('[frozen]'));\n      this._frozenToEndCells = Array.prototype.slice.call(this.$.table.querySelectorAll('[frozen-to-end]'));\n      this.__updateHorizontalScrollPosition();\n    });\n    this._debounceUpdateFrozenColumn();\n  }\n\n  /** @protected */\n  _debounceUpdateFrozenColumn() {\n    this.__debounceUpdateFrozenColumn = Debouncer.debounce(this.__debounceUpdateFrozenColumn, microTask, () => this._updateFrozenColumn());\n  }\n\n  /** @private */\n  _updateFrozenColumn() {\n    if (!this._columnTree) {\n      return;\n    }\n    const columnsRow = this._columnTree[this._columnTree.length - 1].slice(0);\n    columnsRow.sort((a, b) => {\n      return a._order - b._order;\n    });\n    let lastFrozen;\n    let firstFrozenToEnd;\n\n    // Use for loop to only iterate columns once\n    for (let i = 0; i < columnsRow.length; i++) {\n      const col = columnsRow[i];\n      col._lastFrozen = false;\n      col._firstFrozenToEnd = false;\n      if (firstFrozenToEnd === undefined && col.frozenToEnd && !col.hidden) {\n        firstFrozenToEnd = i;\n      }\n      if (col.frozen && !col.hidden) {\n        lastFrozen = i;\n      }\n    }\n    if (lastFrozen !== undefined) {\n      columnsRow[lastFrozen]._lastFrozen = true;\n    }\n    if (firstFrozenToEnd !== undefined) {\n      columnsRow[firstFrozenToEnd]._firstFrozenToEnd = true;\n    }\n    this.__updateColumnsBodyContentHidden();\n  }\n\n  /** @private */\n  __updateHorizontalScrollPosition() {\n    if (!this._columnTree) {\n      return;\n    }\n    const scrollWidth = this.$.table.scrollWidth;\n    const clientWidth = this.$.table.clientWidth;\n    const scrollLeft = Math.max(0, this.$.table.scrollLeft);\n    const normalizedScrollLeft = getNormalizedScrollLeft(this.$.table, this.getAttribute('dir'));\n\n    // Position header, footer and items container\n    const transform = `translate(${-scrollLeft}px, 0)`;\n    this.$.header.style.transform = transform;\n    this.$.footer.style.transform = transform;\n    this.$.items.style.transform = transform;\n\n    // Position frozen cells\n    const x = this.__isRTL ? normalizedScrollLeft + clientWidth - scrollWidth : scrollLeft;\n    const transformFrozen = `translate(${x}px, 0)`;\n    this._frozenCells.forEach(cell => {\n      cell.style.transform = transformFrozen;\n    });\n\n    // Position cells frozen to end\n    const remaining = this.__isRTL ? normalizedScrollLeft : scrollLeft + clientWidth - scrollWidth;\n    const transformFrozenToEnd = `translate(${remaining}px, 0)`;\n    let transformFrozenToEndBody = transformFrozenToEnd;\n    if (this._lazyColumns) {\n      // Lazy column rendering is used, calculate the offset to apply to the frozen to end cells\n      const columnsInOrder = this._getColumnsInOrder();\n      const lastVisibleColumn = [...columnsInOrder].reverse().find(column => !column.frozenToEnd && !column._bodyContentHidden);\n      const lastVisibleColumnEnd = this.__getColumnEnd(lastVisibleColumn);\n      const firstFrozenToEndColumn = columnsInOrder.find(column => column.frozenToEnd);\n      const firstFrozenToEndColumnStart = this.__getColumnStart(firstFrozenToEndColumn);\n      const translateX = remaining + (firstFrozenToEndColumnStart - lastVisibleColumnEnd) + this.__lazyColumnsStart;\n      transformFrozenToEndBody = `translate(${translateX}px, 0)`;\n    }\n    this._frozenToEndCells.forEach(cell => {\n      if (this.$.items.contains(cell)) {\n        cell.style.transform = transformFrozenToEndBody;\n      } else {\n        cell.style.transform = transformFrozenToEnd;\n      }\n    });\n\n    // Only update the --_grid-horizontal-scroll-position custom property when navigating\n    // on row focus mode to avoid performance issues.\n    if (this.hasAttribute('navigating') && this.__rowFocusMode) {\n      this.$.table.style.setProperty('--_grid-horizontal-scroll-position', `${-x}px`);\n    }\n  }\n};","map":{"version":3,"names":["isElementHidden","animationFrame","microTask","timeOut","Debouncer","getNormalizedScrollLeft","ResizeMixin","timeouts","SCROLLING","UPDATE_CONTENT_VISIBILITY","ScrollMixin","superClass","properties","columnRendering","type","String","value","_frozenCells","Array","_frozenToEndCells","_rowWithFocusedElement","Element","observers","_scrollLeft","$","table","scrollLeft","_scrollTop","scrollTop","top","_lazyColumns","ready","scrollTarget","items","addEventListener","e","itemsIndex","composedPath","indexOf","undefined","_afterScroll","_onResize","_updateOverflow","__updateHorizontalScrollPosition","_firefox","isVisible","__previousVisible","__memorizedScrollTop","_scrollToFlatIndex","index","Math","min","_effectiveSize","max","__virtualizer","scrollToIndex","__scrollIntoViewport","rowElement","children","find","child","dstRect","getBoundingClientRect","footerTop","footer","headerBottom","header","bottom","_scheduleScrolling","_scrollingFrame","requestAnimationFrame","scroller","toggleAttribute","_debounceScrolling","debounce","after","cancelAnimationFrame","hasAttribute","_hideTooltip","_debounceColumnContentVisibility","__cachedScrollLeft","__updateColumnsBodyContentHidden","_columnTree","columnsInOrder","_getColumnsInOrder","_sizerCell","bodyContentHiddenChanged","forEach","column","bodyContentHidden","__isColumnInViewport","_bodyContentHidden","_cells","cell","remove","__parentRow","followingColumnCell","_column","insertBefore","_frozenCellsChanged","lastFrozenColumn","reverse","frozen","lastFrozenColumnEnd","__getColumnEnd","firstVisibleColumn","__lazyColumnsStart","__getColumnStart","style","setProperty","_resetKeyboardNavigation","__isRTL","clientWidth","offsetLeft","offsetWidth","frozenToEnd","__isHorizontallyInViewport","element","__columnRenderingChanged","removeAttribute","setAttribute","_debounceOverflow","__doUpdateOverflow","overflow","scrollHeight","clientHeight","getAttribute","scrollWidth","replace","matched","trim","length","_debouncerCacheElements","from","shadowRoot","querySelectorAll","transform","prototype","slice","call","_debounceUpdateFrozenColumn","__debounceUpdateFrozenColumn","_updateFrozenColumn","columnsRow","sort","a","b","_order","lastFrozen","firstFrozenToEnd","i","col","_lastFrozen","_firstFrozenToEnd","hidden","normalizedScrollLeft","x","transformFrozen","remaining","transformFrozenToEnd","transformFrozenToEndBody","lastVisibleColumn","lastVisibleColumnEnd","firstFrozenToEndColumn","firstFrozenToEndColumnStart","translateX","contains","__rowFocusMode"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@vaadin/grid/src/vaadin-grid-scroll-mixin.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2016 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { isElementHidden } from '@vaadin/a11y-base';\nimport { animationFrame, microTask, timeOut } from '@vaadin/component-base/src/async.js';\nimport { Debouncer } from '@vaadin/component-base/src/debounce.js';\nimport { getNormalizedScrollLeft } from '@vaadin/component-base/src/dir-utils.js';\nimport { ResizeMixin } from '@vaadin/component-base/src/resize-mixin.js';\n\nconst timeouts = {\n  SCROLLING: 500,\n  UPDATE_CONTENT_VISIBILITY: 100,\n};\n\n/**\n * @polymerMixin\n */\nexport const ScrollMixin = (superClass) =>\n  class ScrollMixin extends ResizeMixin(superClass) {\n    static get properties() {\n      return {\n        /**\n         * Allows you to choose between modes for rendering columns in the grid:\n         *\n         * \"eager\" (default): All columns are rendered upfront, regardless of their visibility within the viewport.\n         * This mode should generally be preferred, as it avoids the limitations imposed by the \"lazy\" mode.\n         * Use this mode unless the grid has a large number of columns and performance outweighs the limitations\n         * in priority.\n         *\n         * \"lazy\": Optimizes the rendering of cells when there are multiple columns in the grid by virtualizing\n         * horizontal scrolling. In this mode, body cells are rendered only when their corresponding columns are\n         * inside the visible viewport.\n         *\n         * Using \"lazy\" rendering should be used only if you're dealing with a large number of columns and performance\n         * is your highest priority. For most use cases, the default \"eager\" mode is recommended due to the\n         * limitations imposed by the \"lazy\" mode.\n         *\n         * When using the \"lazy\" mode, keep the following limitations in mind:\n         *\n         * - Row Height: When only a number of columns are visible at once, the height of a row can only be that of\n         * the highest cell currently visible on that row. Make sure each cell on a single row has the same height\n         * as all other cells on that row. If row cells have different heights, users may experience jumpiness when\n         * scrolling the grid horizontally as lazily rendered cells with different heights are scrolled into view.\n         *\n         * - Auto-width Columns: For the columns that are initially outside the visible viewport but still use auto-width,\n         * only the header content is taken into account when calculating the column width because the body cells\n         * of the columns outside the viewport are not initially rendered.\n         *\n         * - Screen Reader Compatibility: Screen readers may not be able to associate the focused cells with the correct\n         * headers when only a subset of the body cells on a row is rendered.\n         *\n         * - Keyboard Navigation: Tabbing through focusable elements inside the grid body may not work as expected because\n         * some of the columns that would include focusable elements in the body cells may be outside the visible viewport\n         * and thus not rendered.\n         *\n         * @attr {eager|lazy} column-rendering\n         * @type {!ColumnRendering}\n         */\n        columnRendering: {\n          type: String,\n          value: 'eager',\n        },\n\n        /**\n         * Cached array of frozen cells\n         * @private\n         */\n        _frozenCells: {\n          type: Array,\n          value: () => [],\n        },\n\n        /**\n         * Cached array of cells frozen to end\n         * @private\n         */\n        _frozenToEndCells: {\n          type: Array,\n          value: () => [],\n        },\n\n        /** @private */\n        _rowWithFocusedElement: Element,\n      };\n    }\n\n    static get observers() {\n      return ['__columnRenderingChanged(_columnTree, columnRendering)'];\n    }\n\n    /** @private */\n    get _scrollLeft() {\n      return this.$.table.scrollLeft;\n    }\n\n    /** @private */\n    get _scrollTop() {\n      return this.$.table.scrollTop;\n    }\n\n    /**\n     * Override (from iron-scroll-target-behavior) to avoid document scroll\n     * @private\n     */\n    set _scrollTop(top) {\n      this.$.table.scrollTop = top;\n    }\n\n    /** @protected */\n    get _lazyColumns() {\n      return this.columnRendering === 'lazy';\n    }\n\n    /** @protected */\n    ready() {\n      super.ready();\n\n      this.scrollTarget = this.$.table;\n\n      this.$.items.addEventListener('focusin', (e) => {\n        const itemsIndex = e.composedPath().indexOf(this.$.items);\n        this._rowWithFocusedElement = e.composedPath()[itemsIndex - 1];\n      });\n      this.$.items.addEventListener('focusout', () => {\n        this._rowWithFocusedElement = undefined;\n      });\n\n      this.$.table.addEventListener('scroll', () => this._afterScroll());\n    }\n\n    /**\n     * @protected\n     * @override\n     */\n    _onResize() {\n      this._updateOverflow();\n      this.__updateHorizontalScrollPosition();\n\n      // For Firefox, manually restore last scroll position when grid becomes\n      // visible again. This solves an issue where switching visibility of two\n      // grids causes Firefox trying to synchronize the scroll positions between\n      // the two grid's table elements.\n      // See https://github.com/vaadin/web-components/issues/5796\n      if (this._firefox) {\n        const isVisible = !isElementHidden(this);\n        if (isVisible && this.__previousVisible === false) {\n          this._scrollTop = this.__memorizedScrollTop || 0;\n        }\n        this.__previousVisible = isVisible;\n      }\n    }\n\n    /**\n     * Scroll to a flat index in the grid. The method doesn't take into account\n     * the hierarchy of the items.\n     *\n     * @param {number} index Row index to scroll to\n     * @protected\n     */\n    _scrollToFlatIndex(index) {\n      index = Math.min(this._effectiveSize - 1, Math.max(0, index));\n      this.__virtualizer.scrollToIndex(index);\n      this.__scrollIntoViewport(index);\n    }\n\n    /**\n     * Makes sure the row with the given index (if found in the DOM) is fully\n     * inside the visible viewport, taking header/footer into account.\n     * @private\n     */\n    __scrollIntoViewport(index) {\n      const rowElement = [...this.$.items.children].find((child) => child.index === index);\n      if (rowElement) {\n        const dstRect = rowElement.getBoundingClientRect();\n        const footerTop = this.$.footer.getBoundingClientRect().top;\n        const headerBottom = this.$.header.getBoundingClientRect().bottom;\n        if (dstRect.bottom > footerTop) {\n          this.$.table.scrollTop += dstRect.bottom - footerTop;\n        } else if (dstRect.top < headerBottom) {\n          this.$.table.scrollTop -= headerBottom - dstRect.top;\n        }\n      }\n    }\n\n    /** @private */\n    _scheduleScrolling() {\n      if (!this._scrollingFrame) {\n        // Defer setting state attributes to avoid Edge hiccups\n        this._scrollingFrame = requestAnimationFrame(() => this.$.scroller.toggleAttribute('scrolling', true));\n      }\n      this._debounceScrolling = Debouncer.debounce(this._debounceScrolling, timeOut.after(timeouts.SCROLLING), () => {\n        cancelAnimationFrame(this._scrollingFrame);\n        delete this._scrollingFrame;\n        this.$.scroller.toggleAttribute('scrolling', false);\n      });\n    }\n\n    /** @private */\n    _afterScroll() {\n      this.__updateHorizontalScrollPosition();\n\n      if (!this.hasAttribute('reordering')) {\n        this._scheduleScrolling();\n      }\n      if (!this.hasAttribute('navigating')) {\n        this._hideTooltip(true);\n      }\n\n      this._updateOverflow();\n\n      this._debounceColumnContentVisibility = Debouncer.debounce(\n        this._debounceColumnContentVisibility,\n        timeOut.after(timeouts.UPDATE_CONTENT_VISIBILITY),\n        () => {\n          // If horizontal scroll position changed and lazy column rendering is enabled,\n          // update the visible columns.\n          if (this._lazyColumns && this.__cachedScrollLeft !== this._scrollLeft) {\n            this.__cachedScrollLeft = this._scrollLeft;\n            this.__updateColumnsBodyContentHidden();\n          }\n        },\n      );\n\n      // Memorize last scroll position in Firefox\n      if (this._firefox) {\n        const isVisible = !isElementHidden(this);\n        if (isVisible && this.__previousVisible !== false) {\n          this.__memorizedScrollTop = this._scrollTop;\n        }\n      }\n    }\n\n    /** @private */\n    __updateColumnsBodyContentHidden() {\n      if (!this._columnTree) {\n        return;\n      }\n\n      const columnsInOrder = this._getColumnsInOrder();\n\n      // Return if sizer cells are not yet assigned to columns\n      if (!columnsInOrder[0] || !columnsInOrder[0]._sizerCell) {\n        return;\n      }\n\n      let bodyContentHiddenChanged = false;\n\n      // Remove the column cells from the DOM if the column is outside the viewport.\n      // Add the column cells to the DOM if the column is inside the viewport.\n      //\n      // Update the _bodyContentHidden property of the column to reflect the current\n      // visibility state and make it run renderers for the cells if necessary.\n      columnsInOrder.forEach((column) => {\n        const bodyContentHidden = this._lazyColumns && !this.__isColumnInViewport(column);\n\n        if (column._bodyContentHidden !== bodyContentHidden) {\n          bodyContentHiddenChanged = true;\n          column._cells.forEach((cell) => {\n            if (cell !== column._sizerCell) {\n              if (bodyContentHidden) {\n                cell.remove();\n              } else if (cell.__parentRow) {\n                // Add the cell to the correct DOM position in the row\n                const followingColumnCell = [...cell.__parentRow.children].find(\n                  (child) => columnsInOrder.indexOf(child._column) > columnsInOrder.indexOf(column),\n                );\n                cell.__parentRow.insertBefore(cell, followingColumnCell);\n              }\n            }\n          });\n        }\n\n        column._bodyContentHidden = bodyContentHidden;\n      });\n\n      if (bodyContentHiddenChanged) {\n        // Frozen columns may have changed their visibility\n        this._frozenCellsChanged();\n      }\n\n      if (this._lazyColumns) {\n        // Calculate the offset to apply to the body cells\n        const lastFrozenColumn = [...columnsInOrder].reverse().find((column) => column.frozen);\n        const lastFrozenColumnEnd = this.__getColumnEnd(lastFrozenColumn);\n        const firstVisibleColumn = columnsInOrder.find((column) => !column.frozen && !column._bodyContentHidden);\n        this.__lazyColumnsStart = this.__getColumnStart(firstVisibleColumn) - lastFrozenColumnEnd;\n        this.$.items.style.setProperty('--_grid-lazy-columns-start', `${this.__lazyColumnsStart}px`);\n\n        // Make sure the body has a focusable element in lazy columns mode\n        this._resetKeyboardNavigation();\n      }\n    }\n\n    /** @private */\n    __getColumnEnd(column) {\n      if (!column) {\n        return this.__isRTL ? this.$.table.clientWidth : 0;\n      }\n      return column._sizerCell.offsetLeft + (this.__isRTL ? 0 : column._sizerCell.offsetWidth);\n    }\n\n    /** @private */\n    __getColumnStart(column) {\n      if (!column) {\n        return this.__isRTL ? this.$.table.clientWidth : 0;\n      }\n      return column._sizerCell.offsetLeft + (this.__isRTL ? column._sizerCell.offsetWidth : 0);\n    }\n\n    /**\n     * Returns true if the given column is horizontally inside the viewport.\n     * @private\n     */\n    __isColumnInViewport(column) {\n      if (column.frozen || column.frozenToEnd) {\n        // Assume frozen columns to always be inside the viewport\n        return true;\n      }\n\n      // Check if the column's sizer cell is inside the viewport\n      return this.__isHorizontallyInViewport(column._sizerCell);\n    }\n\n    /** @private */\n    __isHorizontallyInViewport(element) {\n      return (\n        element.offsetLeft + element.offsetWidth >= this._scrollLeft &&\n        element.offsetLeft <= this._scrollLeft + this.clientWidth\n      );\n    }\n\n    /** @private */\n    __columnRenderingChanged(_columnTree, columnRendering) {\n      if (columnRendering === 'eager') {\n        this.$.scroller.removeAttribute('column-rendering');\n      } else {\n        this.$.scroller.setAttribute('column-rendering', columnRendering);\n      }\n\n      this.__updateColumnsBodyContentHidden();\n    }\n\n    /** @private */\n    _updateOverflow() {\n      this._debounceOverflow = Debouncer.debounce(this._debounceOverflow, animationFrame, () => {\n        this.__doUpdateOverflow();\n      });\n    }\n\n    /** @private */\n    __doUpdateOverflow() {\n      // Set overflow styling attributes\n      let overflow = '';\n      const table = this.$.table;\n      if (table.scrollTop < table.scrollHeight - table.clientHeight) {\n        overflow += ' bottom';\n      }\n\n      if (table.scrollTop > 0) {\n        overflow += ' top';\n      }\n\n      const scrollLeft = getNormalizedScrollLeft(table, this.getAttribute('dir'));\n      if (scrollLeft > 0) {\n        overflow += ' start';\n      }\n\n      if (scrollLeft < table.scrollWidth - table.clientWidth) {\n        overflow += ' end';\n      }\n\n      if (this.__isRTL) {\n        overflow = overflow.replace(/start|end/giu, (matched) => {\n          return matched === 'start' ? 'end' : 'start';\n        });\n      }\n\n      // TODO: Remove \"right\" and \"left\" values in the next major.\n      if (table.scrollLeft < table.scrollWidth - table.clientWidth) {\n        overflow += ' right';\n      }\n\n      if (table.scrollLeft > 0) {\n        overflow += ' left';\n      }\n\n      const value = overflow.trim();\n      if (value.length > 0 && this.getAttribute('overflow') !== value) {\n        this.setAttribute('overflow', value);\n      } else if (value.length === 0 && this.hasAttribute('overflow')) {\n        this.removeAttribute('overflow');\n      }\n    }\n\n    /** @protected */\n    _frozenCellsChanged() {\n      this._debouncerCacheElements = Debouncer.debounce(this._debouncerCacheElements, microTask, () => {\n        Array.from(this.shadowRoot.querySelectorAll('[part~=\"cell\"]')).forEach((cell) => {\n          cell.style.transform = '';\n        });\n        this._frozenCells = Array.prototype.slice.call(this.$.table.querySelectorAll('[frozen]'));\n        this._frozenToEndCells = Array.prototype.slice.call(this.$.table.querySelectorAll('[frozen-to-end]'));\n        this.__updateHorizontalScrollPosition();\n      });\n      this._debounceUpdateFrozenColumn();\n    }\n\n    /** @protected */\n    _debounceUpdateFrozenColumn() {\n      this.__debounceUpdateFrozenColumn = Debouncer.debounce(this.__debounceUpdateFrozenColumn, microTask, () =>\n        this._updateFrozenColumn(),\n      );\n    }\n\n    /** @private */\n    _updateFrozenColumn() {\n      if (!this._columnTree) {\n        return;\n      }\n\n      const columnsRow = this._columnTree[this._columnTree.length - 1].slice(0);\n      columnsRow.sort((a, b) => {\n        return a._order - b._order;\n      });\n\n      let lastFrozen;\n      let firstFrozenToEnd;\n\n      // Use for loop to only iterate columns once\n      for (let i = 0; i < columnsRow.length; i++) {\n        const col = columnsRow[i];\n\n        col._lastFrozen = false;\n        col._firstFrozenToEnd = false;\n\n        if (firstFrozenToEnd === undefined && col.frozenToEnd && !col.hidden) {\n          firstFrozenToEnd = i;\n        }\n\n        if (col.frozen && !col.hidden) {\n          lastFrozen = i;\n        }\n      }\n\n      if (lastFrozen !== undefined) {\n        columnsRow[lastFrozen]._lastFrozen = true;\n      }\n\n      if (firstFrozenToEnd !== undefined) {\n        columnsRow[firstFrozenToEnd]._firstFrozenToEnd = true;\n      }\n\n      this.__updateColumnsBodyContentHidden();\n    }\n\n    /** @private */\n    __updateHorizontalScrollPosition() {\n      if (!this._columnTree) {\n        return;\n      }\n      const scrollWidth = this.$.table.scrollWidth;\n      const clientWidth = this.$.table.clientWidth;\n      const scrollLeft = Math.max(0, this.$.table.scrollLeft);\n      const normalizedScrollLeft = getNormalizedScrollLeft(this.$.table, this.getAttribute('dir'));\n\n      // Position header, footer and items container\n      const transform = `translate(${-scrollLeft}px, 0)`;\n      this.$.header.style.transform = transform;\n      this.$.footer.style.transform = transform;\n      this.$.items.style.transform = transform;\n\n      // Position frozen cells\n      const x = this.__isRTL ? normalizedScrollLeft + clientWidth - scrollWidth : scrollLeft;\n      const transformFrozen = `translate(${x}px, 0)`;\n      this._frozenCells.forEach((cell) => {\n        cell.style.transform = transformFrozen;\n      });\n\n      // Position cells frozen to end\n      const remaining = this.__isRTL ? normalizedScrollLeft : scrollLeft + clientWidth - scrollWidth;\n      const transformFrozenToEnd = `translate(${remaining}px, 0)`;\n\n      let transformFrozenToEndBody = transformFrozenToEnd;\n\n      if (this._lazyColumns) {\n        // Lazy column rendering is used, calculate the offset to apply to the frozen to end cells\n        const columnsInOrder = this._getColumnsInOrder();\n\n        const lastVisibleColumn = [...columnsInOrder]\n          .reverse()\n          .find((column) => !column.frozenToEnd && !column._bodyContentHidden);\n        const lastVisibleColumnEnd = this.__getColumnEnd(lastVisibleColumn);\n\n        const firstFrozenToEndColumn = columnsInOrder.find((column) => column.frozenToEnd);\n        const firstFrozenToEndColumnStart = this.__getColumnStart(firstFrozenToEndColumn);\n\n        const translateX = remaining + (firstFrozenToEndColumnStart - lastVisibleColumnEnd) + this.__lazyColumnsStart;\n        transformFrozenToEndBody = `translate(${translateX}px, 0)`;\n      }\n\n      this._frozenToEndCells.forEach((cell) => {\n        if (this.$.items.contains(cell)) {\n          cell.style.transform = transformFrozenToEndBody;\n        } else {\n          cell.style.transform = transformFrozenToEnd;\n        }\n      });\n\n      // Only update the --_grid-horizontal-scroll-position custom property when navigating\n      // on row focus mode to avoid performance issues.\n      if (this.hasAttribute('navigating') && this.__rowFocusMode) {\n        this.$.table.style.setProperty('--_grid-horizontal-scroll-position', `${-x}px`);\n      }\n    }\n  };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}