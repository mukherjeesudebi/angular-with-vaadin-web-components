{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\nimport { animationFrame, idlePeriod, microTask } from './async.js';\nimport { Debouncer, enqueueDebouncer, flush } from './debounce.js';\nconst IOS = navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\\d+)/u);\nconst IOS_TOUCH_SCROLLING = IOS && IOS[1] >= 8;\nconst DEFAULT_PHYSICAL_COUNT = 3;\n\n/**\n * DO NOT EDIT THIS FILE!\n *\n * This file includes the iron-list scrolling engine copied from\n * https://github.com/PolymerElements/iron-list/blob/master/iron-list.js\n *\n * If something in the scrolling engine needs to be changed\n * for the virtualizer's purposes, override a function\n * in virtualizer-iron-list-adapter.js instead of changing it here.\n * If a function on this file is no longer needed, the code can be safely deleted.\n *\n * This will allow us to keep the iron-list code here as close to\n * the original as possible.\n */\nexport const ironList = {\n  /**\n   * The ratio of hidden tiles that should remain in the scroll direction.\n   * Recommended value ~0.5, so it will distribute tiles evenly in both\n   * directions.\n   */\n  _ratio: 0.5,\n  /**\n   * The padding-top value for the list.\n   */\n  _scrollerPaddingTop: 0,\n  /**\n   * This value is a cached value of `scrollTop` from the last `scroll` event.\n   */\n  _scrollPosition: 0,\n  /**\n   * The sum of the heights of all the tiles in the DOM.\n   */\n  _physicalSize: 0,\n  /**\n   * The average `offsetHeight` of the tiles observed till now.\n   */\n  _physicalAverage: 0,\n  /**\n   * The number of tiles which `offsetHeight` > 0 observed until now.\n   */\n  _physicalAverageCount: 0,\n  /**\n   * The Y position of the item rendered in the `_physicalStart`\n   * tile relative to the scrolling list.\n   */\n  _physicalTop: 0,\n  /**\n   * The number of items in the list.\n   */\n  _virtualCount: 0,\n  /**\n   * The estimated scroll height based on `_physicalAverage`\n   */\n  _estScrollHeight: 0,\n  /**\n   * The scroll height of the dom node\n   */\n  _scrollHeight: 0,\n  /**\n   * The height of the list. This is referred as the viewport in the context of\n   * list.\n   */\n  _viewportHeight: 0,\n  /**\n   * The width of the list. This is referred as the viewport in the context of\n   * list.\n   */\n  _viewportWidth: 0,\n  /**\n   * An array of DOM nodes that are currently in the tree\n   * @type {?Array<!HTMLElement>}\n   */\n  _physicalItems: null,\n  /**\n   * An array of heights for each item in `_physicalItems`\n   * @type {?Array<number>}\n   */\n  _physicalSizes: null,\n  /**\n   * A cached value for the first visible index.\n   * See `firstVisibleIndex`\n   * @type {?number}\n   */\n  _firstVisibleIndexVal: null,\n  /**\n   * A cached value for the last visible index.\n   * See `lastVisibleIndex`\n   * @type {?number}\n   */\n  _lastVisibleIndexVal: null,\n  /**\n   * The max number of pages to render. One page is equivalent to the height of\n   * the list.\n   */\n  _maxPages: 2,\n  /**\n   * The cost of stamping a template in ms.\n   */\n  _templateCost: 0,\n  /**\n   * The bottom of the physical content.\n   */\n  get _physicalBottom() {\n    return this._physicalTop + this._physicalSize;\n  },\n  /**\n   * The bottom of the scroll.\n   */\n  get _scrollBottom() {\n    return this._scrollPosition + this._viewportHeight;\n  },\n  /**\n   * The n-th item rendered in the last physical item.\n   */\n  get _virtualEnd() {\n    return this._virtualStart + this._physicalCount - 1;\n  },\n  /**\n   * The height of the physical content that isn't on the screen.\n   */\n  get _hiddenContentSize() {\n    return this._physicalSize - this._viewportHeight;\n  },\n  /**\n   * The maximum scroll top value.\n   */\n  get _maxScrollTop() {\n    return this._estScrollHeight - this._viewportHeight + this._scrollOffset;\n  },\n  /**\n   * The largest n-th value for an item such that it can be rendered in\n   * `_physicalStart`.\n   */\n  get _maxVirtualStart() {\n    const virtualCount = this._virtualCount;\n    return Math.max(0, virtualCount - this._physicalCount);\n  },\n  get _virtualStart() {\n    return this._virtualStartVal || 0;\n  },\n  set _virtualStart(val) {\n    val = this._clamp(val, 0, this._maxVirtualStart);\n    this._virtualStartVal = val;\n  },\n  get _physicalStart() {\n    return this._physicalStartVal || 0;\n  },\n  /**\n   * The k-th tile that is at the top of the scrolling list.\n   */\n  set _physicalStart(val) {\n    val %= this._physicalCount;\n    if (val < 0) {\n      val = this._physicalCount + val;\n    }\n    this._physicalStartVal = val;\n  },\n  /**\n   * The k-th tile that is at the bottom of the scrolling list.\n   */\n  get _physicalEnd() {\n    return (this._physicalStart + this._physicalCount - 1) % this._physicalCount;\n  },\n  get _physicalCount() {\n    return this._physicalCountVal || 0;\n  },\n  set _physicalCount(val) {\n    this._physicalCountVal = val;\n  },\n  /**\n   * An optimal physical size such that we will have enough physical items\n   * to fill up the viewport and recycle when the user scrolls.\n   *\n   * This default value assumes that we will at least have the equivalent\n   * to a viewport of physical items above and below the user's viewport.\n   */\n  get _optPhysicalSize() {\n    return this._viewportHeight === 0 ? Infinity : this._viewportHeight * this._maxPages;\n  },\n  /**\n   * True if the current list is visible.\n   */\n  get _isVisible() {\n    return Boolean(this.offsetWidth || this.offsetHeight);\n  },\n  /**\n   * Gets the index of the first visible item in the viewport.\n   *\n   * @type {number}\n   */\n  get firstVisibleIndex() {\n    let idx = this._firstVisibleIndexVal;\n    if (idx == null) {\n      let physicalOffset = this._physicalTop + this._scrollOffset;\n      idx = this._iterateItems((pidx, vidx) => {\n        physicalOffset += this._getPhysicalSizeIncrement(pidx);\n        if (physicalOffset > this._scrollPosition) {\n          return vidx;\n        }\n      }) || 0;\n      this._firstVisibleIndexVal = idx;\n    }\n    return idx;\n  },\n  /**\n   * Gets the index of the last visible item in the viewport.\n   *\n   * @type {number}\n   */\n  get lastVisibleIndex() {\n    let idx = this._lastVisibleIndexVal;\n    if (idx == null) {\n      let physicalOffset = this._physicalTop + this._scrollOffset;\n      this._iterateItems((pidx, vidx) => {\n        if (physicalOffset < this._scrollBottom) {\n          idx = vidx;\n        }\n        physicalOffset += this._getPhysicalSizeIncrement(pidx);\n      });\n      this._lastVisibleIndexVal = idx;\n    }\n    return idx;\n  },\n  get _scrollOffset() {\n    return this._scrollerPaddingTop + this.scrollOffset;\n  },\n  /**\n   * Recycles the physical items when needed.\n   */\n  _scrollHandler() {\n    const scrollTop = Math.max(0, Math.min(this._maxScrollTop, this._scrollTop));\n    let delta = scrollTop - this._scrollPosition;\n    const isScrollingDown = delta >= 0;\n    // Track the current scroll position.\n    this._scrollPosition = scrollTop;\n    // Clear indexes for first and last visible indexes.\n    this._firstVisibleIndexVal = null;\n    this._lastVisibleIndexVal = null;\n    // Random access.\n    if (Math.abs(delta) > this._physicalSize && this._physicalSize > 0) {\n      delta -= this._scrollOffset;\n      const idxAdjustment = Math.round(delta / this._physicalAverage);\n      this._virtualStart += idxAdjustment;\n      this._physicalStart += idxAdjustment;\n      // Estimate new physical offset based on the virtual start index.\n      // adjusts the physical start position to stay in sync with the clamped\n      // virtual start index. It's critical not to let this value be\n      // more than the scroll position however, since that would result in\n      // the physical items not covering the viewport, and leading to\n      // _increasePoolIfNeeded to run away creating items to try to fill it.\n      this._physicalTop = Math.min(Math.floor(this._virtualStart) * this._physicalAverage, this._scrollPosition);\n      this._update();\n    } else if (this._physicalCount > 0) {\n      const reusables = this._getReusables(isScrollingDown);\n      if (isScrollingDown) {\n        this._physicalTop = reusables.physicalTop;\n        this._virtualStart += reusables.indexes.length;\n        this._physicalStart += reusables.indexes.length;\n      } else {\n        this._virtualStart -= reusables.indexes.length;\n        this._physicalStart -= reusables.indexes.length;\n      }\n      this._update(reusables.indexes, isScrollingDown ? null : reusables.indexes);\n      this._debounce('_increasePoolIfNeeded', this._increasePoolIfNeeded.bind(this, 0), microTask);\n    }\n  },\n  /**\n   * Returns an object that contains the indexes of the physical items\n   * that might be reused and the physicalTop.\n   *\n   * @param {boolean} fromTop If the potential reusable items are above the scrolling region.\n   */\n  _getReusables(fromTop) {\n    let ith, offsetContent, physicalItemHeight;\n    const idxs = [];\n    const protectedOffsetContent = this._hiddenContentSize * this._ratio;\n    const virtualStart = this._virtualStart;\n    const virtualEnd = this._virtualEnd;\n    const physicalCount = this._physicalCount;\n    let top = this._physicalTop + this._scrollOffset;\n    const bottom = this._physicalBottom + this._scrollOffset;\n    // This may be called outside of a scrollHandler, so use last cached position\n    const scrollTop = this._scrollPosition;\n    const scrollBottom = this._scrollBottom;\n    if (fromTop) {\n      ith = this._physicalStart;\n      offsetContent = scrollTop - top;\n    } else {\n      ith = this._physicalEnd;\n      offsetContent = bottom - scrollBottom;\n    }\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      physicalItemHeight = this._getPhysicalSizeIncrement(ith);\n      offsetContent -= physicalItemHeight;\n      if (idxs.length >= physicalCount || offsetContent <= protectedOffsetContent) {\n        break;\n      }\n      if (fromTop) {\n        // Check that index is within the valid range.\n        if (virtualEnd + idxs.length + 1 >= this._virtualCount) {\n          break;\n        }\n        // Check that the index is not visible.\n        if (top + physicalItemHeight >= scrollTop - this._scrollOffset) {\n          break;\n        }\n        idxs.push(ith);\n        top += physicalItemHeight;\n        ith = (ith + 1) % physicalCount;\n      } else {\n        // Check that index is within the valid range.\n        if (virtualStart - idxs.length <= 0) {\n          break;\n        }\n        // Check that the index is not visible.\n        if (top + this._physicalSize - physicalItemHeight <= scrollBottom) {\n          break;\n        }\n        idxs.push(ith);\n        top -= physicalItemHeight;\n        ith = ith === 0 ? physicalCount - 1 : ith - 1;\n      }\n    }\n    return {\n      indexes: idxs,\n      physicalTop: top - this._scrollOffset\n    };\n  },\n  /**\n   * Update the list of items, starting from the `_virtualStart` item.\n   * @param {!Array<number>=} itemSet\n   * @param {!Array<number>=} movingUp\n   */\n  _update(itemSet, movingUp) {\n    if (itemSet && itemSet.length === 0 || this._physicalCount === 0) {\n      return;\n    }\n    this._assignModels(itemSet);\n    this._updateMetrics(itemSet);\n    // Adjust offset after measuring.\n    if (movingUp) {\n      while (movingUp.length) {\n        const idx = movingUp.pop();\n        this._physicalTop -= this._getPhysicalSizeIncrement(idx);\n      }\n    }\n    this._positionItems();\n    this._updateScrollerSize();\n  },\n  _isClientFull() {\n    return this._scrollBottom !== 0 && this._physicalBottom - 1 >= this._scrollBottom && this._physicalTop <= this._scrollPosition;\n  },\n  /**\n   * Increases the pool size.\n   */\n  _increasePoolIfNeeded(count) {\n    const nextPhysicalCount = this._clamp(this._physicalCount + count, DEFAULT_PHYSICAL_COUNT, this._virtualCount - this._virtualStart);\n    const delta = nextPhysicalCount - this._physicalCount;\n    let nextIncrease = Math.round(this._physicalCount * 0.5);\n    if (delta < 0) {\n      return;\n    }\n    if (delta > 0) {\n      const ts = window.performance.now();\n      // Concat arrays in place.\n      [].push.apply(this._physicalItems, this._createPool(delta));\n      // Push 0s into physicalSizes. Can't use Array.fill because IE11 doesn't\n      // support it.\n      for (let i = 0; i < delta; i++) {\n        this._physicalSizes.push(0);\n      }\n      this._physicalCount += delta;\n      // Update the physical start if it needs to preserve the model of the\n      // focused item. In this situation, the focused item is currently rendered\n      // and its model would have changed after increasing the pool if the\n      // physical start remained unchanged.\n      if (this._physicalStart > this._physicalEnd && this._isIndexRendered(this._focusedVirtualIndex) && this._getPhysicalIndex(this._focusedVirtualIndex) < this._physicalEnd) {\n        this._physicalStart += delta;\n      }\n      this._update();\n      this._templateCost = (window.performance.now() - ts) / delta;\n      nextIncrease = Math.round(this._physicalCount * 0.5);\n    }\n    if (this._virtualEnd >= this._virtualCount - 1 || nextIncrease === 0) {\n      // Do nothing.\n    } else if (!this._isClientFull()) {\n      this._debounce('_increasePoolIfNeeded', this._increasePoolIfNeeded.bind(this, nextIncrease), microTask);\n    } else if (this._physicalSize < this._optPhysicalSize) {\n      // Yield and increase the pool during idle time until the physical size is\n      // optimal.\n      this._debounce('_increasePoolIfNeeded', this._increasePoolIfNeeded.bind(this, this._clamp(Math.round(50 / this._templateCost), 1, nextIncrease)), idlePeriod);\n    }\n  },\n  /**\n   * Renders the a new list.\n   */\n  _render() {\n    if (!this.isAttached || !this._isVisible) {\n      return;\n    }\n    if (this._physicalCount !== 0) {\n      const reusables = this._getReusables(true);\n      this._physicalTop = reusables.physicalTop;\n      this._virtualStart += reusables.indexes.length;\n      this._physicalStart += reusables.indexes.length;\n      this._update(reusables.indexes);\n      this._update();\n      this._increasePoolIfNeeded(0);\n    } else if (this._virtualCount > 0) {\n      // Initial render\n      this.updateViewportBoundaries();\n      this._increasePoolIfNeeded(DEFAULT_PHYSICAL_COUNT);\n    }\n  },\n  /**\n   * Called when the items have changed. That is, reassignments\n   * to `items`, splices or updates to a single item.\n   */\n  _itemsChanged(change) {\n    if (change.path === 'items') {\n      this._virtualStart = 0;\n      this._physicalTop = 0;\n      this._virtualCount = this.items ? this.items.length : 0;\n      this._physicalIndexForKey = {};\n      this._firstVisibleIndexVal = null;\n      this._lastVisibleIndexVal = null;\n      if (!this._physicalItems) {\n        this._physicalItems = [];\n      }\n      if (!this._physicalSizes) {\n        this._physicalSizes = [];\n      }\n      this._physicalStart = 0;\n      if (this._scrollTop > this._scrollOffset) {\n        this._resetScrollPosition(0);\n      }\n      this._debounce('_render', this._render, animationFrame);\n    }\n  },\n  /**\n   * Executes a provided function per every physical index in `itemSet`\n   * `itemSet` default value is equivalent to the entire set of physical\n   * indexes.\n   *\n   * @param {!function(number, number)} fn\n   * @param {!Array<number>=} itemSet\n   */\n  _iterateItems(fn, itemSet) {\n    let pidx, vidx, rtn, i;\n    if (arguments.length === 2 && itemSet) {\n      for (i = 0; i < itemSet.length; i++) {\n        pidx = itemSet[i];\n        vidx = this._computeVidx(pidx);\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n    } else {\n      pidx = this._physicalStart;\n      vidx = this._virtualStart;\n      for (; pidx < this._physicalCount; pidx++, vidx++) {\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n      for (pidx = 0; pidx < this._physicalStart; pidx++, vidx++) {\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n    }\n  },\n  /**\n   * Returns the virtual index for a given physical index\n   *\n   * @param {number} pidx Physical index\n   * @return {number}\n   */\n  _computeVidx(pidx) {\n    if (pidx >= this._physicalStart) {\n      return this._virtualStart + (pidx - this._physicalStart);\n    }\n    return this._virtualStart + (this._physicalCount - this._physicalStart) + pidx;\n  },\n  /**\n   * Updates the position of the physical items.\n   */\n  _positionItems() {\n    this._adjustScrollPosition();\n    let y = this._physicalTop;\n    this._iterateItems(pidx => {\n      this.translate3d(0, `${y}px`, 0, this._physicalItems[pidx]);\n      y += this._physicalSizes[pidx];\n    });\n  },\n  _getPhysicalSizeIncrement(pidx) {\n    return this._physicalSizes[pidx];\n  },\n  /**\n   * Adjusts the scroll position when it was overestimated.\n   */\n  _adjustScrollPosition() {\n    const deltaHeight = this._virtualStart === 0 ? this._physicalTop : Math.min(this._scrollPosition + this._physicalTop, 0);\n    // Note: the delta can be positive or negative.\n    if (deltaHeight !== 0) {\n      this._physicalTop -= deltaHeight;\n      // This may be called outside of a scrollHandler, so use last cached position\n      const scrollTop = this._scrollPosition;\n      // Juking scroll position during interial scrolling on iOS is no bueno\n      if (!IOS_TOUCH_SCROLLING && scrollTop > 0) {\n        this._resetScrollPosition(scrollTop - deltaHeight);\n      }\n    }\n  },\n  /**\n   * Sets the position of the scroll.\n   */\n  _resetScrollPosition(pos) {\n    if (this.scrollTarget && pos >= 0) {\n      this._scrollTop = pos;\n      this._scrollPosition = this._scrollTop;\n    }\n  },\n  /**\n   * Sets the scroll height, that's the height of the content,\n   *\n   * @param {boolean=} forceUpdate If true, updates the height no matter what.\n   */\n  _updateScrollerSize(forceUpdate) {\n    const estScrollHeight = this._physicalBottom + Math.max(this._virtualCount - this._physicalCount - this._virtualStart, 0) * this._physicalAverage;\n    this._estScrollHeight = estScrollHeight;\n\n    // Amortize height adjustment, so it won't trigger large repaints too often.\n    if (forceUpdate || this._scrollHeight === 0 || this._scrollPosition >= estScrollHeight - this._physicalSize || Math.abs(estScrollHeight - this._scrollHeight) >= this._viewportHeight) {\n      this.$.items.style.height = `${estScrollHeight}px`;\n      this._scrollHeight = estScrollHeight;\n    }\n  },\n  /**\n   * Scroll to a specific index in the virtual list regardless\n   * of the physical items in the DOM tree.\n   *\n   * @method scrollToIndex\n   * @param {number} idx The index of the item\n   */\n  scrollToIndex(idx) {\n    if (typeof idx !== 'number' || idx < 0 || idx > this.items.length - 1) {\n      return;\n    }\n    flush();\n    // Items should have been rendered prior scrolling to an index.\n    if (this._physicalCount === 0) {\n      return;\n    }\n    idx = this._clamp(idx, 0, this._virtualCount - 1);\n    // Update the virtual start only when needed.\n    if (!this._isIndexRendered(idx) || idx >= this._maxVirtualStart) {\n      this._virtualStart = idx - 1;\n    }\n    this._assignModels();\n    this._updateMetrics();\n    // Estimate new physical offset.\n    this._physicalTop = this._virtualStart * this._physicalAverage;\n    let currentTopItem = this._physicalStart;\n    let currentVirtualItem = this._virtualStart;\n    let targetOffsetTop = 0;\n    const hiddenContentSize = this._hiddenContentSize;\n    // Scroll to the item as much as we can.\n    while (currentVirtualItem < idx && targetOffsetTop <= hiddenContentSize) {\n      targetOffsetTop += this._getPhysicalSizeIncrement(currentTopItem);\n      currentTopItem = (currentTopItem + 1) % this._physicalCount;\n      currentVirtualItem += 1;\n    }\n    this._updateScrollerSize(true);\n    this._positionItems();\n    this._resetScrollPosition(this._physicalTop + this._scrollOffset + targetOffsetTop);\n    this._increasePoolIfNeeded(0);\n    // Clear cached visible index.\n    this._firstVisibleIndexVal = null;\n    this._lastVisibleIndexVal = null;\n  },\n  /**\n   * Reset the physical average and the average count.\n   */\n  _resetAverage() {\n    this._physicalAverage = 0;\n    this._physicalAverageCount = 0;\n  },\n  /**\n   * A handler for the `iron-resize` event triggered by `IronResizableBehavior`\n   * when the element is resized.\n   */\n  _resizeHandler() {\n    this._debounce('_render', () => {\n      // Clear cached visible index.\n      this._firstVisibleIndexVal = null;\n      this._lastVisibleIndexVal = null;\n      if (this._isVisible) {\n        this.updateViewportBoundaries();\n        // Reinstall the scroll event listener.\n        this.toggleScrollListener(true);\n        this._resetAverage();\n        this._render();\n      } else {\n        // Uninstall the scroll event listener.\n        this.toggleScrollListener(false);\n      }\n    }, animationFrame);\n  },\n  _isIndexRendered(idx) {\n    return idx >= this._virtualStart && idx <= this._virtualEnd;\n  },\n  _getPhysicalIndex(vidx) {\n    return (this._physicalStart + (vidx - this._virtualStart)) % this._physicalCount;\n  },\n  _clamp(v, min, max) {\n    return Math.min(max, Math.max(min, v));\n  },\n  _debounce(name, cb, asyncModule) {\n    if (!this._debouncers) {\n      this._debouncers = {};\n    }\n    this._debouncers[name] = Debouncer.debounce(this._debouncers[name], asyncModule, cb.bind(this));\n    enqueueDebouncer(this._debouncers[name]);\n  }\n};","map":{"version":3,"names":["animationFrame","idlePeriod","microTask","Debouncer","enqueueDebouncer","flush","IOS","navigator","userAgent","match","IOS_TOUCH_SCROLLING","DEFAULT_PHYSICAL_COUNT","ironList","_ratio","_scrollerPaddingTop","_scrollPosition","_physicalSize","_physicalAverage","_physicalAverageCount","_physicalTop","_virtualCount","_estScrollHeight","_scrollHeight","_viewportHeight","_viewportWidth","_physicalItems","_physicalSizes","_firstVisibleIndexVal","_lastVisibleIndexVal","_maxPages","_templateCost","_physicalBottom","_scrollBottom","_virtualEnd","_virtualStart","_physicalCount","_hiddenContentSize","_maxScrollTop","_scrollOffset","_maxVirtualStart","virtualCount","Math","max","_virtualStartVal","val","_clamp","_physicalStart","_physicalStartVal","_physicalEnd","_physicalCountVal","_optPhysicalSize","Infinity","_isVisible","Boolean","offsetWidth","offsetHeight","firstVisibleIndex","idx","physicalOffset","_iterateItems","pidx","vidx","_getPhysicalSizeIncrement","lastVisibleIndex","scrollOffset","_scrollHandler","scrollTop","min","_scrollTop","delta","isScrollingDown","abs","idxAdjustment","round","floor","_update","reusables","_getReusables","physicalTop","indexes","length","_debounce","_increasePoolIfNeeded","bind","fromTop","ith","offsetContent","physicalItemHeight","idxs","protectedOffsetContent","virtualStart","virtualEnd","physicalCount","top","bottom","scrollBottom","push","itemSet","movingUp","_assignModels","_updateMetrics","pop","_positionItems","_updateScrollerSize","_isClientFull","count","nextPhysicalCount","nextIncrease","ts","window","performance","now","apply","_createPool","i","_isIndexRendered","_focusedVirtualIndex","_getPhysicalIndex","_render","isAttached","updateViewportBoundaries","_itemsChanged","change","path","items","_physicalIndexForKey","_resetScrollPosition","fn","rtn","arguments","_computeVidx","call","_adjustScrollPosition","y","translate3d","deltaHeight","pos","scrollTarget","forceUpdate","estScrollHeight","$","style","height","scrollToIndex","currentTopItem","currentVirtualItem","targetOffsetTop","hiddenContentSize","_resetAverage","_resizeHandler","toggleScrollListener","v","name","cb","asyncModule","_debouncers","debounce"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@vaadin/component-base/src/iron-list-core.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\nimport { animationFrame, idlePeriod, microTask } from './async.js';\nimport { Debouncer, enqueueDebouncer, flush } from './debounce.js';\n\nconst IOS = navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\\d+)/u);\nconst IOS_TOUCH_SCROLLING = IOS && IOS[1] >= 8;\nconst DEFAULT_PHYSICAL_COUNT = 3;\n\n/**\n * DO NOT EDIT THIS FILE!\n *\n * This file includes the iron-list scrolling engine copied from\n * https://github.com/PolymerElements/iron-list/blob/master/iron-list.js\n *\n * If something in the scrolling engine needs to be changed\n * for the virtualizer's purposes, override a function\n * in virtualizer-iron-list-adapter.js instead of changing it here.\n * If a function on this file is no longer needed, the code can be safely deleted.\n *\n * This will allow us to keep the iron-list code here as close to\n * the original as possible.\n */\nexport const ironList = {\n  /**\n   * The ratio of hidden tiles that should remain in the scroll direction.\n   * Recommended value ~0.5, so it will distribute tiles evenly in both\n   * directions.\n   */\n  _ratio: 0.5,\n\n  /**\n   * The padding-top value for the list.\n   */\n  _scrollerPaddingTop: 0,\n\n  /**\n   * This value is a cached value of `scrollTop` from the last `scroll` event.\n   */\n  _scrollPosition: 0,\n\n  /**\n   * The sum of the heights of all the tiles in the DOM.\n   */\n  _physicalSize: 0,\n\n  /**\n   * The average `offsetHeight` of the tiles observed till now.\n   */\n  _physicalAverage: 0,\n\n  /**\n   * The number of tiles which `offsetHeight` > 0 observed until now.\n   */\n  _physicalAverageCount: 0,\n\n  /**\n   * The Y position of the item rendered in the `_physicalStart`\n   * tile relative to the scrolling list.\n   */\n  _physicalTop: 0,\n\n  /**\n   * The number of items in the list.\n   */\n  _virtualCount: 0,\n\n  /**\n   * The estimated scroll height based on `_physicalAverage`\n   */\n  _estScrollHeight: 0,\n\n  /**\n   * The scroll height of the dom node\n   */\n  _scrollHeight: 0,\n\n  /**\n   * The height of the list. This is referred as the viewport in the context of\n   * list.\n   */\n  _viewportHeight: 0,\n\n  /**\n   * The width of the list. This is referred as the viewport in the context of\n   * list.\n   */\n  _viewportWidth: 0,\n\n  /**\n   * An array of DOM nodes that are currently in the tree\n   * @type {?Array<!HTMLElement>}\n   */\n  _physicalItems: null,\n\n  /**\n   * An array of heights for each item in `_physicalItems`\n   * @type {?Array<number>}\n   */\n  _physicalSizes: null,\n\n  /**\n   * A cached value for the first visible index.\n   * See `firstVisibleIndex`\n   * @type {?number}\n   */\n  _firstVisibleIndexVal: null,\n\n  /**\n   * A cached value for the last visible index.\n   * See `lastVisibleIndex`\n   * @type {?number}\n   */\n  _lastVisibleIndexVal: null,\n\n  /**\n   * The max number of pages to render. One page is equivalent to the height of\n   * the list.\n   */\n  _maxPages: 2,\n\n  /**\n   * The cost of stamping a template in ms.\n   */\n  _templateCost: 0,\n\n  /**\n   * The bottom of the physical content.\n   */\n  get _physicalBottom() {\n    return this._physicalTop + this._physicalSize;\n  },\n\n  /**\n   * The bottom of the scroll.\n   */\n  get _scrollBottom() {\n    return this._scrollPosition + this._viewportHeight;\n  },\n\n  /**\n   * The n-th item rendered in the last physical item.\n   */\n  get _virtualEnd() {\n    return this._virtualStart + this._physicalCount - 1;\n  },\n\n  /**\n   * The height of the physical content that isn't on the screen.\n   */\n  get _hiddenContentSize() {\n    return this._physicalSize - this._viewportHeight;\n  },\n\n  /**\n   * The maximum scroll top value.\n   */\n  get _maxScrollTop() {\n    return this._estScrollHeight - this._viewportHeight + this._scrollOffset;\n  },\n\n  /**\n   * The largest n-th value for an item such that it can be rendered in\n   * `_physicalStart`.\n   */\n  get _maxVirtualStart() {\n    const virtualCount = this._virtualCount;\n    return Math.max(0, virtualCount - this._physicalCount);\n  },\n\n  get _virtualStart() {\n    return this._virtualStartVal || 0;\n  },\n\n  set _virtualStart(val) {\n    val = this._clamp(val, 0, this._maxVirtualStart);\n    this._virtualStartVal = val;\n  },\n\n  get _physicalStart() {\n    return this._physicalStartVal || 0;\n  },\n\n  /**\n   * The k-th tile that is at the top of the scrolling list.\n   */\n  set _physicalStart(val) {\n    val %= this._physicalCount;\n    if (val < 0) {\n      val = this._physicalCount + val;\n    }\n    this._physicalStartVal = val;\n  },\n\n  /**\n   * The k-th tile that is at the bottom of the scrolling list.\n   */\n  get _physicalEnd() {\n    return (this._physicalStart + this._physicalCount - 1) % this._physicalCount;\n  },\n\n  get _physicalCount() {\n    return this._physicalCountVal || 0;\n  },\n\n  set _physicalCount(val) {\n    this._physicalCountVal = val;\n  },\n\n  /**\n   * An optimal physical size such that we will have enough physical items\n   * to fill up the viewport and recycle when the user scrolls.\n   *\n   * This default value assumes that we will at least have the equivalent\n   * to a viewport of physical items above and below the user's viewport.\n   */\n  get _optPhysicalSize() {\n    return this._viewportHeight === 0 ? Infinity : this._viewportHeight * this._maxPages;\n  },\n\n  /**\n   * True if the current list is visible.\n   */\n  get _isVisible() {\n    return Boolean(this.offsetWidth || this.offsetHeight);\n  },\n\n  /**\n   * Gets the index of the first visible item in the viewport.\n   *\n   * @type {number}\n   */\n  get firstVisibleIndex() {\n    let idx = this._firstVisibleIndexVal;\n    if (idx == null) {\n      let physicalOffset = this._physicalTop + this._scrollOffset;\n\n      idx =\n        this._iterateItems((pidx, vidx) => {\n          physicalOffset += this._getPhysicalSizeIncrement(pidx);\n\n          if (physicalOffset > this._scrollPosition) {\n            return vidx;\n          }\n        }) || 0;\n      this._firstVisibleIndexVal = idx;\n    }\n    return idx;\n  },\n\n  /**\n   * Gets the index of the last visible item in the viewport.\n   *\n   * @type {number}\n   */\n  get lastVisibleIndex() {\n    let idx = this._lastVisibleIndexVal;\n    if (idx == null) {\n      let physicalOffset = this._physicalTop + this._scrollOffset;\n      this._iterateItems((pidx, vidx) => {\n        if (physicalOffset < this._scrollBottom) {\n          idx = vidx;\n        }\n        physicalOffset += this._getPhysicalSizeIncrement(pidx);\n      });\n\n      this._lastVisibleIndexVal = idx;\n    }\n    return idx;\n  },\n\n  get _scrollOffset() {\n    return this._scrollerPaddingTop + this.scrollOffset;\n  },\n\n  /**\n   * Recycles the physical items when needed.\n   */\n  _scrollHandler() {\n    const scrollTop = Math.max(0, Math.min(this._maxScrollTop, this._scrollTop));\n    let delta = scrollTop - this._scrollPosition;\n    const isScrollingDown = delta >= 0;\n    // Track the current scroll position.\n    this._scrollPosition = scrollTop;\n    // Clear indexes for first and last visible indexes.\n    this._firstVisibleIndexVal = null;\n    this._lastVisibleIndexVal = null;\n    // Random access.\n    if (Math.abs(delta) > this._physicalSize && this._physicalSize > 0) {\n      delta -= this._scrollOffset;\n      const idxAdjustment = Math.round(delta / this._physicalAverage);\n      this._virtualStart += idxAdjustment;\n      this._physicalStart += idxAdjustment;\n      // Estimate new physical offset based on the virtual start index.\n      // adjusts the physical start position to stay in sync with the clamped\n      // virtual start index. It's critical not to let this value be\n      // more than the scroll position however, since that would result in\n      // the physical items not covering the viewport, and leading to\n      // _increasePoolIfNeeded to run away creating items to try to fill it.\n      this._physicalTop = Math.min(Math.floor(this._virtualStart) * this._physicalAverage, this._scrollPosition);\n      this._update();\n    } else if (this._physicalCount > 0) {\n      const reusables = this._getReusables(isScrollingDown);\n      if (isScrollingDown) {\n        this._physicalTop = reusables.physicalTop;\n        this._virtualStart += reusables.indexes.length;\n        this._physicalStart += reusables.indexes.length;\n      } else {\n        this._virtualStart -= reusables.indexes.length;\n        this._physicalStart -= reusables.indexes.length;\n      }\n      this._update(reusables.indexes, isScrollingDown ? null : reusables.indexes);\n      this._debounce('_increasePoolIfNeeded', this._increasePoolIfNeeded.bind(this, 0), microTask);\n    }\n  },\n\n  /**\n   * Returns an object that contains the indexes of the physical items\n   * that might be reused and the physicalTop.\n   *\n   * @param {boolean} fromTop If the potential reusable items are above the scrolling region.\n   */\n  _getReusables(fromTop) {\n    let ith, offsetContent, physicalItemHeight;\n    const idxs = [];\n    const protectedOffsetContent = this._hiddenContentSize * this._ratio;\n    const virtualStart = this._virtualStart;\n    const virtualEnd = this._virtualEnd;\n    const physicalCount = this._physicalCount;\n    let top = this._physicalTop + this._scrollOffset;\n    const bottom = this._physicalBottom + this._scrollOffset;\n    // This may be called outside of a scrollHandler, so use last cached position\n    const scrollTop = this._scrollPosition;\n    const scrollBottom = this._scrollBottom;\n\n    if (fromTop) {\n      ith = this._physicalStart;\n      offsetContent = scrollTop - top;\n    } else {\n      ith = this._physicalEnd;\n      offsetContent = bottom - scrollBottom;\n    }\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      physicalItemHeight = this._getPhysicalSizeIncrement(ith);\n      offsetContent -= physicalItemHeight;\n      if (idxs.length >= physicalCount || offsetContent <= protectedOffsetContent) {\n        break;\n      }\n      if (fromTop) {\n        // Check that index is within the valid range.\n        if (virtualEnd + idxs.length + 1 >= this._virtualCount) {\n          break;\n        }\n        // Check that the index is not visible.\n        if (top + physicalItemHeight >= scrollTop - this._scrollOffset) {\n          break;\n        }\n        idxs.push(ith);\n        top += physicalItemHeight;\n        ith = (ith + 1) % physicalCount;\n      } else {\n        // Check that index is within the valid range.\n        if (virtualStart - idxs.length <= 0) {\n          break;\n        }\n        // Check that the index is not visible.\n        if (top + this._physicalSize - physicalItemHeight <= scrollBottom) {\n          break;\n        }\n        idxs.push(ith);\n        top -= physicalItemHeight;\n        ith = ith === 0 ? physicalCount - 1 : ith - 1;\n      }\n    }\n    return { indexes: idxs, physicalTop: top - this._scrollOffset };\n  },\n\n  /**\n   * Update the list of items, starting from the `_virtualStart` item.\n   * @param {!Array<number>=} itemSet\n   * @param {!Array<number>=} movingUp\n   */\n  _update(itemSet, movingUp) {\n    if ((itemSet && itemSet.length === 0) || this._physicalCount === 0) {\n      return;\n    }\n    this._assignModels(itemSet);\n    this._updateMetrics(itemSet);\n    // Adjust offset after measuring.\n    if (movingUp) {\n      while (movingUp.length) {\n        const idx = movingUp.pop();\n        this._physicalTop -= this._getPhysicalSizeIncrement(idx);\n      }\n    }\n    this._positionItems();\n    this._updateScrollerSize();\n  },\n\n  _isClientFull() {\n    return (\n      this._scrollBottom !== 0 &&\n      this._physicalBottom - 1 >= this._scrollBottom &&\n      this._physicalTop <= this._scrollPosition\n    );\n  },\n\n  /**\n   * Increases the pool size.\n   */\n  _increasePoolIfNeeded(count) {\n    const nextPhysicalCount = this._clamp(\n      this._physicalCount + count,\n      DEFAULT_PHYSICAL_COUNT,\n      this._virtualCount - this._virtualStart,\n    );\n    const delta = nextPhysicalCount - this._physicalCount;\n    let nextIncrease = Math.round(this._physicalCount * 0.5);\n\n    if (delta < 0) {\n      return;\n    }\n    if (delta > 0) {\n      const ts = window.performance.now();\n      // Concat arrays in place.\n      [].push.apply(this._physicalItems, this._createPool(delta));\n      // Push 0s into physicalSizes. Can't use Array.fill because IE11 doesn't\n      // support it.\n      for (let i = 0; i < delta; i++) {\n        this._physicalSizes.push(0);\n      }\n      this._physicalCount += delta;\n      // Update the physical start if it needs to preserve the model of the\n      // focused item. In this situation, the focused item is currently rendered\n      // and its model would have changed after increasing the pool if the\n      // physical start remained unchanged.\n      if (\n        this._physicalStart > this._physicalEnd &&\n        this._isIndexRendered(this._focusedVirtualIndex) &&\n        this._getPhysicalIndex(this._focusedVirtualIndex) < this._physicalEnd\n      ) {\n        this._physicalStart += delta;\n      }\n      this._update();\n      this._templateCost = (window.performance.now() - ts) / delta;\n      nextIncrease = Math.round(this._physicalCount * 0.5);\n    }\n    if (this._virtualEnd >= this._virtualCount - 1 || nextIncrease === 0) {\n      // Do nothing.\n    } else if (!this._isClientFull()) {\n      this._debounce('_increasePoolIfNeeded', this._increasePoolIfNeeded.bind(this, nextIncrease), microTask);\n    } else if (this._physicalSize < this._optPhysicalSize) {\n      // Yield and increase the pool during idle time until the physical size is\n      // optimal.\n      this._debounce(\n        '_increasePoolIfNeeded',\n        this._increasePoolIfNeeded.bind(this, this._clamp(Math.round(50 / this._templateCost), 1, nextIncrease)),\n        idlePeriod,\n      );\n    }\n  },\n\n  /**\n   * Renders the a new list.\n   */\n  _render() {\n    if (!this.isAttached || !this._isVisible) {\n      return;\n    }\n    if (this._physicalCount !== 0) {\n      const reusables = this._getReusables(true);\n      this._physicalTop = reusables.physicalTop;\n      this._virtualStart += reusables.indexes.length;\n      this._physicalStart += reusables.indexes.length;\n      this._update(reusables.indexes);\n      this._update();\n      this._increasePoolIfNeeded(0);\n    } else if (this._virtualCount > 0) {\n      // Initial render\n      this.updateViewportBoundaries();\n      this._increasePoolIfNeeded(DEFAULT_PHYSICAL_COUNT);\n    }\n  },\n\n  /**\n   * Called when the items have changed. That is, reassignments\n   * to `items`, splices or updates to a single item.\n   */\n  _itemsChanged(change) {\n    if (change.path === 'items') {\n      this._virtualStart = 0;\n      this._physicalTop = 0;\n      this._virtualCount = this.items ? this.items.length : 0;\n      this._physicalIndexForKey = {};\n      this._firstVisibleIndexVal = null;\n      this._lastVisibleIndexVal = null;\n      if (!this._physicalItems) {\n        this._physicalItems = [];\n      }\n      if (!this._physicalSizes) {\n        this._physicalSizes = [];\n      }\n      this._physicalStart = 0;\n      if (this._scrollTop > this._scrollOffset) {\n        this._resetScrollPosition(0);\n      }\n      this._debounce('_render', this._render, animationFrame);\n    }\n  },\n\n  /**\n   * Executes a provided function per every physical index in `itemSet`\n   * `itemSet` default value is equivalent to the entire set of physical\n   * indexes.\n   *\n   * @param {!function(number, number)} fn\n   * @param {!Array<number>=} itemSet\n   */\n  _iterateItems(fn, itemSet) {\n    let pidx, vidx, rtn, i;\n\n    if (arguments.length === 2 && itemSet) {\n      for (i = 0; i < itemSet.length; i++) {\n        pidx = itemSet[i];\n        vidx = this._computeVidx(pidx);\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n    } else {\n      pidx = this._physicalStart;\n      vidx = this._virtualStart;\n      for (; pidx < this._physicalCount; pidx++, vidx++) {\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n      for (pidx = 0; pidx < this._physicalStart; pidx++, vidx++) {\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n    }\n  },\n\n  /**\n   * Returns the virtual index for a given physical index\n   *\n   * @param {number} pidx Physical index\n   * @return {number}\n   */\n  _computeVidx(pidx) {\n    if (pidx >= this._physicalStart) {\n      return this._virtualStart + (pidx - this._physicalStart);\n    }\n    return this._virtualStart + (this._physicalCount - this._physicalStart) + pidx;\n  },\n\n  /**\n   * Updates the position of the physical items.\n   */\n  _positionItems() {\n    this._adjustScrollPosition();\n\n    let y = this._physicalTop;\n\n    this._iterateItems((pidx) => {\n      this.translate3d(0, `${y}px`, 0, this._physicalItems[pidx]);\n      y += this._physicalSizes[pidx];\n    });\n  },\n\n  _getPhysicalSizeIncrement(pidx) {\n    return this._physicalSizes[pidx];\n  },\n\n  /**\n   * Adjusts the scroll position when it was overestimated.\n   */\n  _adjustScrollPosition() {\n    const deltaHeight =\n      this._virtualStart === 0 ? this._physicalTop : Math.min(this._scrollPosition + this._physicalTop, 0);\n    // Note: the delta can be positive or negative.\n    if (deltaHeight !== 0) {\n      this._physicalTop -= deltaHeight;\n      // This may be called outside of a scrollHandler, so use last cached position\n      const scrollTop = this._scrollPosition;\n      // Juking scroll position during interial scrolling on iOS is no bueno\n      if (!IOS_TOUCH_SCROLLING && scrollTop > 0) {\n        this._resetScrollPosition(scrollTop - deltaHeight);\n      }\n    }\n  },\n\n  /**\n   * Sets the position of the scroll.\n   */\n  _resetScrollPosition(pos) {\n    if (this.scrollTarget && pos >= 0) {\n      this._scrollTop = pos;\n      this._scrollPosition = this._scrollTop;\n    }\n  },\n\n  /**\n   * Sets the scroll height, that's the height of the content,\n   *\n   * @param {boolean=} forceUpdate If true, updates the height no matter what.\n   */\n  _updateScrollerSize(forceUpdate) {\n    const estScrollHeight =\n      this._physicalBottom +\n      Math.max(this._virtualCount - this._physicalCount - this._virtualStart, 0) * this._physicalAverage;\n\n    this._estScrollHeight = estScrollHeight;\n\n    // Amortize height adjustment, so it won't trigger large repaints too often.\n    if (\n      forceUpdate ||\n      this._scrollHeight === 0 ||\n      this._scrollPosition >= estScrollHeight - this._physicalSize ||\n      Math.abs(estScrollHeight - this._scrollHeight) >= this._viewportHeight\n    ) {\n      this.$.items.style.height = `${estScrollHeight}px`;\n      this._scrollHeight = estScrollHeight;\n    }\n  },\n\n  /**\n   * Scroll to a specific index in the virtual list regardless\n   * of the physical items in the DOM tree.\n   *\n   * @method scrollToIndex\n   * @param {number} idx The index of the item\n   */\n  scrollToIndex(idx) {\n    if (typeof idx !== 'number' || idx < 0 || idx > this.items.length - 1) {\n      return;\n    }\n    flush();\n    // Items should have been rendered prior scrolling to an index.\n    if (this._physicalCount === 0) {\n      return;\n    }\n    idx = this._clamp(idx, 0, this._virtualCount - 1);\n    // Update the virtual start only when needed.\n    if (!this._isIndexRendered(idx) || idx >= this._maxVirtualStart) {\n      this._virtualStart = idx - 1;\n    }\n    this._assignModels();\n    this._updateMetrics();\n    // Estimate new physical offset.\n    this._physicalTop = this._virtualStart * this._physicalAverage;\n\n    let currentTopItem = this._physicalStart;\n    let currentVirtualItem = this._virtualStart;\n    let targetOffsetTop = 0;\n    const hiddenContentSize = this._hiddenContentSize;\n    // Scroll to the item as much as we can.\n    while (currentVirtualItem < idx && targetOffsetTop <= hiddenContentSize) {\n      targetOffsetTop += this._getPhysicalSizeIncrement(currentTopItem);\n      currentTopItem = (currentTopItem + 1) % this._physicalCount;\n      currentVirtualItem += 1;\n    }\n    this._updateScrollerSize(true);\n    this._positionItems();\n    this._resetScrollPosition(this._physicalTop + this._scrollOffset + targetOffsetTop);\n    this._increasePoolIfNeeded(0);\n    // Clear cached visible index.\n    this._firstVisibleIndexVal = null;\n    this._lastVisibleIndexVal = null;\n  },\n\n  /**\n   * Reset the physical average and the average count.\n   */\n  _resetAverage() {\n    this._physicalAverage = 0;\n    this._physicalAverageCount = 0;\n  },\n\n  /**\n   * A handler for the `iron-resize` event triggered by `IronResizableBehavior`\n   * when the element is resized.\n   */\n  _resizeHandler() {\n    this._debounce(\n      '_render',\n      () => {\n        // Clear cached visible index.\n        this._firstVisibleIndexVal = null;\n        this._lastVisibleIndexVal = null;\n        if (this._isVisible) {\n          this.updateViewportBoundaries();\n          // Reinstall the scroll event listener.\n          this.toggleScrollListener(true);\n          this._resetAverage();\n          this._render();\n        } else {\n          // Uninstall the scroll event listener.\n          this.toggleScrollListener(false);\n        }\n      },\n      animationFrame,\n    );\n  },\n\n  _isIndexRendered(idx) {\n    return idx >= this._virtualStart && idx <= this._virtualEnd;\n  },\n\n  _getPhysicalIndex(vidx) {\n    return (this._physicalStart + (vidx - this._virtualStart)) % this._physicalCount;\n  },\n\n  _clamp(v, min, max) {\n    return Math.min(max, Math.max(min, v));\n  },\n\n  _debounce(name, cb, asyncModule) {\n    if (!this._debouncers) {\n      this._debouncers = {};\n    }\n    this._debouncers[name] = Debouncer.debounce(this._debouncers[name], asyncModule, cb.bind(this));\n    enqueueDebouncer(this._debouncers[name]);\n  },\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,cAAc,EAAEC,UAAU,EAAEC,SAAS,QAAQ,YAAY;AAClE,SAASC,SAAS,EAAEC,gBAAgB,EAAEC,KAAK,QAAQ,eAAe;AAElE,MAAMC,GAAG,GAAGC,SAAS,CAACC,SAAS,CAACC,KAAK,CAAC,sCAAsC,CAAC;AAC7E,MAAMC,mBAAmB,GAAGJ,GAAG,IAAIA,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC;AAC9C,MAAMK,sBAAsB,GAAG,CAAC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,QAAQ,GAAG;EACtB;AACF;AACA;AACA;AACA;EACEC,MAAM,EAAE,GAAG;EAEX;AACF;AACA;EACEC,mBAAmB,EAAE,CAAC;EAEtB;AACF;AACA;EACEC,eAAe,EAAE,CAAC;EAElB;AACF;AACA;EACEC,aAAa,EAAE,CAAC;EAEhB;AACF;AACA;EACEC,gBAAgB,EAAE,CAAC;EAEnB;AACF;AACA;EACEC,qBAAqB,EAAE,CAAC;EAExB;AACF;AACA;AACA;EACEC,YAAY,EAAE,CAAC;EAEf;AACF;AACA;EACEC,aAAa,EAAE,CAAC;EAEhB;AACF;AACA;EACEC,gBAAgB,EAAE,CAAC;EAEnB;AACF;AACA;EACEC,aAAa,EAAE,CAAC;EAEhB;AACF;AACA;AACA;EACEC,eAAe,EAAE,CAAC;EAElB;AACF;AACA;AACA;EACEC,cAAc,EAAE,CAAC;EAEjB;AACF;AACA;AACA;EACEC,cAAc,EAAE,IAAI;EAEpB;AACF;AACA;AACA;EACEC,cAAc,EAAE,IAAI;EAEpB;AACF;AACA;AACA;AACA;EACEC,qBAAqB,EAAE,IAAI;EAE3B;AACF;AACA;AACA;AACA;EACEC,oBAAoB,EAAE,IAAI;EAE1B;AACF;AACA;AACA;EACEC,SAAS,EAAE,CAAC;EAEZ;AACF;AACA;EACEC,aAAa,EAAE,CAAC;EAEhB;AACF;AACA;EACE,IAAIC,eAAeA,CAAA,EAAG;IACpB,OAAO,IAAI,CAACZ,YAAY,GAAG,IAAI,CAACH,aAAa;EAC/C,CAAC;EAED;AACF;AACA;EACE,IAAIgB,aAAaA,CAAA,EAAG;IAClB,OAAO,IAAI,CAACjB,eAAe,GAAG,IAAI,CAACQ,eAAe;EACpD,CAAC;EAED;AACF;AACA;EACE,IAAIU,WAAWA,CAAA,EAAG;IAChB,OAAO,IAAI,CAACC,aAAa,GAAG,IAAI,CAACC,cAAc,GAAG,CAAC;EACrD,CAAC;EAED;AACF;AACA;EACE,IAAIC,kBAAkBA,CAAA,EAAG;IACvB,OAAO,IAAI,CAACpB,aAAa,GAAG,IAAI,CAACO,eAAe;EAClD,CAAC;EAED;AACF;AACA;EACE,IAAIc,aAAaA,CAAA,EAAG;IAClB,OAAO,IAAI,CAAChB,gBAAgB,GAAG,IAAI,CAACE,eAAe,GAAG,IAAI,CAACe,aAAa;EAC1E,CAAC;EAED;AACF;AACA;AACA;EACE,IAAIC,gBAAgBA,CAAA,EAAG;IACrB,MAAMC,YAAY,GAAG,IAAI,CAACpB,aAAa;IACvC,OAAOqB,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEF,YAAY,GAAG,IAAI,CAACL,cAAc,CAAC;EACxD,CAAC;EAED,IAAID,aAAaA,CAAA,EAAG;IAClB,OAAO,IAAI,CAACS,gBAAgB,IAAI,CAAC;EACnC,CAAC;EAED,IAAIT,aAAaA,CAACU,GAAG,EAAE;IACrBA,GAAG,GAAG,IAAI,CAACC,MAAM,CAACD,GAAG,EAAE,CAAC,EAAE,IAAI,CAACL,gBAAgB,CAAC;IAChD,IAAI,CAACI,gBAAgB,GAAGC,GAAG;EAC7B,CAAC;EAED,IAAIE,cAAcA,CAAA,EAAG;IACnB,OAAO,IAAI,CAACC,iBAAiB,IAAI,CAAC;EACpC,CAAC;EAED;AACF;AACA;EACE,IAAID,cAAcA,CAACF,GAAG,EAAE;IACtBA,GAAG,IAAI,IAAI,CAACT,cAAc;IAC1B,IAAIS,GAAG,GAAG,CAAC,EAAE;MACXA,GAAG,GAAG,IAAI,CAACT,cAAc,GAAGS,GAAG;IACjC;IACA,IAAI,CAACG,iBAAiB,GAAGH,GAAG;EAC9B,CAAC;EAED;AACF;AACA;EACE,IAAII,YAAYA,CAAA,EAAG;IACjB,OAAO,CAAC,IAAI,CAACF,cAAc,GAAG,IAAI,CAACX,cAAc,GAAG,CAAC,IAAI,IAAI,CAACA,cAAc;EAC9E,CAAC;EAED,IAAIA,cAAcA,CAAA,EAAG;IACnB,OAAO,IAAI,CAACc,iBAAiB,IAAI,CAAC;EACpC,CAAC;EAED,IAAId,cAAcA,CAACS,GAAG,EAAE;IACtB,IAAI,CAACK,iBAAiB,GAAGL,GAAG;EAC9B,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAIM,gBAAgBA,CAAA,EAAG;IACrB,OAAO,IAAI,CAAC3B,eAAe,KAAK,CAAC,GAAG4B,QAAQ,GAAG,IAAI,CAAC5B,eAAe,GAAG,IAAI,CAACM,SAAS;EACtF,CAAC;EAED;AACF;AACA;EACE,IAAIuB,UAAUA,CAAA,EAAG;IACf,OAAOC,OAAO,CAAC,IAAI,CAACC,WAAW,IAAI,IAAI,CAACC,YAAY,CAAC;EACvD,CAAC;EAED;AACF;AACA;AACA;AACA;EACE,IAAIC,iBAAiBA,CAAA,EAAG;IACtB,IAAIC,GAAG,GAAG,IAAI,CAAC9B,qBAAqB;IACpC,IAAI8B,GAAG,IAAI,IAAI,EAAE;MACf,IAAIC,cAAc,GAAG,IAAI,CAACvC,YAAY,GAAG,IAAI,CAACmB,aAAa;MAE3DmB,GAAG,GACD,IAAI,CAACE,aAAa,CAAC,CAACC,IAAI,EAAEC,IAAI,KAAK;QACjCH,cAAc,IAAI,IAAI,CAACI,yBAAyB,CAACF,IAAI,CAAC;QAEtD,IAAIF,cAAc,GAAG,IAAI,CAAC3C,eAAe,EAAE;UACzC,OAAO8C,IAAI;QACb;MACF,CAAC,CAAC,IAAI,CAAC;MACT,IAAI,CAAClC,qBAAqB,GAAG8B,GAAG;IAClC;IACA,OAAOA,GAAG;EACZ,CAAC;EAED;AACF;AACA;AACA;AACA;EACE,IAAIM,gBAAgBA,CAAA,EAAG;IACrB,IAAIN,GAAG,GAAG,IAAI,CAAC7B,oBAAoB;IACnC,IAAI6B,GAAG,IAAI,IAAI,EAAE;MACf,IAAIC,cAAc,GAAG,IAAI,CAACvC,YAAY,GAAG,IAAI,CAACmB,aAAa;MAC3D,IAAI,CAACqB,aAAa,CAAC,CAACC,IAAI,EAAEC,IAAI,KAAK;QACjC,IAAIH,cAAc,GAAG,IAAI,CAAC1B,aAAa,EAAE;UACvCyB,GAAG,GAAGI,IAAI;QACZ;QACAH,cAAc,IAAI,IAAI,CAACI,yBAAyB,CAACF,IAAI,CAAC;MACxD,CAAC,CAAC;MAEF,IAAI,CAAChC,oBAAoB,GAAG6B,GAAG;IACjC;IACA,OAAOA,GAAG;EACZ,CAAC;EAED,IAAInB,aAAaA,CAAA,EAAG;IAClB,OAAO,IAAI,CAACxB,mBAAmB,GAAG,IAAI,CAACkD,YAAY;EACrD,CAAC;EAED;AACF;AACA;EACEC,cAAcA,CAAA,EAAG;IACf,MAAMC,SAAS,GAAGzB,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAAC0B,GAAG,CAAC,IAAI,CAAC9B,aAAa,EAAE,IAAI,CAAC+B,UAAU,CAAC,CAAC;IAC5E,IAAIC,KAAK,GAAGH,SAAS,GAAG,IAAI,CAACnD,eAAe;IAC5C,MAAMuD,eAAe,GAAGD,KAAK,IAAI,CAAC;IAClC;IACA,IAAI,CAACtD,eAAe,GAAGmD,SAAS;IAChC;IACA,IAAI,CAACvC,qBAAqB,GAAG,IAAI;IACjC,IAAI,CAACC,oBAAoB,GAAG,IAAI;IAChC;IACA,IAAIa,IAAI,CAAC8B,GAAG,CAACF,KAAK,CAAC,GAAG,IAAI,CAACrD,aAAa,IAAI,IAAI,CAACA,aAAa,GAAG,CAAC,EAAE;MAClEqD,KAAK,IAAI,IAAI,CAAC/B,aAAa;MAC3B,MAAMkC,aAAa,GAAG/B,IAAI,CAACgC,KAAK,CAACJ,KAAK,GAAG,IAAI,CAACpD,gBAAgB,CAAC;MAC/D,IAAI,CAACiB,aAAa,IAAIsC,aAAa;MACnC,IAAI,CAAC1B,cAAc,IAAI0B,aAAa;MACpC;MACA;MACA;MACA;MACA;MACA;MACA,IAAI,CAACrD,YAAY,GAAGsB,IAAI,CAAC0B,GAAG,CAAC1B,IAAI,CAACiC,KAAK,CAAC,IAAI,CAACxC,aAAa,CAAC,GAAG,IAAI,CAACjB,gBAAgB,EAAE,IAAI,CAACF,eAAe,CAAC;MAC1G,IAAI,CAAC4D,OAAO,CAAC,CAAC;IAChB,CAAC,MAAM,IAAI,IAAI,CAACxC,cAAc,GAAG,CAAC,EAAE;MAClC,MAAMyC,SAAS,GAAG,IAAI,CAACC,aAAa,CAACP,eAAe,CAAC;MACrD,IAAIA,eAAe,EAAE;QACnB,IAAI,CAACnD,YAAY,GAAGyD,SAAS,CAACE,WAAW;QACzC,IAAI,CAAC5C,aAAa,IAAI0C,SAAS,CAACG,OAAO,CAACC,MAAM;QAC9C,IAAI,CAAClC,cAAc,IAAI8B,SAAS,CAACG,OAAO,CAACC,MAAM;MACjD,CAAC,MAAM;QACL,IAAI,CAAC9C,aAAa,IAAI0C,SAAS,CAACG,OAAO,CAACC,MAAM;QAC9C,IAAI,CAAClC,cAAc,IAAI8B,SAAS,CAACG,OAAO,CAACC,MAAM;MACjD;MACA,IAAI,CAACL,OAAO,CAACC,SAAS,CAACG,OAAO,EAAET,eAAe,GAAG,IAAI,GAAGM,SAAS,CAACG,OAAO,CAAC;MAC3E,IAAI,CAACE,SAAS,CAAC,uBAAuB,EAAE,IAAI,CAACC,qBAAqB,CAACC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC,EAAEjF,SAAS,CAAC;IAC9F;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;EACE2E,aAAaA,CAACO,OAAO,EAAE;IACrB,IAAIC,GAAG,EAAEC,aAAa,EAAEC,kBAAkB;IAC1C,MAAMC,IAAI,GAAG,EAAE;IACf,MAAMC,sBAAsB,GAAG,IAAI,CAACrD,kBAAkB,GAAG,IAAI,CAACvB,MAAM;IACpE,MAAM6E,YAAY,GAAG,IAAI,CAACxD,aAAa;IACvC,MAAMyD,UAAU,GAAG,IAAI,CAAC1D,WAAW;IACnC,MAAM2D,aAAa,GAAG,IAAI,CAACzD,cAAc;IACzC,IAAI0D,GAAG,GAAG,IAAI,CAAC1E,YAAY,GAAG,IAAI,CAACmB,aAAa;IAChD,MAAMwD,MAAM,GAAG,IAAI,CAAC/D,eAAe,GAAG,IAAI,CAACO,aAAa;IACxD;IACA,MAAM4B,SAAS,GAAG,IAAI,CAACnD,eAAe;IACtC,MAAMgF,YAAY,GAAG,IAAI,CAAC/D,aAAa;IAEvC,IAAIoD,OAAO,EAAE;MACXC,GAAG,GAAG,IAAI,CAACvC,cAAc;MACzBwC,aAAa,GAAGpB,SAAS,GAAG2B,GAAG;IACjC,CAAC,MAAM;MACLR,GAAG,GAAG,IAAI,CAACrC,YAAY;MACvBsC,aAAa,GAAGQ,MAAM,GAAGC,YAAY;IACvC;IACA;IACA,OAAO,IAAI,EAAE;MACXR,kBAAkB,GAAG,IAAI,CAACzB,yBAAyB,CAACuB,GAAG,CAAC;MACxDC,aAAa,IAAIC,kBAAkB;MACnC,IAAIC,IAAI,CAACR,MAAM,IAAIY,aAAa,IAAIN,aAAa,IAAIG,sBAAsB,EAAE;QAC3E;MACF;MACA,IAAIL,OAAO,EAAE;QACX;QACA,IAAIO,UAAU,GAAGH,IAAI,CAACR,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC5D,aAAa,EAAE;UACtD;QACF;QACA;QACA,IAAIyE,GAAG,GAAGN,kBAAkB,IAAIrB,SAAS,GAAG,IAAI,CAAC5B,aAAa,EAAE;UAC9D;QACF;QACAkD,IAAI,CAACQ,IAAI,CAACX,GAAG,CAAC;QACdQ,GAAG,IAAIN,kBAAkB;QACzBF,GAAG,GAAG,CAACA,GAAG,GAAG,CAAC,IAAIO,aAAa;MACjC,CAAC,MAAM;QACL;QACA,IAAIF,YAAY,GAAGF,IAAI,CAACR,MAAM,IAAI,CAAC,EAAE;UACnC;QACF;QACA;QACA,IAAIa,GAAG,GAAG,IAAI,CAAC7E,aAAa,GAAGuE,kBAAkB,IAAIQ,YAAY,EAAE;UACjE;QACF;QACAP,IAAI,CAACQ,IAAI,CAACX,GAAG,CAAC;QACdQ,GAAG,IAAIN,kBAAkB;QACzBF,GAAG,GAAGA,GAAG,KAAK,CAAC,GAAGO,aAAa,GAAG,CAAC,GAAGP,GAAG,GAAG,CAAC;MAC/C;IACF;IACA,OAAO;MAAEN,OAAO,EAAES,IAAI;MAAEV,WAAW,EAAEe,GAAG,GAAG,IAAI,CAACvD;IAAc,CAAC;EACjE,CAAC;EAED;AACF;AACA;AACA;AACA;EACEqC,OAAOA,CAACsB,OAAO,EAAEC,QAAQ,EAAE;IACzB,IAAKD,OAAO,IAAIA,OAAO,CAACjB,MAAM,KAAK,CAAC,IAAK,IAAI,CAAC7C,cAAc,KAAK,CAAC,EAAE;MAClE;IACF;IACA,IAAI,CAACgE,aAAa,CAACF,OAAO,CAAC;IAC3B,IAAI,CAACG,cAAc,CAACH,OAAO,CAAC;IAC5B;IACA,IAAIC,QAAQ,EAAE;MACZ,OAAOA,QAAQ,CAAClB,MAAM,EAAE;QACtB,MAAMvB,GAAG,GAAGyC,QAAQ,CAACG,GAAG,CAAC,CAAC;QAC1B,IAAI,CAAClF,YAAY,IAAI,IAAI,CAAC2C,yBAAyB,CAACL,GAAG,CAAC;MAC1D;IACF;IACA,IAAI,CAAC6C,cAAc,CAAC,CAAC;IACrB,IAAI,CAACC,mBAAmB,CAAC,CAAC;EAC5B,CAAC;EAEDC,aAAaA,CAAA,EAAG;IACd,OACE,IAAI,CAACxE,aAAa,KAAK,CAAC,IACxB,IAAI,CAACD,eAAe,GAAG,CAAC,IAAI,IAAI,CAACC,aAAa,IAC9C,IAAI,CAACb,YAAY,IAAI,IAAI,CAACJ,eAAe;EAE7C,CAAC;EAED;AACF;AACA;EACEmE,qBAAqBA,CAACuB,KAAK,EAAE;IAC3B,MAAMC,iBAAiB,GAAG,IAAI,CAAC7D,MAAM,CACnC,IAAI,CAACV,cAAc,GAAGsE,KAAK,EAC3B9F,sBAAsB,EACtB,IAAI,CAACS,aAAa,GAAG,IAAI,CAACc,aAC5B,CAAC;IACD,MAAMmC,KAAK,GAAGqC,iBAAiB,GAAG,IAAI,CAACvE,cAAc;IACrD,IAAIwE,YAAY,GAAGlE,IAAI,CAACgC,KAAK,CAAC,IAAI,CAACtC,cAAc,GAAG,GAAG,CAAC;IAExD,IAAIkC,KAAK,GAAG,CAAC,EAAE;MACb;IACF;IACA,IAAIA,KAAK,GAAG,CAAC,EAAE;MACb,MAAMuC,EAAE,GAAGC,MAAM,CAACC,WAAW,CAACC,GAAG,CAAC,CAAC;MACnC;MACA,EAAE,CAACf,IAAI,CAACgB,KAAK,CAAC,IAAI,CAACvF,cAAc,EAAE,IAAI,CAACwF,WAAW,CAAC5C,KAAK,CAAC,CAAC;MAC3D;MACA;MACA,KAAK,IAAI6C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7C,KAAK,EAAE6C,CAAC,EAAE,EAAE;QAC9B,IAAI,CAACxF,cAAc,CAACsE,IAAI,CAAC,CAAC,CAAC;MAC7B;MACA,IAAI,CAAC7D,cAAc,IAAIkC,KAAK;MAC5B;MACA;MACA;MACA;MACA,IACE,IAAI,CAACvB,cAAc,GAAG,IAAI,CAACE,YAAY,IACvC,IAAI,CAACmE,gBAAgB,CAAC,IAAI,CAACC,oBAAoB,CAAC,IAChD,IAAI,CAACC,iBAAiB,CAAC,IAAI,CAACD,oBAAoB,CAAC,GAAG,IAAI,CAACpE,YAAY,EACrE;QACA,IAAI,CAACF,cAAc,IAAIuB,KAAK;MAC9B;MACA,IAAI,CAACM,OAAO,CAAC,CAAC;MACd,IAAI,CAAC7C,aAAa,GAAG,CAAC+E,MAAM,CAACC,WAAW,CAACC,GAAG,CAAC,CAAC,GAAGH,EAAE,IAAIvC,KAAK;MAC5DsC,YAAY,GAAGlE,IAAI,CAACgC,KAAK,CAAC,IAAI,CAACtC,cAAc,GAAG,GAAG,CAAC;IACtD;IACA,IAAI,IAAI,CAACF,WAAW,IAAI,IAAI,CAACb,aAAa,GAAG,CAAC,IAAIuF,YAAY,KAAK,CAAC,EAAE;MACpE;IAAA,CACD,MAAM,IAAI,CAAC,IAAI,CAACH,aAAa,CAAC,CAAC,EAAE;MAChC,IAAI,CAACvB,SAAS,CAAC,uBAAuB,EAAE,IAAI,CAACC,qBAAqB,CAACC,IAAI,CAAC,IAAI,EAAEwB,YAAY,CAAC,EAAEzG,SAAS,CAAC;IACzG,CAAC,MAAM,IAAI,IAAI,CAACc,aAAa,GAAG,IAAI,CAACkC,gBAAgB,EAAE;MACrD;MACA;MACA,IAAI,CAAC+B,SAAS,CACZ,uBAAuB,EACvB,IAAI,CAACC,qBAAqB,CAACC,IAAI,CAAC,IAAI,EAAE,IAAI,CAACtC,MAAM,CAACJ,IAAI,CAACgC,KAAK,CAAC,EAAE,GAAG,IAAI,CAAC3C,aAAa,CAAC,EAAE,CAAC,EAAE6E,YAAY,CAAC,CAAC,EACxG1G,UACF,CAAC;IACH;EACF,CAAC;EAED;AACF;AACA;EACEqH,OAAOA,CAAA,EAAG;IACR,IAAI,CAAC,IAAI,CAACC,UAAU,IAAI,CAAC,IAAI,CAACnE,UAAU,EAAE;MACxC;IACF;IACA,IAAI,IAAI,CAACjB,cAAc,KAAK,CAAC,EAAE;MAC7B,MAAMyC,SAAS,GAAG,IAAI,CAACC,aAAa,CAAC,IAAI,CAAC;MAC1C,IAAI,CAAC1D,YAAY,GAAGyD,SAAS,CAACE,WAAW;MACzC,IAAI,CAAC5C,aAAa,IAAI0C,SAAS,CAACG,OAAO,CAACC,MAAM;MAC9C,IAAI,CAAClC,cAAc,IAAI8B,SAAS,CAACG,OAAO,CAACC,MAAM;MAC/C,IAAI,CAACL,OAAO,CAACC,SAAS,CAACG,OAAO,CAAC;MAC/B,IAAI,CAACJ,OAAO,CAAC,CAAC;MACd,IAAI,CAACO,qBAAqB,CAAC,CAAC,CAAC;IAC/B,CAAC,MAAM,IAAI,IAAI,CAAC9D,aAAa,GAAG,CAAC,EAAE;MACjC;MACA,IAAI,CAACoG,wBAAwB,CAAC,CAAC;MAC/B,IAAI,CAACtC,qBAAqB,CAACvE,sBAAsB,CAAC;IACpD;EACF,CAAC;EAED;AACF;AACA;AACA;EACE8G,aAAaA,CAACC,MAAM,EAAE;IACpB,IAAIA,MAAM,CAACC,IAAI,KAAK,OAAO,EAAE;MAC3B,IAAI,CAACzF,aAAa,GAAG,CAAC;MACtB,IAAI,CAACf,YAAY,GAAG,CAAC;MACrB,IAAI,CAACC,aAAa,GAAG,IAAI,CAACwG,KAAK,GAAG,IAAI,CAACA,KAAK,CAAC5C,MAAM,GAAG,CAAC;MACvD,IAAI,CAAC6C,oBAAoB,GAAG,CAAC,CAAC;MAC9B,IAAI,CAAClG,qBAAqB,GAAG,IAAI;MACjC,IAAI,CAACC,oBAAoB,GAAG,IAAI;MAChC,IAAI,CAAC,IAAI,CAACH,cAAc,EAAE;QACxB,IAAI,CAACA,cAAc,GAAG,EAAE;MAC1B;MACA,IAAI,CAAC,IAAI,CAACC,cAAc,EAAE;QACxB,IAAI,CAACA,cAAc,GAAG,EAAE;MAC1B;MACA,IAAI,CAACoB,cAAc,GAAG,CAAC;MACvB,IAAI,IAAI,CAACsB,UAAU,GAAG,IAAI,CAAC9B,aAAa,EAAE;QACxC,IAAI,CAACwF,oBAAoB,CAAC,CAAC,CAAC;MAC9B;MACA,IAAI,CAAC7C,SAAS,CAAC,SAAS,EAAE,IAAI,CAACqC,OAAO,EAAEtH,cAAc,CAAC;IACzD;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE2D,aAAaA,CAACoE,EAAE,EAAE9B,OAAO,EAAE;IACzB,IAAIrC,IAAI,EAAEC,IAAI,EAAEmE,GAAG,EAAEd,CAAC;IAEtB,IAAIe,SAAS,CAACjD,MAAM,KAAK,CAAC,IAAIiB,OAAO,EAAE;MACrC,KAAKiB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGjB,OAAO,CAACjB,MAAM,EAAEkC,CAAC,EAAE,EAAE;QACnCtD,IAAI,GAAGqC,OAAO,CAACiB,CAAC,CAAC;QACjBrD,IAAI,GAAG,IAAI,CAACqE,YAAY,CAACtE,IAAI,CAAC;QAC9B,IAAI,CAACoE,GAAG,GAAGD,EAAE,CAACI,IAAI,CAAC,IAAI,EAAEvE,IAAI,EAAEC,IAAI,CAAC,KAAK,IAAI,EAAE;UAC7C,OAAOmE,GAAG;QACZ;MACF;IACF,CAAC,MAAM;MACLpE,IAAI,GAAG,IAAI,CAACd,cAAc;MAC1Be,IAAI,GAAG,IAAI,CAAC3B,aAAa;MACzB,OAAO0B,IAAI,GAAG,IAAI,CAACzB,cAAc,EAAEyB,IAAI,EAAE,EAAEC,IAAI,EAAE,EAAE;QACjD,IAAI,CAACmE,GAAG,GAAGD,EAAE,CAACI,IAAI,CAAC,IAAI,EAAEvE,IAAI,EAAEC,IAAI,CAAC,KAAK,IAAI,EAAE;UAC7C,OAAOmE,GAAG;QACZ;MACF;MACA,KAAKpE,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAG,IAAI,CAACd,cAAc,EAAEc,IAAI,EAAE,EAAEC,IAAI,EAAE,EAAE;QACzD,IAAI,CAACmE,GAAG,GAAGD,EAAE,CAACI,IAAI,CAAC,IAAI,EAAEvE,IAAI,EAAEC,IAAI,CAAC,KAAK,IAAI,EAAE;UAC7C,OAAOmE,GAAG;QACZ;MACF;IACF;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;EACEE,YAAYA,CAACtE,IAAI,EAAE;IACjB,IAAIA,IAAI,IAAI,IAAI,CAACd,cAAc,EAAE;MAC/B,OAAO,IAAI,CAACZ,aAAa,IAAI0B,IAAI,GAAG,IAAI,CAACd,cAAc,CAAC;IAC1D;IACA,OAAO,IAAI,CAACZ,aAAa,IAAI,IAAI,CAACC,cAAc,GAAG,IAAI,CAACW,cAAc,CAAC,GAAGc,IAAI;EAChF,CAAC;EAED;AACF;AACA;EACE0C,cAAcA,CAAA,EAAG;IACf,IAAI,CAAC8B,qBAAqB,CAAC,CAAC;IAE5B,IAAIC,CAAC,GAAG,IAAI,CAAClH,YAAY;IAEzB,IAAI,CAACwC,aAAa,CAAEC,IAAI,IAAK;MAC3B,IAAI,CAAC0E,WAAW,CAAC,CAAC,EAAG,GAAED,CAAE,IAAG,EAAE,CAAC,EAAE,IAAI,CAAC5G,cAAc,CAACmC,IAAI,CAAC,CAAC;MAC3DyE,CAAC,IAAI,IAAI,CAAC3G,cAAc,CAACkC,IAAI,CAAC;IAChC,CAAC,CAAC;EACJ,CAAC;EAEDE,yBAAyBA,CAACF,IAAI,EAAE;IAC9B,OAAO,IAAI,CAAClC,cAAc,CAACkC,IAAI,CAAC;EAClC,CAAC;EAED;AACF;AACA;EACEwE,qBAAqBA,CAAA,EAAG;IACtB,MAAMG,WAAW,GACf,IAAI,CAACrG,aAAa,KAAK,CAAC,GAAG,IAAI,CAACf,YAAY,GAAGsB,IAAI,CAAC0B,GAAG,CAAC,IAAI,CAACpD,eAAe,GAAG,IAAI,CAACI,YAAY,EAAE,CAAC,CAAC;IACtG;IACA,IAAIoH,WAAW,KAAK,CAAC,EAAE;MACrB,IAAI,CAACpH,YAAY,IAAIoH,WAAW;MAChC;MACA,MAAMrE,SAAS,GAAG,IAAI,CAACnD,eAAe;MACtC;MACA,IAAI,CAACL,mBAAmB,IAAIwD,SAAS,GAAG,CAAC,EAAE;QACzC,IAAI,CAAC4D,oBAAoB,CAAC5D,SAAS,GAAGqE,WAAW,CAAC;MACpD;IACF;EACF,CAAC;EAED;AACF;AACA;EACET,oBAAoBA,CAACU,GAAG,EAAE;IACxB,IAAI,IAAI,CAACC,YAAY,IAAID,GAAG,IAAI,CAAC,EAAE;MACjC,IAAI,CAACpE,UAAU,GAAGoE,GAAG;MACrB,IAAI,CAACzH,eAAe,GAAG,IAAI,CAACqD,UAAU;IACxC;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;EACEmC,mBAAmBA,CAACmC,WAAW,EAAE;IAC/B,MAAMC,eAAe,GACnB,IAAI,CAAC5G,eAAe,GACpBU,IAAI,CAACC,GAAG,CAAC,IAAI,CAACtB,aAAa,GAAG,IAAI,CAACe,cAAc,GAAG,IAAI,CAACD,aAAa,EAAE,CAAC,CAAC,GAAG,IAAI,CAACjB,gBAAgB;IAEpG,IAAI,CAACI,gBAAgB,GAAGsH,eAAe;;IAEvC;IACA,IACED,WAAW,IACX,IAAI,CAACpH,aAAa,KAAK,CAAC,IACxB,IAAI,CAACP,eAAe,IAAI4H,eAAe,GAAG,IAAI,CAAC3H,aAAa,IAC5DyB,IAAI,CAAC8B,GAAG,CAACoE,eAAe,GAAG,IAAI,CAACrH,aAAa,CAAC,IAAI,IAAI,CAACC,eAAe,EACtE;MACA,IAAI,CAACqH,CAAC,CAAChB,KAAK,CAACiB,KAAK,CAACC,MAAM,GAAI,GAAEH,eAAgB,IAAG;MAClD,IAAI,CAACrH,aAAa,GAAGqH,eAAe;IACtC;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACEI,aAAaA,CAACtF,GAAG,EAAE;IACjB,IAAI,OAAOA,GAAG,KAAK,QAAQ,IAAIA,GAAG,GAAG,CAAC,IAAIA,GAAG,GAAG,IAAI,CAACmE,KAAK,CAAC5C,MAAM,GAAG,CAAC,EAAE;MACrE;IACF;IACA3E,KAAK,CAAC,CAAC;IACP;IACA,IAAI,IAAI,CAAC8B,cAAc,KAAK,CAAC,EAAE;MAC7B;IACF;IACAsB,GAAG,GAAG,IAAI,CAACZ,MAAM,CAACY,GAAG,EAAE,CAAC,EAAE,IAAI,CAACrC,aAAa,GAAG,CAAC,CAAC;IACjD;IACA,IAAI,CAAC,IAAI,CAAC+F,gBAAgB,CAAC1D,GAAG,CAAC,IAAIA,GAAG,IAAI,IAAI,CAAClB,gBAAgB,EAAE;MAC/D,IAAI,CAACL,aAAa,GAAGuB,GAAG,GAAG,CAAC;IAC9B;IACA,IAAI,CAAC0C,aAAa,CAAC,CAAC;IACpB,IAAI,CAACC,cAAc,CAAC,CAAC;IACrB;IACA,IAAI,CAACjF,YAAY,GAAG,IAAI,CAACe,aAAa,GAAG,IAAI,CAACjB,gBAAgB;IAE9D,IAAI+H,cAAc,GAAG,IAAI,CAAClG,cAAc;IACxC,IAAImG,kBAAkB,GAAG,IAAI,CAAC/G,aAAa;IAC3C,IAAIgH,eAAe,GAAG,CAAC;IACvB,MAAMC,iBAAiB,GAAG,IAAI,CAAC/G,kBAAkB;IACjD;IACA,OAAO6G,kBAAkB,GAAGxF,GAAG,IAAIyF,eAAe,IAAIC,iBAAiB,EAAE;MACvED,eAAe,IAAI,IAAI,CAACpF,yBAAyB,CAACkF,cAAc,CAAC;MACjEA,cAAc,GAAG,CAACA,cAAc,GAAG,CAAC,IAAI,IAAI,CAAC7G,cAAc;MAC3D8G,kBAAkB,IAAI,CAAC;IACzB;IACA,IAAI,CAAC1C,mBAAmB,CAAC,IAAI,CAAC;IAC9B,IAAI,CAACD,cAAc,CAAC,CAAC;IACrB,IAAI,CAACwB,oBAAoB,CAAC,IAAI,CAAC3G,YAAY,GAAG,IAAI,CAACmB,aAAa,GAAG4G,eAAe,CAAC;IACnF,IAAI,CAAChE,qBAAqB,CAAC,CAAC,CAAC;IAC7B;IACA,IAAI,CAACvD,qBAAqB,GAAG,IAAI;IACjC,IAAI,CAACC,oBAAoB,GAAG,IAAI;EAClC,CAAC;EAED;AACF;AACA;EACEwH,aAAaA,CAAA,EAAG;IACd,IAAI,CAACnI,gBAAgB,GAAG,CAAC;IACzB,IAAI,CAACC,qBAAqB,GAAG,CAAC;EAChC,CAAC;EAED;AACF;AACA;AACA;EACEmI,cAAcA,CAAA,EAAG;IACf,IAAI,CAACpE,SAAS,CACZ,SAAS,EACT,MAAM;MACJ;MACA,IAAI,CAACtD,qBAAqB,GAAG,IAAI;MACjC,IAAI,CAACC,oBAAoB,GAAG,IAAI;MAChC,IAAI,IAAI,CAACwB,UAAU,EAAE;QACnB,IAAI,CAACoE,wBAAwB,CAAC,CAAC;QAC/B;QACA,IAAI,CAAC8B,oBAAoB,CAAC,IAAI,CAAC;QAC/B,IAAI,CAACF,aAAa,CAAC,CAAC;QACpB,IAAI,CAAC9B,OAAO,CAAC,CAAC;MAChB,CAAC,MAAM;QACL;QACA,IAAI,CAACgC,oBAAoB,CAAC,KAAK,CAAC;MAClC;IACF,CAAC,EACDtJ,cACF,CAAC;EACH,CAAC;EAEDmH,gBAAgBA,CAAC1D,GAAG,EAAE;IACpB,OAAOA,GAAG,IAAI,IAAI,CAACvB,aAAa,IAAIuB,GAAG,IAAI,IAAI,CAACxB,WAAW;EAC7D,CAAC;EAEDoF,iBAAiBA,CAACxD,IAAI,EAAE;IACtB,OAAO,CAAC,IAAI,CAACf,cAAc,IAAIe,IAAI,GAAG,IAAI,CAAC3B,aAAa,CAAC,IAAI,IAAI,CAACC,cAAc;EAClF,CAAC;EAEDU,MAAMA,CAAC0G,CAAC,EAAEpF,GAAG,EAAEzB,GAAG,EAAE;IAClB,OAAOD,IAAI,CAAC0B,GAAG,CAACzB,GAAG,EAAED,IAAI,CAACC,GAAG,CAACyB,GAAG,EAAEoF,CAAC,CAAC,CAAC;EACxC,CAAC;EAEDtE,SAASA,CAACuE,IAAI,EAAEC,EAAE,EAAEC,WAAW,EAAE;IAC/B,IAAI,CAAC,IAAI,CAACC,WAAW,EAAE;MACrB,IAAI,CAACA,WAAW,GAAG,CAAC,CAAC;IACvB;IACA,IAAI,CAACA,WAAW,CAACH,IAAI,CAAC,GAAGrJ,SAAS,CAACyJ,QAAQ,CAAC,IAAI,CAACD,WAAW,CAACH,IAAI,CAAC,EAAEE,WAAW,EAAED,EAAE,CAACtE,IAAI,CAAC,IAAI,CAAC,CAAC;IAC/F/E,gBAAgB,CAAC,IAAI,CAACuJ,WAAW,CAACH,IAAI,CAAC,CAAC;EAC1C;AACF,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}