{"ast":null,"code":"/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * @fileoverview\n *\n * Module for adding listeners to a node for the following normalized\n * cross-platform \"gesture\" events:\n * - `down` - mouse or touch went down\n * - `up` - mouse or touch went up\n * - `tap` - mouse click or finger tap\n * - `track` - mouse drag or touch move\n *\n * @summary Module for adding cross-platform gesture event listeners.\n */\n\nimport './boot.js';\nimport { timeOut, microTask } from './async.js';\nimport { Debouncer } from './debounce.js';\nimport { passiveTouchGestures } from './settings.js';\nimport { wrap } from './wrap.js';\n\n// detect native touch action support\nlet HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';\nlet GESTURE_KEY = '__polymerGestures';\nlet HANDLED_OBJ = '__polymerGesturesHandled';\nlet TOUCH_ACTION = '__polymerGesturesTouchAction';\n// radius for tap and track\nlet TAP_DISTANCE = 25;\nlet TRACK_DISTANCE = 5;\n// number of last N track positions to keep\nlet TRACK_LENGTH = 2;\n\n// Disabling \"mouse\" handlers for 2500ms is enough\nlet MOUSE_TIMEOUT = 2500;\nlet MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'click'];\n// an array of bitmask values for mapping MouseEvent.which to MouseEvent.buttons\nlet MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];\nlet MOUSE_HAS_BUTTONS = function () {\n  try {\n    return new MouseEvent('test', {\n      buttons: 1\n    }).buttons === 1;\n  } catch (e) {\n    return false;\n  }\n}();\n\n/**\n * @param {string} name Possible mouse event name\n * @return {boolean} true if mouse event, false if not\n */\nfunction isMouseEvent(name) {\n  return MOUSE_EVENTS.indexOf(name) > -1;\n}\n\n/* eslint no-empty: [\"error\", { \"allowEmptyCatch\": true }] */\n// check for passive event listeners\nlet SUPPORTS_PASSIVE = false;\n(function () {\n  try {\n    let opts = Object.defineProperty({}, 'passive', {\n      get() {\n        SUPPORTS_PASSIVE = true;\n      }\n    });\n    window.addEventListener('test', null, opts);\n    window.removeEventListener('test', null, opts);\n  } catch (e) {}\n})();\n\n/**\n * Generate settings for event listeners, dependant on `passiveTouchGestures`\n *\n * @param {string} eventName Event name to determine if `{passive}` option is\n *   needed\n * @return {{passive: boolean} | undefined} Options to use for addEventListener\n *   and removeEventListener\n */\nfunction PASSIVE_TOUCH(eventName) {\n  if (isMouseEvent(eventName) || eventName === 'touchend') {\n    return;\n  }\n  if (HAS_NATIVE_TA && SUPPORTS_PASSIVE && passiveTouchGestures) {\n    return {\n      passive: true\n    };\n  } else {\n    return;\n  }\n}\n\n// Check for touch-only devices\nlet IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);\n\n// keep track of any labels hit by the mouseCanceller\n/** @type {!Array<!HTMLLabelElement>} */\nconst clickedLabels = [];\n\n/** @type {!Object<boolean>} */\nconst labellable = {\n  'button': true,\n  'input': true,\n  'keygen': true,\n  'meter': true,\n  'output': true,\n  'textarea': true,\n  'progress': true,\n  'select': true\n};\n\n// Defined at https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#enabling-and-disabling-form-controls:-the-disabled-attribute\n/** @type {!Object<boolean>} */\nconst canBeDisabled = {\n  'button': true,\n  'command': true,\n  'fieldset': true,\n  'input': true,\n  'keygen': true,\n  'optgroup': true,\n  'option': true,\n  'select': true,\n  'textarea': true\n};\n\n/**\n * @param {HTMLElement} el Element to check labelling status\n * @return {boolean} element can have labels\n */\nfunction canBeLabelled(el) {\n  return labellable[el.localName] || false;\n}\n\n/**\n * @param {HTMLElement} el Element that may be labelled.\n * @return {!Array<!HTMLLabelElement>} Relevant label for `el`\n */\nfunction matchingLabels(el) {\n  let labels = Array.prototype.slice.call( /** @type {HTMLInputElement} */el.labels || []);\n  // IE doesn't have `labels` and Safari doesn't populate `labels`\n  // if element is in a shadowroot.\n  // In this instance, finding the non-ancestor labels is enough,\n  // as the mouseCancellor code will handle ancstor labels\n  if (!labels.length) {\n    labels = [];\n    let root = el.getRootNode();\n    // if there is an id on `el`, check for all labels with a matching `for` attribute\n    if (el.id) {\n      let matching = root.querySelectorAll(`label[for = ${el.id}]`);\n      for (let i = 0; i < matching.length; i++) {\n        labels.push( /** @type {!HTMLLabelElement} */matching[i]);\n      }\n    }\n  }\n  return labels;\n}\n\n// touch will make synthetic mouse events\n// `preventDefault` on touchend will cancel them,\n// but this breaks `<input>` focus and link clicks\n// disable mouse handlers for MOUSE_TIMEOUT ms after\n// a touchend to ignore synthetic mouse events\nlet mouseCanceller = function (mouseEvent) {\n  // Check for sourceCapabilities, used to distinguish synthetic events\n  // if mouseEvent did not come from a device that fires touch events,\n  // it was made by a real mouse and should be counted\n  // http://wicg.github.io/InputDeviceCapabilities/#dom-inputdevicecapabilities-firestouchevents\n  let sc = mouseEvent.sourceCapabilities;\n  if (sc && !sc.firesTouchEvents) {\n    return;\n  }\n  // skip synthetic mouse events\n  mouseEvent[HANDLED_OBJ] = {\n    skip: true\n  };\n  // disable \"ghost clicks\"\n  if (mouseEvent.type === 'click') {\n    let clickFromLabel = false;\n    let path = getComposedPath(mouseEvent);\n    for (let i = 0; i < path.length; i++) {\n      if (path[i].nodeType === Node.ELEMENT_NODE) {\n        if (path[i].localName === 'label') {\n          clickedLabels.push( /** @type {!HTMLLabelElement} */path[i]);\n        } else if (canBeLabelled( /** @type {!HTMLElement} */path[i])) {\n          let ownerLabels = matchingLabels( /** @type {!HTMLElement} */path[i]);\n          // check if one of the clicked labels is labelling this element\n          for (let j = 0; j < ownerLabels.length; j++) {\n            clickFromLabel = clickFromLabel || clickedLabels.indexOf(ownerLabels[j]) > -1;\n          }\n        }\n      }\n      if (path[i] === POINTERSTATE.mouse.target) {\n        return;\n      }\n    }\n    // if one of the clicked labels was labelling the target element,\n    // this is not a ghost click\n    if (clickFromLabel) {\n      return;\n    }\n    mouseEvent.preventDefault();\n    mouseEvent.stopPropagation();\n  }\n};\n\n/**\n * @param {boolean=} setup True to add, false to remove.\n * @return {void}\n */\nfunction setupTeardownMouseCanceller(setup) {\n  let events = IS_TOUCH_ONLY ? ['click'] : MOUSE_EVENTS;\n  for (let i = 0, en; i < events.length; i++) {\n    en = events[i];\n    if (setup) {\n      // reset clickLabels array\n      clickedLabels.length = 0;\n      document.addEventListener(en, mouseCanceller, true);\n    } else {\n      document.removeEventListener(en, mouseCanceller, true);\n    }\n  }\n}\nfunction ignoreMouse(e) {\n  if (!POINTERSTATE.mouse.mouseIgnoreJob) {\n    setupTeardownMouseCanceller(true);\n  }\n  let unset = function () {\n    setupTeardownMouseCanceller();\n    POINTERSTATE.mouse.target = null;\n    POINTERSTATE.mouse.mouseIgnoreJob = null;\n  };\n  POINTERSTATE.mouse.target = getComposedPath(e)[0];\n  POINTERSTATE.mouse.mouseIgnoreJob = Debouncer.debounce(POINTERSTATE.mouse.mouseIgnoreJob, timeOut.after(MOUSE_TIMEOUT), unset);\n}\n\n/**\n * @param {MouseEvent} ev event to test for left mouse button down\n * @return {boolean} has left mouse button down\n */\nfunction hasLeftMouseButton(ev) {\n  let type = ev.type;\n  // exit early if the event is not a mouse event\n  if (!isMouseEvent(type)) {\n    return false;\n  }\n  // ev.button is not reliable for mousemove (0 is overloaded as both left button and no buttons)\n  // instead we use ev.buttons (bitmask of buttons) or fall back to ev.which (deprecated, 0 for no buttons, 1 for left button)\n  if (type === 'mousemove') {\n    // allow undefined for testing events\n    let buttons = ev.buttons === undefined ? 1 : ev.buttons;\n    if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {\n      buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;\n    }\n    // buttons is a bitmask, check that the left button bit is set (1)\n    return Boolean(buttons & 1);\n  } else {\n    // allow undefined for testing events\n    let button = ev.button === undefined ? 0 : ev.button;\n    // ev.button is 0 in mousedown/mouseup/click for left button activation\n    return button === 0;\n  }\n}\nfunction isSyntheticClick(ev) {\n  if (ev.type === 'click') {\n    // ev.detail is 0 for HTMLElement.click in most browsers\n    if (ev.detail === 0) {\n      return true;\n    }\n    // in the worst case, check that the x/y position of the click is within\n    // the bounding box of the target of the event\n    // Thanks IE 10 >:(\n    let t = _findOriginalTarget(ev);\n    // make sure the target of the event is an element so we can use getBoundingClientRect,\n    // if not, just assume it is a synthetic click\n    if (!t.nodeType || /** @type {Element} */t.nodeType !== Node.ELEMENT_NODE) {\n      return true;\n    }\n    let bcr = /** @type {Element} */t.getBoundingClientRect();\n    // use page x/y to account for scrolling\n    let x = ev.pageX,\n      y = ev.pageY;\n    // ev is a synthetic click if the position is outside the bounding box of the target\n    return !(x >= bcr.left && x <= bcr.right && y >= bcr.top && y <= bcr.bottom);\n  }\n  return false;\n}\nlet POINTERSTATE = {\n  mouse: {\n    target: null,\n    mouseIgnoreJob: null\n  },\n  touch: {\n    x: 0,\n    y: 0,\n    id: -1,\n    scrollDecided: false\n  }\n};\nfunction firstTouchAction(ev) {\n  let ta = 'auto';\n  let path = getComposedPath(ev);\n  for (let i = 0, n; i < path.length; i++) {\n    n = path[i];\n    if (n[TOUCH_ACTION]) {\n      ta = n[TOUCH_ACTION];\n      break;\n    }\n  }\n  return ta;\n}\nfunction trackDocument(stateObj, movefn, upfn) {\n  stateObj.movefn = movefn;\n  stateObj.upfn = upfn;\n  document.addEventListener('mousemove', movefn);\n  document.addEventListener('mouseup', upfn);\n}\nfunction untrackDocument(stateObj) {\n  document.removeEventListener('mousemove', stateObj.movefn);\n  document.removeEventListener('mouseup', stateObj.upfn);\n  stateObj.movefn = null;\n  stateObj.upfn = null;\n}\n\n// use a document-wide touchend listener to start the ghost-click prevention mechanism\n// Use passive event listeners, if supported, to not affect scrolling performance\ndocument.addEventListener('touchend', ignoreMouse, SUPPORTS_PASSIVE ? {\n  passive: true\n} : false);\n\n/**\n * Returns the composedPath for the given event.\n * @param {Event} event to process\n * @return {!Array<!EventTarget>} Path of the event\n */\nconst getComposedPath = window.ShadyDOM && window.ShadyDOM.noPatch ? window.ShadyDOM.composedPath : event => event.composedPath && event.composedPath() || [];\n\n/** @type {!Object<string, !GestureRecognizer>} */\nexport const gestures = {};\n\n/** @type {!Array<!GestureRecognizer>} */\nexport const recognizers = [];\n\n/**\n * Finds the element rendered on the screen at the provided coordinates.\n *\n * Similar to `document.elementFromPoint`, but pierces through\n * shadow roots.\n *\n * @param {number} x Horizontal pixel coordinate\n * @param {number} y Vertical pixel coordinate\n * @return {Element} Returns the deepest shadowRoot inclusive element\n * found at the screen position given.\n */\nexport function deepTargetFind(x, y) {\n  let node = document.elementFromPoint(x, y);\n  let next = node;\n  // this code path is only taken when native ShadowDOM is used\n  // if there is a shadowroot, it may have a node at x/y\n  // if there is not a shadowroot, exit the loop\n  while (next && next.shadowRoot && !window.ShadyDOM) {\n    // if there is a node at x/y in the shadowroot, look deeper\n    let oldNext = next;\n    next = next.shadowRoot.elementFromPoint(x, y);\n    // on Safari, elementFromPoint may return the shadowRoot host\n    if (oldNext === next) {\n      break;\n    }\n    if (next) {\n      node = next;\n    }\n  }\n  return node;\n}\n\n/**\n * a cheaper check than ev.composedPath()[0];\n *\n * @private\n * @param {Event|Touch} ev Event.\n * @return {EventTarget} Returns the event target.\n */\nfunction _findOriginalTarget(ev) {\n  const path = getComposedPath( /** @type {?Event} */ev);\n  // It shouldn't be, but sometimes path is empty (window on Safari).\n  return path.length > 0 ? path[0] : ev.target;\n}\n\n/**\n * @private\n * @param {Event} ev Event.\n * @return {void}\n */\nfunction _handleNative(ev) {\n  let handled;\n  let type = ev.type;\n  let node = ev.currentTarget;\n  let gobj = node[GESTURE_KEY];\n  if (!gobj) {\n    return;\n  }\n  let gs = gobj[type];\n  if (!gs) {\n    return;\n  }\n  if (!ev[HANDLED_OBJ]) {\n    ev[HANDLED_OBJ] = {};\n    if (type.slice(0, 5) === 'touch') {\n      ev = /** @type {TouchEvent} */ev; // eslint-disable-line no-self-assign\n      let t = ev.changedTouches[0];\n      if (type === 'touchstart') {\n        // only handle the first finger\n        if (ev.touches.length === 1) {\n          POINTERSTATE.touch.id = t.identifier;\n        }\n      }\n      if (POINTERSTATE.touch.id !== t.identifier) {\n        return;\n      }\n      if (!HAS_NATIVE_TA) {\n        if (type === 'touchstart' || type === 'touchmove') {\n          _handleTouchAction(ev);\n        }\n      }\n    }\n  }\n  handled = ev[HANDLED_OBJ];\n  // used to ignore synthetic mouse events\n  if (handled.skip) {\n    return;\n  }\n  // reset recognizer state\n  for (let i = 0, r; i < recognizers.length; i++) {\n    r = recognizers[i];\n    if (gs[r.name] && !handled[r.name]) {\n      if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {\n        r.reset();\n      }\n    }\n  }\n  // enforce gesture recognizer order\n  for (let i = 0, r; i < recognizers.length; i++) {\n    r = recognizers[i];\n    if (gs[r.name] && !handled[r.name]) {\n      handled[r.name] = true;\n      r[type](ev);\n    }\n  }\n}\n\n/**\n * @private\n * @param {TouchEvent} ev Event.\n * @return {void}\n */\nfunction _handleTouchAction(ev) {\n  let t = ev.changedTouches[0];\n  let type = ev.type;\n  if (type === 'touchstart') {\n    POINTERSTATE.touch.x = t.clientX;\n    POINTERSTATE.touch.y = t.clientY;\n    POINTERSTATE.touch.scrollDecided = false;\n  } else if (type === 'touchmove') {\n    if (POINTERSTATE.touch.scrollDecided) {\n      return;\n    }\n    POINTERSTATE.touch.scrollDecided = true;\n    let ta = firstTouchAction(ev);\n    let shouldPrevent = false;\n    let dx = Math.abs(POINTERSTATE.touch.x - t.clientX);\n    let dy = Math.abs(POINTERSTATE.touch.y - t.clientY);\n    if (!ev.cancelable) {\n      // scrolling is happening\n    } else if (ta === 'none') {\n      shouldPrevent = true;\n    } else if (ta === 'pan-x') {\n      shouldPrevent = dy > dx;\n    } else if (ta === 'pan-y') {\n      shouldPrevent = dx > dy;\n    }\n    if (shouldPrevent) {\n      ev.preventDefault();\n    } else {\n      prevent('track');\n    }\n  }\n}\n\n/**\n * Adds an event listener to a node for the given gesture type.\n *\n * @param {!EventTarget} node Node to add listener on\n * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`\n * @param {!function(!Event):void} handler Event listener function to call\n * @return {boolean} Returns true if a gesture event listener was added.\n */\nexport function addListener(node, evType, handler) {\n  if (gestures[evType]) {\n    _add(node, evType, handler);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Removes an event listener from a node for the given gesture type.\n *\n * @param {!EventTarget} node Node to remove listener from\n * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`\n * @param {!function(!Event):void} handler Event listener function previously passed to\n *  `addListener`.\n * @return {boolean} Returns true if a gesture event listener was removed.\n */\nexport function removeListener(node, evType, handler) {\n  if (gestures[evType]) {\n    _remove(node, evType, handler);\n    return true;\n  }\n  return false;\n}\n\n/**\n * automate the event listeners for the native events\n *\n * @private\n * @param {!EventTarget} node Node on which to add the event.\n * @param {string} evType Event type to add.\n * @param {function(!Event)} handler Event handler function.\n * @return {void}\n */\nfunction _add(node, evType, handler) {\n  let recognizer = gestures[evType];\n  let deps = recognizer.deps;\n  let name = recognizer.name;\n  let gobj = node[GESTURE_KEY];\n  if (!gobj) {\n    node[GESTURE_KEY] = gobj = {};\n  }\n  for (let i = 0, dep, gd; i < deps.length; i++) {\n    dep = deps[i];\n    // don't add mouse handlers on iOS because they cause gray selection overlays\n    if (IS_TOUCH_ONLY && isMouseEvent(dep) && dep !== 'click') {\n      continue;\n    }\n    gd = gobj[dep];\n    if (!gd) {\n      gobj[dep] = gd = {\n        _count: 0\n      };\n    }\n    if (gd._count === 0) {\n      node.addEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));\n    }\n    gd[name] = (gd[name] || 0) + 1;\n    gd._count = (gd._count || 0) + 1;\n  }\n  node.addEventListener(evType, handler);\n  if (recognizer.touchAction) {\n    setTouchAction(node, recognizer.touchAction);\n  }\n}\n\n/**\n * automate event listener removal for native events\n *\n * @private\n * @param {!EventTarget} node Node on which to remove the event.\n * @param {string} evType Event type to remove.\n * @param {function(!Event): void} handler Event handler function.\n * @return {void}\n */\nfunction _remove(node, evType, handler) {\n  let recognizer = gestures[evType];\n  let deps = recognizer.deps;\n  let name = recognizer.name;\n  let gobj = node[GESTURE_KEY];\n  if (gobj) {\n    for (let i = 0, dep, gd; i < deps.length; i++) {\n      dep = deps[i];\n      gd = gobj[dep];\n      if (gd && gd[name]) {\n        gd[name] = (gd[name] || 1) - 1;\n        gd._count = (gd._count || 1) - 1;\n        if (gd._count === 0) {\n          node.removeEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));\n        }\n      }\n    }\n  }\n  node.removeEventListener(evType, handler);\n}\n\n/**\n * Registers a new gesture event recognizer for adding new custom\n * gesture event types.\n *\n * @param {!GestureRecognizer} recog Gesture recognizer descriptor\n * @return {void}\n */\nexport function register(recog) {\n  recognizers.push(recog);\n  for (let i = 0; i < recog.emits.length; i++) {\n    gestures[recog.emits[i]] = recog;\n  }\n}\n\n/**\n * @private\n * @param {string} evName Event name.\n * @return {Object} Returns the gesture for the given event name.\n */\nfunction _findRecognizerByEvent(evName) {\n  for (let i = 0, r; i < recognizers.length; i++) {\n    r = recognizers[i];\n    for (let j = 0, n; j < r.emits.length; j++) {\n      n = r.emits[j];\n      if (n === evName) {\n        return r;\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Sets scrolling direction on node.\n *\n * This value is checked on first move, thus it should be called prior to\n * adding event listeners.\n *\n * @param {!EventTarget} node Node to set touch action setting on\n * @param {string} value Touch action value\n * @return {void}\n */\nexport function setTouchAction(node, value) {\n  if (HAS_NATIVE_TA && node instanceof HTMLElement) {\n    // NOTE: add touchAction async so that events can be added in\n    // custom element constructors. Otherwise we run afoul of custom\n    // elements restriction against settings attributes (style) in the\n    // constructor.\n    microTask.run(() => {\n      node.style.touchAction = value;\n    });\n  }\n  node[TOUCH_ACTION] = value;\n}\n\n/**\n * Dispatches an event on the `target` element of `type` with the given\n * `detail`.\n * @private\n * @param {!EventTarget} target The element on which to fire an event.\n * @param {string} type The type of event to fire.\n * @param {!Object=} detail The detail object to populate on the event.\n * @return {void}\n */\nfunction _fire(target, type, detail) {\n  let ev = new Event(type, {\n    bubbles: true,\n    cancelable: true,\n    composed: true\n  });\n  ev.detail = detail;\n  wrap( /** @type {!Node} */target).dispatchEvent(ev);\n  // forward `preventDefault` in a clean way\n  if (ev.defaultPrevented) {\n    let preventer = detail.preventer || detail.sourceEvent;\n    if (preventer && preventer.preventDefault) {\n      preventer.preventDefault();\n    }\n  }\n}\n\n/**\n * Prevents the dispatch and default action of the given event name.\n *\n * @param {string} evName Event name.\n * @return {void}\n */\nexport function prevent(evName) {\n  let recognizer = _findRecognizerByEvent(evName);\n  if (recognizer.info) {\n    recognizer.info.prevent = true;\n  }\n}\n\n/**\n * Reset the 2500ms timeout on processing mouse input after detecting touch input.\n *\n * Touch inputs create synthesized mouse inputs anywhere from 0 to 2000ms after the touch.\n * This method should only be called during testing with simulated touch inputs.\n * Calling this method in production may cause duplicate taps or other Gestures.\n *\n * @return {void}\n */\nexport function resetMouseCanceller() {\n  if (POINTERSTATE.mouse.mouseIgnoreJob) {\n    POINTERSTATE.mouse.mouseIgnoreJob.flush();\n  }\n}\n\n/* eslint-disable valid-jsdoc */\n\nregister({\n  name: 'downup',\n  deps: ['mousedown', 'touchstart', 'touchend'],\n  flow: {\n    start: ['mousedown', 'touchstart'],\n    end: ['mouseup', 'touchend']\n  },\n  emits: ['down', 'up'],\n  info: {\n    movefn: null,\n    upfn: null\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @return {void}\n   */\n  reset: function () {\n    untrackDocument(this.info);\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   * @return {void}\n   */\n  mousedown: function (e) {\n    if (!hasLeftMouseButton(e)) {\n      return;\n    }\n    let t = _findOriginalTarget(e);\n    let self = this;\n    let movefn = function movefn(e) {\n      if (!hasLeftMouseButton(e)) {\n        downupFire('up', t, e);\n        untrackDocument(self.info);\n      }\n    };\n    let upfn = function upfn(e) {\n      if (hasLeftMouseButton(e)) {\n        downupFire('up', t, e);\n      }\n      untrackDocument(self.info);\n    };\n    trackDocument(this.info, movefn, upfn);\n    downupFire('down', t, e);\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchstart: function (e) {\n    downupFire('down', _findOriginalTarget(e), e.changedTouches[0], e);\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchend: function (e) {\n    downupFire('up', _findOriginalTarget(e), e.changedTouches[0], e);\n  }\n});\n\n/**\n * @param {string} type\n * @param {EventTarget} target\n * @param {Event|Touch} event\n * @param {Event=} preventer\n * @return {void}\n */\nfunction downupFire(type, target, event, preventer) {\n  if (!target) {\n    return;\n  }\n  _fire(target, type, {\n    x: event.clientX,\n    y: event.clientY,\n    sourceEvent: event,\n    preventer: preventer,\n    prevent: function (e) {\n      return prevent(e);\n    }\n  });\n}\nregister({\n  name: 'track',\n  touchAction: 'none',\n  deps: ['mousedown', 'touchstart', 'touchmove', 'touchend'],\n  flow: {\n    start: ['mousedown', 'touchstart'],\n    end: ['mouseup', 'touchend']\n  },\n  emits: ['track'],\n  info: {\n    x: 0,\n    y: 0,\n    state: 'start',\n    started: false,\n    moves: [],\n    /** @this {GestureInfo} */\n    addMove: function (move) {\n      if (this.moves.length > TRACK_LENGTH) {\n        this.moves.shift();\n      }\n      this.moves.push(move);\n    },\n    movefn: null,\n    upfn: null,\n    prevent: false\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @return {void}\n   */\n  reset: function () {\n    this.info.state = 'start';\n    this.info.started = false;\n    this.info.moves = [];\n    this.info.x = 0;\n    this.info.y = 0;\n    this.info.prevent = false;\n    untrackDocument(this.info);\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   * @return {void}\n   */\n  mousedown: function (e) {\n    if (!hasLeftMouseButton(e)) {\n      return;\n    }\n    let t = _findOriginalTarget(e);\n    let self = this;\n    let movefn = function movefn(e) {\n      let x = e.clientX,\n        y = e.clientY;\n      if (trackHasMovedEnough(self.info, x, y)) {\n        // first move is 'start', subsequent moves are 'move', mouseup is 'end'\n        self.info.state = self.info.started ? e.type === 'mouseup' ? 'end' : 'track' : 'start';\n        if (self.info.state === 'start') {\n          // if and only if tracking, always prevent tap\n          prevent('tap');\n        }\n        self.info.addMove({\n          x: x,\n          y: y\n        });\n        if (!hasLeftMouseButton(e)) {\n          // always fire \"end\"\n          self.info.state = 'end';\n          untrackDocument(self.info);\n        }\n        if (t) {\n          trackFire(self.info, t, e);\n        }\n        self.info.started = true;\n      }\n    };\n    let upfn = function upfn(e) {\n      if (self.info.started) {\n        movefn(e);\n      }\n\n      // remove the temporary listeners\n      untrackDocument(self.info);\n    };\n    // add temporary document listeners as mouse retargets\n    trackDocument(this.info, movefn, upfn);\n    this.info.x = e.clientX;\n    this.info.y = e.clientY;\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchstart: function (e) {\n    let ct = e.changedTouches[0];\n    this.info.x = ct.clientX;\n    this.info.y = ct.clientY;\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchmove: function (e) {\n    let t = _findOriginalTarget(e);\n    let ct = e.changedTouches[0];\n    let x = ct.clientX,\n      y = ct.clientY;\n    if (trackHasMovedEnough(this.info, x, y)) {\n      if (this.info.state === 'start') {\n        // if and only if tracking, always prevent tap\n        prevent('tap');\n      }\n      this.info.addMove({\n        x: x,\n        y: y\n      });\n      trackFire(this.info, t, ct);\n      this.info.state = 'track';\n      this.info.started = true;\n    }\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchend: function (e) {\n    let t = _findOriginalTarget(e);\n    let ct = e.changedTouches[0];\n    // only trackend if track was started and not aborted\n    if (this.info.started) {\n      // reset started state on up\n      this.info.state = 'end';\n      this.info.addMove({\n        x: ct.clientX,\n        y: ct.clientY\n      });\n      trackFire(this.info, t, ct);\n    }\n  }\n});\n\n/**\n * @param {!GestureInfo} info\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nfunction trackHasMovedEnough(info, x, y) {\n  if (info.prevent) {\n    return false;\n  }\n  if (info.started) {\n    return true;\n  }\n  let dx = Math.abs(info.x - x);\n  let dy = Math.abs(info.y - y);\n  return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;\n}\n\n/**\n * @param {!GestureInfo} info\n * @param {?EventTarget} target\n * @param {Touch} touch\n * @return {void}\n */\nfunction trackFire(info, target, touch) {\n  if (!target) {\n    return;\n  }\n  let secondlast = info.moves[info.moves.length - 2];\n  let lastmove = info.moves[info.moves.length - 1];\n  let dx = lastmove.x - info.x;\n  let dy = lastmove.y - info.y;\n  let ddx,\n    ddy = 0;\n  if (secondlast) {\n    ddx = lastmove.x - secondlast.x;\n    ddy = lastmove.y - secondlast.y;\n  }\n  _fire(target, 'track', {\n    state: info.state,\n    x: touch.clientX,\n    y: touch.clientY,\n    dx: dx,\n    dy: dy,\n    ddx: ddx,\n    ddy: ddy,\n    sourceEvent: touch,\n    hover: function () {\n      return deepTargetFind(touch.clientX, touch.clientY);\n    }\n  });\n}\nregister({\n  name: 'tap',\n  deps: ['mousedown', 'click', 'touchstart', 'touchend'],\n  flow: {\n    start: ['mousedown', 'touchstart'],\n    end: ['click', 'touchend']\n  },\n  emits: ['tap'],\n  info: {\n    x: NaN,\n    y: NaN,\n    prevent: false\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @return {void}\n   */\n  reset: function () {\n    this.info.x = NaN;\n    this.info.y = NaN;\n    this.info.prevent = false;\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   * @return {void}\n   */\n  mousedown: function (e) {\n    if (hasLeftMouseButton(e)) {\n      this.info.x = e.clientX;\n      this.info.y = e.clientY;\n    }\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   * @return {void}\n   */\n  click: function (e) {\n    if (hasLeftMouseButton(e)) {\n      trackForward(this.info, e);\n    }\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchstart: function (e) {\n    const touch = e.changedTouches[0];\n    this.info.x = touch.clientX;\n    this.info.y = touch.clientY;\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchend: function (e) {\n    trackForward(this.info, e.changedTouches[0], e);\n  }\n});\n\n/**\n * @param {!GestureInfo} info\n * @param {Event | Touch} e\n * @param {Event=} preventer\n * @return {void}\n */\nfunction trackForward(info, e, preventer) {\n  let dx = Math.abs(e.clientX - info.x);\n  let dy = Math.abs(e.clientY - info.y);\n  // find original target from `preventer` for TouchEvents, or `e` for MouseEvents\n  let t = _findOriginalTarget(preventer || e);\n  if (!t || canBeDisabled[/** @type {!HTMLElement} */t.localName] && t.hasAttribute('disabled')) {\n    return;\n  }\n  // dx,dy can be NaN if `click` has been simulated and there was no `down` for `start`\n  if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e)) {\n    // prevent taps from being generated if an event has canceled them\n    if (!info.prevent) {\n      _fire(t, 'tap', {\n        x: e.clientX,\n        y: e.clientY,\n        sourceEvent: e,\n        preventer: preventer\n      });\n    }\n  }\n}\n\n/* eslint-enable valid-jsdoc */\n\n/** @deprecated */\nexport const findOriginalTarget = _findOriginalTarget;\n\n/** @deprecated */\nexport const add = addListener;\n\n/** @deprecated */\nexport const remove = removeListener;","map":{"version":3,"names":["timeOut","microTask","Debouncer","passiveTouchGestures","wrap","HAS_NATIVE_TA","document","head","style","touchAction","GESTURE_KEY","HANDLED_OBJ","TOUCH_ACTION","TAP_DISTANCE","TRACK_DISTANCE","TRACK_LENGTH","MOUSE_TIMEOUT","MOUSE_EVENTS","MOUSE_WHICH_TO_BUTTONS","MOUSE_HAS_BUTTONS","MouseEvent","buttons","e","isMouseEvent","name","indexOf","SUPPORTS_PASSIVE","opts","Object","defineProperty","get","window","addEventListener","removeEventListener","PASSIVE_TOUCH","eventName","passive","IS_TOUCH_ONLY","navigator","userAgent","match","clickedLabels","labellable","canBeDisabled","canBeLabelled","el","localName","matchingLabels","labels","Array","prototype","slice","call","length","root","getRootNode","id","matching","querySelectorAll","i","push","mouseCanceller","mouseEvent","sc","sourceCapabilities","firesTouchEvents","skip","type","clickFromLabel","path","getComposedPath","nodeType","Node","ELEMENT_NODE","ownerLabels","j","POINTERSTATE","mouse","target","preventDefault","stopPropagation","setupTeardownMouseCanceller","setup","events","en","ignoreMouse","mouseIgnoreJob","unset","debounce","after","hasLeftMouseButton","ev","undefined","which","Boolean","button","isSyntheticClick","detail","t","_findOriginalTarget","bcr","getBoundingClientRect","x","pageX","y","pageY","left","right","top","bottom","touch","scrollDecided","firstTouchAction","ta","n","trackDocument","stateObj","movefn","upfn","untrackDocument","ShadyDOM","noPatch","composedPath","event","gestures","recognizers","deepTargetFind","node","elementFromPoint","next","shadowRoot","oldNext","_handleNative","handled","currentTarget","gobj","gs","changedTouches","touches","identifier","_handleTouchAction","r","flow","start","reset","clientX","clientY","shouldPrevent","dx","Math","abs","dy","cancelable","prevent","addListener","evType","handler","_add","removeListener","_remove","recognizer","deps","dep","gd","_count","setTouchAction","register","recog","emits","_findRecognizerByEvent","evName","value","HTMLElement","run","_fire","Event","bubbles","composed","dispatchEvent","defaultPrevented","preventer","sourceEvent","info","resetMouseCanceller","flush","end","mousedown","self","downupFire","touchstart","touchend","state","started","moves","addMove","move","shift","trackHasMovedEnough","trackFire","ct","touchmove","secondlast","lastmove","ddx","ddy","hover","NaN","click","trackForward","hasAttribute","isNaN","findOriginalTarget","add","remove"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@polymer/polymer/lib/utils/gestures.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * @fileoverview\n *\n * Module for adding listeners to a node for the following normalized\n * cross-platform \"gesture\" events:\n * - `down` - mouse or touch went down\n * - `up` - mouse or touch went up\n * - `tap` - mouse click or finger tap\n * - `track` - mouse drag or touch move\n *\n * @summary Module for adding cross-platform gesture event listeners.\n */\n\nimport './boot.js';\n\nimport { timeOut, microTask } from './async.js';\nimport { Debouncer } from './debounce.js';\nimport { passiveTouchGestures } from './settings.js';\nimport { wrap } from './wrap.js';\n\n// detect native touch action support\nlet HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';\nlet GESTURE_KEY = '__polymerGestures';\nlet HANDLED_OBJ = '__polymerGesturesHandled';\nlet TOUCH_ACTION = '__polymerGesturesTouchAction';\n// radius for tap and track\nlet TAP_DISTANCE = 25;\nlet TRACK_DISTANCE = 5;\n// number of last N track positions to keep\nlet TRACK_LENGTH = 2;\n\n// Disabling \"mouse\" handlers for 2500ms is enough\nlet MOUSE_TIMEOUT = 2500;\nlet MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'click'];\n// an array of bitmask values for mapping MouseEvent.which to MouseEvent.buttons\nlet MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];\nlet MOUSE_HAS_BUTTONS = (function() {\n  try {\n    return new MouseEvent('test', {buttons: 1}).buttons === 1;\n  } catch (e) {\n    return false;\n  }\n})();\n\n/**\n * @param {string} name Possible mouse event name\n * @return {boolean} true if mouse event, false if not\n */\nfunction isMouseEvent(name) {\n  return MOUSE_EVENTS.indexOf(name) > -1;\n}\n\n/* eslint no-empty: [\"error\", { \"allowEmptyCatch\": true }] */\n// check for passive event listeners\nlet SUPPORTS_PASSIVE = false;\n(function() {\n  try {\n    let opts = Object.defineProperty({}, 'passive', {get() {SUPPORTS_PASSIVE = true;}});\n    window.addEventListener('test', null, opts);\n    window.removeEventListener('test', null, opts);\n  } catch(e) {}\n})();\n\n/**\n * Generate settings for event listeners, dependant on `passiveTouchGestures`\n *\n * @param {string} eventName Event name to determine if `{passive}` option is\n *   needed\n * @return {{passive: boolean} | undefined} Options to use for addEventListener\n *   and removeEventListener\n */\nfunction PASSIVE_TOUCH(eventName) {\n  if (isMouseEvent(eventName) || eventName === 'touchend') {\n    return;\n  }\n  if (HAS_NATIVE_TA && SUPPORTS_PASSIVE && passiveTouchGestures) {\n    return {passive: true};\n  } else {\n    return;\n  }\n}\n\n// Check for touch-only devices\nlet IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);\n\n// keep track of any labels hit by the mouseCanceller\n/** @type {!Array<!HTMLLabelElement>} */\nconst clickedLabels = [];\n\n/** @type {!Object<boolean>} */\nconst labellable = {\n  'button': true,\n  'input': true,\n  'keygen': true,\n  'meter': true,\n  'output': true,\n  'textarea': true,\n  'progress': true,\n  'select': true\n};\n\n// Defined at https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#enabling-and-disabling-form-controls:-the-disabled-attribute\n/** @type {!Object<boolean>} */\nconst canBeDisabled = {\n  'button': true,\n  'command': true,\n  'fieldset': true,\n  'input': true,\n  'keygen': true,\n  'optgroup': true,\n  'option': true,\n  'select': true,\n  'textarea': true\n};\n\n/**\n * @param {HTMLElement} el Element to check labelling status\n * @return {boolean} element can have labels\n */\nfunction canBeLabelled(el) {\n  return labellable[el.localName] || false;\n}\n\n/**\n * @param {HTMLElement} el Element that may be labelled.\n * @return {!Array<!HTMLLabelElement>} Relevant label for `el`\n */\nfunction matchingLabels(el) {\n  let labels = Array.prototype.slice.call(/** @type {HTMLInputElement} */(el).labels || []);\n  // IE doesn't have `labels` and Safari doesn't populate `labels`\n  // if element is in a shadowroot.\n  // In this instance, finding the non-ancestor labels is enough,\n  // as the mouseCancellor code will handle ancstor labels\n  if (!labels.length) {\n    labels = [];\n    let root = el.getRootNode();\n    // if there is an id on `el`, check for all labels with a matching `for` attribute\n    if (el.id) {\n      let matching = root.querySelectorAll(`label[for = ${el.id}]`);\n      for (let i = 0; i < matching.length; i++) {\n        labels.push(/** @type {!HTMLLabelElement} */(matching[i]));\n      }\n    }\n  }\n  return labels;\n}\n\n// touch will make synthetic mouse events\n// `preventDefault` on touchend will cancel them,\n// but this breaks `<input>` focus and link clicks\n// disable mouse handlers for MOUSE_TIMEOUT ms after\n// a touchend to ignore synthetic mouse events\nlet mouseCanceller = function(mouseEvent) {\n  // Check for sourceCapabilities, used to distinguish synthetic events\n  // if mouseEvent did not come from a device that fires touch events,\n  // it was made by a real mouse and should be counted\n  // http://wicg.github.io/InputDeviceCapabilities/#dom-inputdevicecapabilities-firestouchevents\n  let sc = mouseEvent.sourceCapabilities;\n  if (sc && !sc.firesTouchEvents) {\n    return;\n  }\n  // skip synthetic mouse events\n  mouseEvent[HANDLED_OBJ] = {skip: true};\n  // disable \"ghost clicks\"\n  if (mouseEvent.type === 'click') {\n    let clickFromLabel = false;\n    let path = getComposedPath(mouseEvent);\n    for (let i = 0; i < path.length; i++) {\n      if (path[i].nodeType === Node.ELEMENT_NODE) {\n        if (path[i].localName === 'label') {\n          clickedLabels.push(/** @type {!HTMLLabelElement} */ (path[i]));\n        } else if (canBeLabelled(/** @type {!HTMLElement} */ (path[i]))) {\n          let ownerLabels =\n              matchingLabels(/** @type {!HTMLElement} */ (path[i]));\n          // check if one of the clicked labels is labelling this element\n          for (let j = 0; j < ownerLabels.length; j++) {\n            clickFromLabel = clickFromLabel || clickedLabels.indexOf(ownerLabels[j]) > -1;\n          }\n        }\n      }\n      if (path[i] === POINTERSTATE.mouse.target) {\n        return;\n      }\n    }\n    // if one of the clicked labels was labelling the target element,\n    // this is not a ghost click\n    if (clickFromLabel) {\n      return;\n    }\n    mouseEvent.preventDefault();\n    mouseEvent.stopPropagation();\n  }\n};\n\n/**\n * @param {boolean=} setup True to add, false to remove.\n * @return {void}\n */\nfunction setupTeardownMouseCanceller(setup) {\n  let events = IS_TOUCH_ONLY ? ['click'] : MOUSE_EVENTS;\n  for (let i = 0, en; i < events.length; i++) {\n    en = events[i];\n    if (setup) {\n      // reset clickLabels array\n      clickedLabels.length = 0;\n      document.addEventListener(en, mouseCanceller, true);\n    } else {\n      document.removeEventListener(en, mouseCanceller, true);\n    }\n  }\n}\n\nfunction ignoreMouse(e) {\n  if (!POINTERSTATE.mouse.mouseIgnoreJob) {\n    setupTeardownMouseCanceller(true);\n  }\n  let unset = function() {\n    setupTeardownMouseCanceller();\n    POINTERSTATE.mouse.target = null;\n    POINTERSTATE.mouse.mouseIgnoreJob = null;\n  };\n  POINTERSTATE.mouse.target = getComposedPath(e)[0];\n  POINTERSTATE.mouse.mouseIgnoreJob = Debouncer.debounce(\n        POINTERSTATE.mouse.mouseIgnoreJob\n      , timeOut.after(MOUSE_TIMEOUT)\n      , unset);\n}\n\n/**\n * @param {MouseEvent} ev event to test for left mouse button down\n * @return {boolean} has left mouse button down\n */\nfunction hasLeftMouseButton(ev) {\n  let type = ev.type;\n  // exit early if the event is not a mouse event\n  if (!isMouseEvent(type)) {\n    return false;\n  }\n  // ev.button is not reliable for mousemove (0 is overloaded as both left button and no buttons)\n  // instead we use ev.buttons (bitmask of buttons) or fall back to ev.which (deprecated, 0 for no buttons, 1 for left button)\n  if (type === 'mousemove') {\n    // allow undefined for testing events\n    let buttons = ev.buttons === undefined ? 1 : ev.buttons;\n    if ((ev instanceof window.MouseEvent) && !MOUSE_HAS_BUTTONS) {\n      buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;\n    }\n    // buttons is a bitmask, check that the left button bit is set (1)\n    return Boolean(buttons & 1);\n  } else {\n    // allow undefined for testing events\n    let button = ev.button === undefined ? 0 : ev.button;\n    // ev.button is 0 in mousedown/mouseup/click for left button activation\n    return button === 0;\n  }\n}\n\nfunction isSyntheticClick(ev) {\n  if (ev.type === 'click') {\n    // ev.detail is 0 for HTMLElement.click in most browsers\n    if (ev.detail === 0) {\n      return true;\n    }\n    // in the worst case, check that the x/y position of the click is within\n    // the bounding box of the target of the event\n    // Thanks IE 10 >:(\n    let t = _findOriginalTarget(ev);\n    // make sure the target of the event is an element so we can use getBoundingClientRect,\n    // if not, just assume it is a synthetic click\n    if (!t.nodeType || /** @type {Element} */(t).nodeType !== Node.ELEMENT_NODE) {\n      return true;\n    }\n    let bcr = /** @type {Element} */(t).getBoundingClientRect();\n    // use page x/y to account for scrolling\n    let x = ev.pageX, y = ev.pageY;\n    // ev is a synthetic click if the position is outside the bounding box of the target\n    return !((x >= bcr.left && x <= bcr.right) && (y >= bcr.top && y <= bcr.bottom));\n  }\n  return false;\n}\n\nlet POINTERSTATE = {\n  mouse: {\n    target: null,\n    mouseIgnoreJob: null\n  },\n  touch: {\n    x: 0,\n    y: 0,\n    id: -1,\n    scrollDecided: false\n  }\n};\n\nfunction firstTouchAction(ev) {\n  let ta = 'auto';\n  let path = getComposedPath(ev);\n  for (let i = 0, n; i < path.length; i++) {\n    n = path[i];\n    if (n[TOUCH_ACTION]) {\n      ta = n[TOUCH_ACTION];\n      break;\n    }\n  }\n  return ta;\n}\n\nfunction trackDocument(stateObj, movefn, upfn) {\n  stateObj.movefn = movefn;\n  stateObj.upfn = upfn;\n  document.addEventListener('mousemove', movefn);\n  document.addEventListener('mouseup', upfn);\n}\n\nfunction untrackDocument(stateObj) {\n  document.removeEventListener('mousemove', stateObj.movefn);\n  document.removeEventListener('mouseup', stateObj.upfn);\n  stateObj.movefn = null;\n  stateObj.upfn = null;\n}\n\n// use a document-wide touchend listener to start the ghost-click prevention mechanism\n// Use passive event listeners, if supported, to not affect scrolling performance\ndocument.addEventListener('touchend', ignoreMouse, SUPPORTS_PASSIVE ? {passive: true} : false);\n\n/**\n * Returns the composedPath for the given event.\n * @param {Event} event to process\n * @return {!Array<!EventTarget>} Path of the event\n */\nconst getComposedPath = window.ShadyDOM && window.ShadyDOM.noPatch ?\n  window.ShadyDOM.composedPath :\n  (event) => event.composedPath && event.composedPath() || [];\n\n/** @type {!Object<string, !GestureRecognizer>} */\nexport const gestures = {};\n\n/** @type {!Array<!GestureRecognizer>} */\nexport const recognizers = [];\n\n/**\n * Finds the element rendered on the screen at the provided coordinates.\n *\n * Similar to `document.elementFromPoint`, but pierces through\n * shadow roots.\n *\n * @param {number} x Horizontal pixel coordinate\n * @param {number} y Vertical pixel coordinate\n * @return {Element} Returns the deepest shadowRoot inclusive element\n * found at the screen position given.\n */\nexport function deepTargetFind(x, y) {\n  let node = document.elementFromPoint(x, y);\n  let next = node;\n  // this code path is only taken when native ShadowDOM is used\n  // if there is a shadowroot, it may have a node at x/y\n  // if there is not a shadowroot, exit the loop\n  while (next && next.shadowRoot && !window.ShadyDOM) {\n    // if there is a node at x/y in the shadowroot, look deeper\n    let oldNext = next;\n    next = next.shadowRoot.elementFromPoint(x, y);\n    // on Safari, elementFromPoint may return the shadowRoot host\n    if (oldNext === next) {\n      break;\n    }\n    if (next) {\n      node = next;\n    }\n  }\n  return node;\n}\n\n/**\n * a cheaper check than ev.composedPath()[0];\n *\n * @private\n * @param {Event|Touch} ev Event.\n * @return {EventTarget} Returns the event target.\n */\nfunction _findOriginalTarget(ev) {\n  const path = getComposedPath(/** @type {?Event} */ (ev));\n  // It shouldn't be, but sometimes path is empty (window on Safari).\n  return path.length > 0 ? path[0] : ev.target;\n}\n\n/**\n * @private\n * @param {Event} ev Event.\n * @return {void}\n */\nfunction _handleNative(ev) {\n  let handled;\n  let type = ev.type;\n  let node = ev.currentTarget;\n  let gobj = node[GESTURE_KEY];\n  if (!gobj) {\n    return;\n  }\n  let gs = gobj[type];\n  if (!gs) {\n    return;\n  }\n  if (!ev[HANDLED_OBJ]) {\n    ev[HANDLED_OBJ] = {};\n    if (type.slice(0, 5) === 'touch') {\n      ev = /** @type {TouchEvent} */(ev); // eslint-disable-line no-self-assign\n      let t = ev.changedTouches[0];\n      if (type === 'touchstart') {\n        // only handle the first finger\n        if (ev.touches.length === 1) {\n          POINTERSTATE.touch.id = t.identifier;\n        }\n      }\n      if (POINTERSTATE.touch.id !== t.identifier) {\n        return;\n      }\n      if (!HAS_NATIVE_TA) {\n        if (type === 'touchstart' || type === 'touchmove') {\n          _handleTouchAction(ev);\n        }\n      }\n    }\n  }\n  handled = ev[HANDLED_OBJ];\n  // used to ignore synthetic mouse events\n  if (handled.skip) {\n    return;\n  }\n  // reset recognizer state\n  for (let i = 0, r; i < recognizers.length; i++) {\n    r = recognizers[i];\n    if (gs[r.name] && !handled[r.name]) {\n      if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {\n        r.reset();\n      }\n    }\n  }\n  // enforce gesture recognizer order\n  for (let i = 0, r; i < recognizers.length; i++) {\n    r = recognizers[i];\n    if (gs[r.name] && !handled[r.name]) {\n      handled[r.name] = true;\n      r[type](ev);\n    }\n  }\n}\n\n/**\n * @private\n * @param {TouchEvent} ev Event.\n * @return {void}\n */\nfunction _handleTouchAction(ev) {\n  let t = ev.changedTouches[0];\n  let type = ev.type;\n  if (type === 'touchstart') {\n    POINTERSTATE.touch.x = t.clientX;\n    POINTERSTATE.touch.y = t.clientY;\n    POINTERSTATE.touch.scrollDecided = false;\n  } else if (type === 'touchmove') {\n    if (POINTERSTATE.touch.scrollDecided) {\n      return;\n    }\n    POINTERSTATE.touch.scrollDecided = true;\n    let ta = firstTouchAction(ev);\n    let shouldPrevent = false;\n    let dx = Math.abs(POINTERSTATE.touch.x - t.clientX);\n    let dy = Math.abs(POINTERSTATE.touch.y - t.clientY);\n    if (!ev.cancelable) {\n      // scrolling is happening\n    } else if (ta === 'none') {\n      shouldPrevent = true;\n    } else if (ta === 'pan-x') {\n      shouldPrevent = dy > dx;\n    } else if (ta === 'pan-y') {\n      shouldPrevent = dx > dy;\n    }\n    if (shouldPrevent) {\n      ev.preventDefault();\n    } else {\n      prevent('track');\n    }\n  }\n}\n\n/**\n * Adds an event listener to a node for the given gesture type.\n *\n * @param {!EventTarget} node Node to add listener on\n * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`\n * @param {!function(!Event):void} handler Event listener function to call\n * @return {boolean} Returns true if a gesture event listener was added.\n */\nexport function addListener(node, evType, handler) {\n  if (gestures[evType]) {\n    _add(node, evType, handler);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Removes an event listener from a node for the given gesture type.\n *\n * @param {!EventTarget} node Node to remove listener from\n * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`\n * @param {!function(!Event):void} handler Event listener function previously passed to\n *  `addListener`.\n * @return {boolean} Returns true if a gesture event listener was removed.\n */\nexport function removeListener(node, evType, handler) {\n  if (gestures[evType]) {\n    _remove(node, evType, handler);\n    return true;\n  }\n  return false;\n}\n\n/**\n * automate the event listeners for the native events\n *\n * @private\n * @param {!EventTarget} node Node on which to add the event.\n * @param {string} evType Event type to add.\n * @param {function(!Event)} handler Event handler function.\n * @return {void}\n */\nfunction _add(node, evType, handler) {\n  let recognizer = gestures[evType];\n  let deps = recognizer.deps;\n  let name = recognizer.name;\n  let gobj = node[GESTURE_KEY];\n  if (!gobj) {\n    node[GESTURE_KEY] = gobj = {};\n  }\n  for (let i = 0, dep, gd; i < deps.length; i++) {\n    dep = deps[i];\n    // don't add mouse handlers on iOS because they cause gray selection overlays\n    if (IS_TOUCH_ONLY && isMouseEvent(dep) && dep !== 'click') {\n      continue;\n    }\n    gd = gobj[dep];\n    if (!gd) {\n      gobj[dep] = gd = {_count: 0};\n    }\n    if (gd._count === 0) {\n      node.addEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));\n    }\n    gd[name] = (gd[name] || 0) + 1;\n    gd._count = (gd._count || 0) + 1;\n  }\n  node.addEventListener(evType, handler);\n  if (recognizer.touchAction) {\n    setTouchAction(node, recognizer.touchAction);\n  }\n}\n\n/**\n * automate event listener removal for native events\n *\n * @private\n * @param {!EventTarget} node Node on which to remove the event.\n * @param {string} evType Event type to remove.\n * @param {function(!Event): void} handler Event handler function.\n * @return {void}\n */\nfunction _remove(node, evType, handler) {\n  let recognizer = gestures[evType];\n  let deps = recognizer.deps;\n  let name = recognizer.name;\n  let gobj = node[GESTURE_KEY];\n  if (gobj) {\n    for (let i = 0, dep, gd; i < deps.length; i++) {\n      dep = deps[i];\n      gd = gobj[dep];\n      if (gd && gd[name]) {\n        gd[name] = (gd[name] || 1) - 1;\n        gd._count = (gd._count || 1) - 1;\n        if (gd._count === 0) {\n          node.removeEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));\n        }\n      }\n    }\n  }\n  node.removeEventListener(evType, handler);\n}\n\n/**\n * Registers a new gesture event recognizer for adding new custom\n * gesture event types.\n *\n * @param {!GestureRecognizer} recog Gesture recognizer descriptor\n * @return {void}\n */\nexport function register(recog) {\n  recognizers.push(recog);\n  for (let i = 0; i < recog.emits.length; i++) {\n    gestures[recog.emits[i]] = recog;\n  }\n}\n\n/**\n * @private\n * @param {string} evName Event name.\n * @return {Object} Returns the gesture for the given event name.\n */\nfunction _findRecognizerByEvent(evName) {\n  for (let i = 0, r; i < recognizers.length; i++) {\n    r = recognizers[i];\n    for (let j = 0, n; j < r.emits.length; j++) {\n      n = r.emits[j];\n      if (n === evName) {\n        return r;\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Sets scrolling direction on node.\n *\n * This value is checked on first move, thus it should be called prior to\n * adding event listeners.\n *\n * @param {!EventTarget} node Node to set touch action setting on\n * @param {string} value Touch action value\n * @return {void}\n */\nexport function setTouchAction(node, value) {\n  if (HAS_NATIVE_TA && node instanceof HTMLElement) {\n    // NOTE: add touchAction async so that events can be added in\n    // custom element constructors. Otherwise we run afoul of custom\n    // elements restriction against settings attributes (style) in the\n    // constructor.\n    microTask.run(() => {\n      node.style.touchAction = value;\n    });\n  }\n  node[TOUCH_ACTION] = value;\n}\n\n/**\n * Dispatches an event on the `target` element of `type` with the given\n * `detail`.\n * @private\n * @param {!EventTarget} target The element on which to fire an event.\n * @param {string} type The type of event to fire.\n * @param {!Object=} detail The detail object to populate on the event.\n * @return {void}\n */\nfunction _fire(target, type, detail) {\n  let ev = new Event(type, { bubbles: true, cancelable: true, composed: true });\n  ev.detail = detail;\n  wrap(/** @type {!Node} */(target)).dispatchEvent(ev);\n  // forward `preventDefault` in a clean way\n  if (ev.defaultPrevented) {\n    let preventer = detail.preventer || detail.sourceEvent;\n    if (preventer && preventer.preventDefault) {\n      preventer.preventDefault();\n    }\n  }\n}\n\n/**\n * Prevents the dispatch and default action of the given event name.\n *\n * @param {string} evName Event name.\n * @return {void}\n */\nexport function prevent(evName) {\n  let recognizer = _findRecognizerByEvent(evName);\n  if (recognizer.info) {\n    recognizer.info.prevent = true;\n  }\n}\n\n/**\n * Reset the 2500ms timeout on processing mouse input after detecting touch input.\n *\n * Touch inputs create synthesized mouse inputs anywhere from 0 to 2000ms after the touch.\n * This method should only be called during testing with simulated touch inputs.\n * Calling this method in production may cause duplicate taps or other Gestures.\n *\n * @return {void}\n */\nexport function resetMouseCanceller() {\n  if (POINTERSTATE.mouse.mouseIgnoreJob) {\n    POINTERSTATE.mouse.mouseIgnoreJob.flush();\n  }\n}\n\n/* eslint-disable valid-jsdoc */\n\nregister({\n  name: 'downup',\n  deps: ['mousedown', 'touchstart', 'touchend'],\n  flow: {\n    start: ['mousedown', 'touchstart'],\n    end: ['mouseup', 'touchend']\n  },\n  emits: ['down', 'up'],\n\n  info: {\n    movefn: null,\n    upfn: null\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @return {void}\n   */\n  reset: function() {\n    untrackDocument(this.info);\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   * @return {void}\n   */\n  mousedown: function(e) {\n    if (!hasLeftMouseButton(e)) {\n      return;\n    }\n    let t = _findOriginalTarget(e);\n    let self = this;\n    let movefn = function movefn(e) {\n      if (!hasLeftMouseButton(e)) {\n        downupFire('up', t, e);\n        untrackDocument(self.info);\n      }\n    };\n    let upfn = function upfn(e) {\n      if (hasLeftMouseButton(e)) {\n        downupFire('up', t, e);\n      }\n      untrackDocument(self.info);\n    };\n    trackDocument(this.info, movefn, upfn);\n    downupFire('down', t, e);\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchstart: function(e) {\n    downupFire('down', _findOriginalTarget(e), e.changedTouches[0], e);\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchend: function(e) {\n    downupFire('up', _findOriginalTarget(e), e.changedTouches[0], e);\n  }\n});\n\n/**\n * @param {string} type\n * @param {EventTarget} target\n * @param {Event|Touch} event\n * @param {Event=} preventer\n * @return {void}\n */\nfunction downupFire(type, target, event, preventer) {\n  if (!target) {\n    return;\n  }\n  _fire(target, type, {\n    x: event.clientX,\n    y: event.clientY,\n    sourceEvent: event,\n    preventer: preventer,\n    prevent: function(e) {\n      return prevent(e);\n    }\n  });\n}\n\nregister({\n  name: 'track',\n  touchAction: 'none',\n  deps: ['mousedown', 'touchstart', 'touchmove', 'touchend'],\n  flow: {\n    start: ['mousedown', 'touchstart'],\n    end: ['mouseup', 'touchend']\n  },\n  emits: ['track'],\n\n  info: {\n    x: 0,\n    y: 0,\n    state: 'start',\n    started: false,\n    moves: [],\n    /** @this {GestureInfo} */\n    addMove: function(move) {\n      if (this.moves.length > TRACK_LENGTH) {\n        this.moves.shift();\n      }\n      this.moves.push(move);\n    },\n    movefn: null,\n    upfn: null,\n    prevent: false\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @return {void}\n   */\n  reset: function() {\n    this.info.state = 'start';\n    this.info.started = false;\n    this.info.moves = [];\n    this.info.x = 0;\n    this.info.y = 0;\n    this.info.prevent = false;\n    untrackDocument(this.info);\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   * @return {void}\n   */\n  mousedown: function(e) {\n    if (!hasLeftMouseButton(e)) {\n      return;\n    }\n    let t = _findOriginalTarget(e);\n    let self = this;\n    let movefn = function movefn(e) {\n      let x = e.clientX, y = e.clientY;\n      if (trackHasMovedEnough(self.info, x, y)) {\n        // first move is 'start', subsequent moves are 'move', mouseup is 'end'\n        self.info.state = self.info.started ? (e.type === 'mouseup' ? 'end' : 'track') : 'start';\n        if (self.info.state === 'start') {\n          // if and only if tracking, always prevent tap\n          prevent('tap');\n        }\n        self.info.addMove({x: x, y: y});\n        if (!hasLeftMouseButton(e)) {\n          // always fire \"end\"\n          self.info.state = 'end';\n          untrackDocument(self.info);\n        }\n        if (t) {\n          trackFire(self.info, t, e);\n        }\n        self.info.started = true;\n      }\n    };\n    let upfn = function upfn(e) {\n      if (self.info.started) {\n        movefn(e);\n      }\n\n      // remove the temporary listeners\n      untrackDocument(self.info);\n    };\n    // add temporary document listeners as mouse retargets\n    trackDocument(this.info, movefn, upfn);\n    this.info.x = e.clientX;\n    this.info.y = e.clientY;\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchstart: function(e) {\n    let ct = e.changedTouches[0];\n    this.info.x = ct.clientX;\n    this.info.y = ct.clientY;\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchmove: function(e) {\n    let t = _findOriginalTarget(e);\n    let ct = e.changedTouches[0];\n    let x = ct.clientX, y = ct.clientY;\n    if (trackHasMovedEnough(this.info, x, y)) {\n      if (this.info.state === 'start') {\n        // if and only if tracking, always prevent tap\n        prevent('tap');\n      }\n      this.info.addMove({x: x, y: y});\n      trackFire(this.info, t, ct);\n      this.info.state = 'track';\n      this.info.started = true;\n    }\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchend: function(e) {\n    let t = _findOriginalTarget(e);\n    let ct = e.changedTouches[0];\n    // only trackend if track was started and not aborted\n    if (this.info.started) {\n      // reset started state on up\n      this.info.state = 'end';\n      this.info.addMove({x: ct.clientX, y: ct.clientY});\n      trackFire(this.info, t, ct);\n    }\n  }\n});\n\n/**\n * @param {!GestureInfo} info\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nfunction trackHasMovedEnough(info, x, y) {\n  if (info.prevent) {\n    return false;\n  }\n  if (info.started) {\n    return true;\n  }\n  let dx = Math.abs(info.x - x);\n  let dy = Math.abs(info.y - y);\n  return (dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE);\n}\n\n/**\n * @param {!GestureInfo} info\n * @param {?EventTarget} target\n * @param {Touch} touch\n * @return {void}\n */\nfunction trackFire(info, target, touch) {\n  if (!target) {\n    return;\n  }\n  let secondlast = info.moves[info.moves.length - 2];\n  let lastmove = info.moves[info.moves.length - 1];\n  let dx = lastmove.x - info.x;\n  let dy = lastmove.y - info.y;\n  let ddx, ddy = 0;\n  if (secondlast) {\n    ddx = lastmove.x - secondlast.x;\n    ddy = lastmove.y - secondlast.y;\n  }\n  _fire(target, 'track', {\n    state: info.state,\n    x: touch.clientX,\n    y: touch.clientY,\n    dx: dx,\n    dy: dy,\n    ddx: ddx,\n    ddy: ddy,\n    sourceEvent: touch,\n    hover: function() {\n      return deepTargetFind(touch.clientX, touch.clientY);\n    }\n  });\n}\n\nregister({\n  name: 'tap',\n  deps: ['mousedown', 'click', 'touchstart', 'touchend'],\n  flow: {\n    start: ['mousedown', 'touchstart'],\n    end: ['click', 'touchend']\n  },\n  emits: ['tap'],\n  info: {\n    x: NaN,\n    y: NaN,\n    prevent: false\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @return {void}\n   */\n  reset: function() {\n    this.info.x = NaN;\n    this.info.y = NaN;\n    this.info.prevent = false;\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   * @return {void}\n   */\n  mousedown: function(e) {\n    if (hasLeftMouseButton(e)) {\n      this.info.x = e.clientX;\n      this.info.y = e.clientY;\n    }\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   * @return {void}\n   */\n  click: function(e) {\n    if (hasLeftMouseButton(e)) {\n      trackForward(this.info, e);\n    }\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchstart: function(e) {\n    const touch = e.changedTouches[0];\n    this.info.x = touch.clientX;\n    this.info.y = touch.clientY;\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchend: function(e) {\n    trackForward(this.info, e.changedTouches[0], e);\n  }\n});\n\n/**\n * @param {!GestureInfo} info\n * @param {Event | Touch} e\n * @param {Event=} preventer\n * @return {void}\n */\nfunction trackForward(info, e, preventer) {\n  let dx = Math.abs(e.clientX - info.x);\n  let dy = Math.abs(e.clientY - info.y);\n  // find original target from `preventer` for TouchEvents, or `e` for MouseEvents\n  let t = _findOriginalTarget((preventer || e));\n  if (!t || (canBeDisabled[/** @type {!HTMLElement} */(t).localName] && t.hasAttribute('disabled'))) {\n    return;\n  }\n  // dx,dy can be NaN if `click` has been simulated and there was no `down` for `start`\n  if (isNaN(dx) || isNaN(dy) || (dx <= TAP_DISTANCE && dy <= TAP_DISTANCE) || isSyntheticClick(e)) {\n    // prevent taps from being generated if an event has canceled them\n    if (!info.prevent) {\n      _fire(t, 'tap', {\n        x: e.clientX,\n        y: e.clientY,\n        sourceEvent: e,\n        preventer: preventer\n      });\n    }\n  }\n}\n\n/* eslint-enable valid-jsdoc */\n\n/** @deprecated */\nexport const findOriginalTarget = _findOriginalTarget;\n\n/** @deprecated */\nexport const add = addListener;\n\n/** @deprecated */\nexport const remove = removeListener;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}