{"ast":null,"code":"/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '../utils/boot.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nconst walker = document.createTreeWalker(document, NodeFilter.SHOW_ALL, null, false);\n\n// 1.x backwards-compatible auto-wrapper for template type extensions\n// This is a clear layering violation and gives favored-nation status to\n// dom-if and dom-repeat templates.  This is a conceit we're choosing to keep\n// a.) to ease 1.x backwards-compatibility due to loss of `is`, and\n// b.) to maintain if/repeat capability in parser-constrained elements\n//     (e.g. table, select) in lieu of native CE type extensions without\n//     massive new invention in this space (e.g. directive system)\nconst templateExtensions = {\n  'dom-if': true,\n  'dom-repeat': true\n};\nfunction wrapTemplateExtension(node) {\n  let is = node.getAttribute('is');\n  if (is && templateExtensions[is]) {\n    let t = node;\n    t.removeAttribute('is');\n    node = t.ownerDocument.createElement(is);\n    t.parentNode.replaceChild(node, t);\n    node.appendChild(t);\n    while (t.attributes.length) {\n      node.setAttribute(t.attributes[0].name, t.attributes[0].value);\n      t.removeAttribute(t.attributes[0].name);\n    }\n  }\n  return node;\n}\nfunction findTemplateNode(root, nodeInfo) {\n  // recursively ascend tree until we hit root\n  let parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);\n  // unwind the stack, returning the indexed node at each level\n  if (parent) {\n    // note: marginally faster than indexing via childNodes\n    // (http://jsperf.com/childnodes-lookup)\n    walker.currentNode = parent;\n    for (let n = walker.firstChild(), i = 0; n; n = walker.nextSibling()) {\n      if (nodeInfo.parentIndex === i++) {\n        return n;\n      }\n    }\n  } else {\n    return root;\n  }\n}\n\n// construct `$` map (from id annotations)\nfunction applyIdToMap(inst, map, node, nodeInfo) {\n  if (nodeInfo.id) {\n    map[nodeInfo.id] = node;\n  }\n}\n\n// install event listeners (from event annotations)\nfunction applyEventListener(inst, node, nodeInfo) {\n  if (nodeInfo.events && nodeInfo.events.length) {\n    for (let j = 0, e$ = nodeInfo.events, e; j < e$.length && (e = e$[j]); j++) {\n      inst._addMethodEventListenerToNode(node, e.name, e.value, inst);\n    }\n  }\n}\n\n// push configuration references at configure time\nfunction applyTemplateContent(inst, node, nodeInfo) {\n  if (nodeInfo.templateInfo) {\n    node._templateInfo = nodeInfo.templateInfo;\n  }\n}\nfunction createNodeEventHandler(context, eventName, methodName) {\n  // Instances can optionally have a _methodHost which allows redirecting where\n  // to find methods. Currently used by `templatize`.\n  context = context._methodHost || context;\n  let handler = function (e) {\n    if (context[methodName]) {\n      context[methodName](e, e.detail);\n    } else {\n      console.warn('listener method `' + methodName + '` not defined');\n    }\n  };\n  return handler;\n}\n\n/**\n * Element mixin that provides basic template parsing and stamping, including\n * the following template-related features for stamped templates:\n *\n * - Declarative event listeners (`on-eventname=\"listener\"`)\n * - Map of node id's to stamped node instances (`this.$.id`)\n * - Nested template content caching/removal and re-installation (performance\n *   optimization)\n *\n * @mixinFunction\n * @polymer\n * @summary Element class mixin that provides basic template parsing and stamping\n */\nexport const TemplateStamp = dedupingMixin(\n/**\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nsuperClass => {\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_TemplateStamp}\n   */\n  class TemplateStamp extends superClass {\n    /**\n     * Scans a template to produce template metadata.\n     *\n     * Template-specific metadata are stored in the object returned, and node-\n     * specific metadata are stored in objects in its flattened `nodeInfoList`\n     * array.  Only nodes in the template that were parsed as nodes of\n     * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object\n     * contains an `index` (`childNodes` index in parent) and optionally\n     * `parent`, which points to node info of its parent (including its index).\n     *\n     * The template metadata object returned from this method has the following\n     * structure (many fields optional):\n     *\n     * ```js\n     *   {\n     *     // Flattened list of node metadata (for nodes that generated metadata)\n     *     nodeInfoList: [\n     *       {\n     *         // `id` attribute for any nodes with id's for generating `$` map\n     *         id: {string},\n     *         // `on-event=\"handler\"` metadata\n     *         events: [\n     *           {\n     *             name: {string},   // event name\n     *             value: {string},  // handler method name\n     *           }, ...\n     *         ],\n     *         // Notes when the template contained a `<slot>` for shady DOM\n     *         // optimization purposes\n     *         hasInsertionPoint: {boolean},\n     *         // For nested `<template>`` nodes, nested template metadata\n     *         templateInfo: {object}, // nested template metadata\n     *         // Metadata to allow efficient retrieval of instanced node\n     *         // corresponding to this metadata\n     *         parentInfo: {number},   // reference to parent nodeInfo>\n     *         parentIndex: {number},  // index in parent's `childNodes` collection\n     *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`\n     *       },\n     *       ...\n     *     ],\n     *     // When true, the template had the `strip-whitespace` attribute\n     *     // or was nested in a template with that setting\n     *     stripWhitespace: {boolean},\n     *     // For nested templates, nested template content is moved into\n     *     // a document fragment stored here; this is an optimization to\n     *     // avoid the cost of nested template cloning\n     *     content: {DocumentFragment}\n     *   }\n     * ```\n     *\n     * This method kicks off a recursive treewalk as follows:\n     *\n     * ```\n     *    _parseTemplate <---------------------+\n     *      _parseTemplateContent              |\n     *        _parseTemplateNode  <------------|--+\n     *          _parseTemplateNestedTemplate --+  |\n     *          _parseTemplateChildNodes ---------+\n     *          _parseTemplateNodeAttributes\n     *            _parseTemplateNodeAttribute\n     *\n     * ```\n     *\n     * These methods may be overridden to add custom metadata about templates\n     * to either `templateInfo` or `nodeInfo`.\n     *\n     * Note that this method may be destructive to the template, in that\n     * e.g. event annotations may be removed after being noted in the\n     * template metadata.\n     *\n     * @param {!HTMLTemplateElement} template Template to parse\n     * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer\n     *   template, for parsing nested templates\n     * @return {!TemplateInfo} Parsed template metadata\n     */\n    static _parseTemplate(template, outerTemplateInfo) {\n      // since a template may be re-used, memo-ize metadata\n      if (!template._templateInfo) {\n        let templateInfo = template._templateInfo = {};\n        templateInfo.nodeInfoList = [];\n        templateInfo.stripWhiteSpace = outerTemplateInfo && outerTemplateInfo.stripWhiteSpace || template.hasAttribute('strip-whitespace');\n        this._parseTemplateContent(template, templateInfo, {\n          parent: null\n        });\n      }\n      return template._templateInfo;\n    }\n    static _parseTemplateContent(template, templateInfo, nodeInfo) {\n      return this._parseTemplateNode(template.content, templateInfo, nodeInfo);\n    }\n\n    /**\n     * Parses template node and adds template and node metadata based on\n     * the current node, and its `childNodes` and `attributes`.\n     *\n     * This method may be overridden to add custom node or template specific\n     * metadata based on this node.\n     *\n     * @param {Node} node Node to parse\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     */\n    static _parseTemplateNode(node, templateInfo, nodeInfo) {\n      let noted;\n      let element = /** @type {Element} */node;\n      if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {\n        noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;\n      } else if (element.localName === 'slot') {\n        // For ShadyDom optimization, indicating there is an insertion point\n        templateInfo.hasInsertionPoint = true;\n      }\n      walker.currentNode = element;\n      if (walker.firstChild()) {\n        noted = this._parseTemplateChildNodes(element, templateInfo, nodeInfo) || noted;\n      }\n      if (element.hasAttributes && element.hasAttributes()) {\n        noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;\n      }\n      return noted;\n    }\n\n    /**\n     * Parses template child nodes for the given root node.\n     *\n     * This method also wraps whitelisted legacy template extensions\n     * (`is=\"dom-if\"` and `is=\"dom-repeat\"`) with their equivalent element\n     * wrappers, collapses text nodes, and strips whitespace from the template\n     * if the `templateInfo.stripWhitespace` setting was provided.\n     *\n     * @param {Node} root Root node whose `childNodes` will be parsed\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {void}\n     */\n    static _parseTemplateChildNodes(root, templateInfo, nodeInfo) {\n      if (root.localName === 'script' || root.localName === 'style') {\n        return;\n      }\n      walker.currentNode = root;\n      for (let node = walker.firstChild(), parentIndex = 0, next; node; node = next) {\n        // Wrap templates\n        if (node.localName == 'template') {\n          node = wrapTemplateExtension(node);\n        }\n        // collapse adjacent textNodes: fixes an IE issue that can cause\n        // text nodes to be inexplicably split =(\n        // note that root.normalize() should work but does not so we do this\n        // manually.\n        walker.currentNode = node;\n        next = walker.nextSibling();\n        if (node.nodeType === Node.TEXT_NODE) {\n          let /** Node */n = next;\n          while (n && n.nodeType === Node.TEXT_NODE) {\n            node.textContent += n.textContent;\n            next = walker.nextSibling();\n            root.removeChild(n);\n            n = next;\n          }\n          // optionally strip whitespace\n          if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {\n            root.removeChild(node);\n            continue;\n          }\n        }\n        let childInfo = {\n          parentIndex,\n          parentInfo: nodeInfo\n        };\n        if (this._parseTemplateNode(node, templateInfo, childInfo)) {\n          childInfo.infoIndex = templateInfo.nodeInfoList.push( /** @type {!NodeInfo} */childInfo) - 1;\n        }\n        // Increment if not removed\n        walker.currentNode = node;\n        if (walker.parentNode()) {\n          parentIndex++;\n        }\n      }\n    }\n\n    /**\n     * Parses template content for the given nested `<template>`.\n     *\n     * Nested template info is stored as `templateInfo` in the current node's\n     * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.\n     * It will then be the responsibility of the host to set it back to the\n     * template and for users stamping nested templates to use the\n     * `_contentForTemplate` method to retrieve the content for this template\n     * (an optimization to avoid the cost of cloning nested template content).\n     *\n     * @param {HTMLTemplateElement} node Node to parse (a <template>)\n     * @param {TemplateInfo} outerTemplateInfo Template metadata for current template\n     *   that includes the template `node`\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     */\n    static _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {\n      let templateInfo = this._parseTemplate(node, outerTemplateInfo);\n      let content = templateInfo.content = node.content.ownerDocument.createDocumentFragment();\n      content.appendChild(node.content);\n      nodeInfo.templateInfo = templateInfo;\n      return true;\n    }\n\n    /**\n     * Parses template node attributes and adds node metadata to `nodeInfo`\n     * for nodes of interest.\n     *\n     * @param {Element} node Node to parse\n     * @param {TemplateInfo} templateInfo Template metadata for current template\n     * @param {NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     */\n    static _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {\n      // Make copy of original attribute list, since the order may change\n      // as attributes are added and removed\n      let noted = false;\n      let attrs = Array.from(node.attributes);\n      for (let i = attrs.length - 1, a; a = attrs[i]; i--) {\n        noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;\n      }\n      return noted;\n    }\n\n    /**\n     * Parses a single template node attribute and adds node metadata to\n     * `nodeInfo` for attributes of interest.\n     *\n     * This implementation adds metadata for `on-event=\"handler\"` attributes\n     * and `id` attributes.\n     *\n     * @param {Element} node Node to parse\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @param {string} name Attribute name\n     * @param {string} value Attribute value\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     */\n    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\n      // events (on-*)\n      if (name.slice(0, 3) === 'on-') {\n        node.removeAttribute(name);\n        nodeInfo.events = nodeInfo.events || [];\n        nodeInfo.events.push({\n          name: name.slice(3),\n          value\n        });\n        return true;\n      }\n      // static id\n      else if (name === 'id') {\n        nodeInfo.id = value;\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Returns the `content` document fragment for a given template.\n     *\n     * For nested templates, Polymer performs an optimization to cache nested\n     * template content to avoid the cost of cloning deeply nested templates.\n     * This method retrieves the cached content for a given template.\n     *\n     * @param {HTMLTemplateElement} template Template to retrieve `content` for\n     * @return {DocumentFragment} Content fragment\n     */\n    static _contentForTemplate(template) {\n      let templateInfo = /** @type {HTMLTemplateElementWithInfo} */template._templateInfo;\n      return templateInfo && templateInfo.content || template.content;\n    }\n\n    /**\n     * Clones the provided template content and returns a document fragment\n     * containing the cloned dom.\n     *\n     * The template is parsed (once and memoized) using this library's\n     * template parsing features, and provides the following value-added\n     * features:\n     * * Adds declarative event listeners for `on-event=\"handler\"` attributes\n     * * Generates an \"id map\" for all nodes with id's under `$` on returned\n     *   document fragment\n     * * Passes template info including `content` back to templates as\n     *   `_templateInfo` (a performance optimization to avoid deep template\n     *   cloning)\n     *\n     * Note that the memoized template parsing process is destructive to the\n     * template: attributes for bindings and declarative event listeners are\n     * removed after being noted in notes, and any nested `<template>.content`\n     * is removed and stored in notes as well.\n     *\n     * @param {!HTMLTemplateElement} template Template to stamp\n     * @return {!StampedTemplate} Cloned template content\n     * @override\n     */\n    _stampTemplate(template) {\n      // Polyfill support: bootstrap the template if it has not already been\n      if (template && !template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {\n        HTMLTemplateElement.decorate(template);\n      }\n      let templateInfo = this.constructor._parseTemplate(template);\n      let nodeInfo = templateInfo.nodeInfoList;\n      let content = templateInfo.content || template.content;\n      let dom = /** @type {DocumentFragment} */document.importNode(content, true);\n      // NOTE: ShadyDom optimization indicating there is an insertion point\n      dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;\n      let nodes = dom.nodeList = new Array(nodeInfo.length);\n      dom.$ = {};\n      for (let i = 0, l = nodeInfo.length, info; i < l && (info = nodeInfo[i]); i++) {\n        let node = nodes[i] = findTemplateNode(dom, info);\n        applyIdToMap(this, dom.$, node, info);\n        applyTemplateContent(this, node, info);\n        applyEventListener(this, node, info);\n      }\n      dom = /** @type {!StampedTemplate} */dom; // eslint-disable-line no-self-assign\n      return dom;\n    }\n\n    /**\n     * Adds an event listener by method name for the event provided.\n     *\n     * This method generates a handler function that looks up the method\n     * name at handling time.\n     *\n     * @param {!EventTarget} node Node to add listener on\n     * @param {string} eventName Name of event\n     * @param {string} methodName Name of method\n     * @param {*=} context Context the method will be called on (defaults\n     *   to `node`)\n     * @return {Function} Generated handler function\n     * @override\n     */\n    _addMethodEventListenerToNode(node, eventName, methodName, context) {\n      context = context || node;\n      let handler = createNodeEventHandler(context, eventName, methodName);\n      this._addEventListenerToNode(node, eventName, handler);\n      return handler;\n    }\n\n    /**\n     * Override point for adding custom or simulated event handling.\n     *\n     * @param {!EventTarget} node Node to add event listener to\n     * @param {string} eventName Name of event\n     * @param {function(!Event):void} handler Listener function to add\n     * @return {void}\n     * @override\n     */\n    _addEventListenerToNode(node, eventName, handler) {\n      node.addEventListener(eventName, handler);\n    }\n\n    /**\n     * Override point for adding custom or simulated event handling.\n     *\n     * @param {!EventTarget} node Node to remove event listener from\n     * @param {string} eventName Name of event\n     * @param {function(!Event):void} handler Listener function to remove\n     * @return {void}\n     * @override\n     */\n    _removeEventListenerFromNode(node, eventName, handler) {\n      node.removeEventListener(eventName, handler);\n    }\n  }\n  return TemplateStamp;\n});","map":{"version":3,"names":["dedupingMixin","walker","document","createTreeWalker","NodeFilter","SHOW_ALL","templateExtensions","wrapTemplateExtension","node","is","getAttribute","t","removeAttribute","ownerDocument","createElement","parentNode","replaceChild","appendChild","attributes","length","setAttribute","name","value","findTemplateNode","root","nodeInfo","parent","parentInfo","currentNode","n","firstChild","i","nextSibling","parentIndex","applyIdToMap","inst","map","id","applyEventListener","events","j","e$","e","_addMethodEventListenerToNode","applyTemplateContent","templateInfo","_templateInfo","createNodeEventHandler","context","eventName","methodName","_methodHost","handler","detail","console","warn","TemplateStamp","superClass","_parseTemplate","template","outerTemplateInfo","nodeInfoList","stripWhiteSpace","hasAttribute","_parseTemplateContent","_parseTemplateNode","content","noted","element","localName","_parseTemplateNestedTemplate","hasInsertionPoint","_parseTemplateChildNodes","hasAttributes","_parseTemplateNodeAttributes","next","nodeType","Node","TEXT_NODE","textContent","removeChild","trim","childInfo","infoIndex","push","createDocumentFragment","attrs","Array","from","a","_parseTemplateNodeAttribute","slice","_contentForTemplate","_stampTemplate","window","HTMLTemplateElement","decorate","constructor","dom","importNode","__noInsertionPoint","nodes","nodeList","$","l","info","_addEventListenerToNode","addEventListener","_removeEventListenerFromNode","removeEventListener"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@polymer/polymer/lib/mixins/template-stamp.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '../utils/boot.js';\n\nimport { dedupingMixin } from '../utils/mixin.js';\n\nconst walker = document.createTreeWalker(document, NodeFilter.SHOW_ALL,\n    null, false);\n\n// 1.x backwards-compatible auto-wrapper for template type extensions\n// This is a clear layering violation and gives favored-nation status to\n// dom-if and dom-repeat templates.  This is a conceit we're choosing to keep\n// a.) to ease 1.x backwards-compatibility due to loss of `is`, and\n// b.) to maintain if/repeat capability in parser-constrained elements\n//     (e.g. table, select) in lieu of native CE type extensions without\n//     massive new invention in this space (e.g. directive system)\nconst templateExtensions = {\n  'dom-if': true,\n  'dom-repeat': true\n};\nfunction wrapTemplateExtension(node) {\n  let is = node.getAttribute('is');\n  if (is && templateExtensions[is]) {\n    let t = node;\n    t.removeAttribute('is');\n    node = t.ownerDocument.createElement(is);\n    t.parentNode.replaceChild(node, t);\n    node.appendChild(t);\n    while(t.attributes.length) {\n      node.setAttribute(t.attributes[0].name, t.attributes[0].value);\n      t.removeAttribute(t.attributes[0].name);\n    }\n  }\n  return node;\n}\n\nfunction findTemplateNode(root, nodeInfo) {\n  // recursively ascend tree until we hit root\n  let parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);\n  // unwind the stack, returning the indexed node at each level\n  if (parent) {\n    // note: marginally faster than indexing via childNodes\n    // (http://jsperf.com/childnodes-lookup)\n    walker.currentNode = parent;\n    for (let n=walker.firstChild(), i=0; n; n=walker.nextSibling()) {\n      if (nodeInfo.parentIndex === i++) {\n        return n;\n      }\n    }\n  } else {\n    return root;\n  }\n}\n\n// construct `$` map (from id annotations)\nfunction applyIdToMap(inst, map, node, nodeInfo) {\n  if (nodeInfo.id) {\n    map[nodeInfo.id] = node;\n  }\n}\n\n// install event listeners (from event annotations)\nfunction applyEventListener(inst, node, nodeInfo) {\n  if (nodeInfo.events && nodeInfo.events.length) {\n    for (let j=0, e$=nodeInfo.events, e; (j<e$.length) && (e=e$[j]); j++) {\n      inst._addMethodEventListenerToNode(node, e.name, e.value, inst);\n    }\n  }\n}\n\n// push configuration references at configure time\nfunction applyTemplateContent(inst, node, nodeInfo) {\n  if (nodeInfo.templateInfo) {\n    node._templateInfo = nodeInfo.templateInfo;\n  }\n}\n\nfunction createNodeEventHandler(context, eventName, methodName) {\n  // Instances can optionally have a _methodHost which allows redirecting where\n  // to find methods. Currently used by `templatize`.\n  context = context._methodHost || context;\n  let handler = function(e) {\n    if (context[methodName]) {\n      context[methodName](e, e.detail);\n    } else {\n      console.warn('listener method `' + methodName + '` not defined');\n    }\n  };\n  return handler;\n}\n\n/**\n * Element mixin that provides basic template parsing and stamping, including\n * the following template-related features for stamped templates:\n *\n * - Declarative event listeners (`on-eventname=\"listener\"`)\n * - Map of node id's to stamped node instances (`this.$.id`)\n * - Nested template content caching/removal and re-installation (performance\n *   optimization)\n *\n * @mixinFunction\n * @polymer\n * @summary Element class mixin that provides basic template parsing and stamping\n */\nexport const TemplateStamp = dedupingMixin(\n    /**\n     * @template T\n     * @param {function(new:T)} superClass Class to apply mixin to.\n     * @return {function(new:T)} superClass with mixin applied.\n     */\n    (superClass) => {\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_TemplateStamp}\n   */\n  class TemplateStamp extends superClass {\n\n    /**\n     * Scans a template to produce template metadata.\n     *\n     * Template-specific metadata are stored in the object returned, and node-\n     * specific metadata are stored in objects in its flattened `nodeInfoList`\n     * array.  Only nodes in the template that were parsed as nodes of\n     * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object\n     * contains an `index` (`childNodes` index in parent) and optionally\n     * `parent`, which points to node info of its parent (including its index).\n     *\n     * The template metadata object returned from this method has the following\n     * structure (many fields optional):\n     *\n     * ```js\n     *   {\n     *     // Flattened list of node metadata (for nodes that generated metadata)\n     *     nodeInfoList: [\n     *       {\n     *         // `id` attribute for any nodes with id's for generating `$` map\n     *         id: {string},\n     *         // `on-event=\"handler\"` metadata\n     *         events: [\n     *           {\n     *             name: {string},   // event name\n     *             value: {string},  // handler method name\n     *           }, ...\n     *         ],\n     *         // Notes when the template contained a `<slot>` for shady DOM\n     *         // optimization purposes\n     *         hasInsertionPoint: {boolean},\n     *         // For nested `<template>`` nodes, nested template metadata\n     *         templateInfo: {object}, // nested template metadata\n     *         // Metadata to allow efficient retrieval of instanced node\n     *         // corresponding to this metadata\n     *         parentInfo: {number},   // reference to parent nodeInfo>\n     *         parentIndex: {number},  // index in parent's `childNodes` collection\n     *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`\n     *       },\n     *       ...\n     *     ],\n     *     // When true, the template had the `strip-whitespace` attribute\n     *     // or was nested in a template with that setting\n     *     stripWhitespace: {boolean},\n     *     // For nested templates, nested template content is moved into\n     *     // a document fragment stored here; this is an optimization to\n     *     // avoid the cost of nested template cloning\n     *     content: {DocumentFragment}\n     *   }\n     * ```\n     *\n     * This method kicks off a recursive treewalk as follows:\n     *\n     * ```\n     *    _parseTemplate <---------------------+\n     *      _parseTemplateContent              |\n     *        _parseTemplateNode  <------------|--+\n     *          _parseTemplateNestedTemplate --+  |\n     *          _parseTemplateChildNodes ---------+\n     *          _parseTemplateNodeAttributes\n     *            _parseTemplateNodeAttribute\n     *\n     * ```\n     *\n     * These methods may be overridden to add custom metadata about templates\n     * to either `templateInfo` or `nodeInfo`.\n     *\n     * Note that this method may be destructive to the template, in that\n     * e.g. event annotations may be removed after being noted in the\n     * template metadata.\n     *\n     * @param {!HTMLTemplateElement} template Template to parse\n     * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer\n     *   template, for parsing nested templates\n     * @return {!TemplateInfo} Parsed template metadata\n     */\n    static _parseTemplate(template, outerTemplateInfo) {\n      // since a template may be re-used, memo-ize metadata\n      if (!template._templateInfo) {\n        let templateInfo = template._templateInfo = {};\n        templateInfo.nodeInfoList = [];\n        templateInfo.stripWhiteSpace =\n          (outerTemplateInfo && outerTemplateInfo.stripWhiteSpace) ||\n          template.hasAttribute('strip-whitespace');\n        this._parseTemplateContent(template, templateInfo, {parent: null});\n      }\n      return template._templateInfo;\n    }\n\n    static _parseTemplateContent(template, templateInfo, nodeInfo) {\n      return this._parseTemplateNode(template.content, templateInfo, nodeInfo);\n    }\n\n    /**\n     * Parses template node and adds template and node metadata based on\n     * the current node, and its `childNodes` and `attributes`.\n     *\n     * This method may be overridden to add custom node or template specific\n     * metadata based on this node.\n     *\n     * @param {Node} node Node to parse\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     */\n    static _parseTemplateNode(node, templateInfo, nodeInfo) {\n      let noted;\n      let element = /** @type {Element} */(node);\n      if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {\n        noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;\n      } else if (element.localName === 'slot') {\n        // For ShadyDom optimization, indicating there is an insertion point\n        templateInfo.hasInsertionPoint = true;\n      }\n      walker.currentNode = element;\n      if (walker.firstChild()) {\n        noted = this._parseTemplateChildNodes(element, templateInfo, nodeInfo) || noted;\n      }\n      if (element.hasAttributes && element.hasAttributes()) {\n        noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;\n      }\n      return noted;\n    }\n\n    /**\n     * Parses template child nodes for the given root node.\n     *\n     * This method also wraps whitelisted legacy template extensions\n     * (`is=\"dom-if\"` and `is=\"dom-repeat\"`) with their equivalent element\n     * wrappers, collapses text nodes, and strips whitespace from the template\n     * if the `templateInfo.stripWhitespace` setting was provided.\n     *\n     * @param {Node} root Root node whose `childNodes` will be parsed\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {void}\n     */\n    static _parseTemplateChildNodes(root, templateInfo, nodeInfo) {\n      if (root.localName === 'script' || root.localName === 'style') {\n        return;\n      }\n      walker.currentNode = root;\n      for (let node=walker.firstChild(), parentIndex=0, next; node; node=next) {\n        // Wrap templates\n        if (node.localName == 'template') {\n          node = wrapTemplateExtension(node);\n        }\n        // collapse adjacent textNodes: fixes an IE issue that can cause\n        // text nodes to be inexplicably split =(\n        // note that root.normalize() should work but does not so we do this\n        // manually.\n        walker.currentNode = node;\n        next = walker.nextSibling();\n        if (node.nodeType === Node.TEXT_NODE) {\n          let /** Node */ n = next;\n          while (n && (n.nodeType === Node.TEXT_NODE)) {\n            node.textContent += n.textContent;\n            next = walker.nextSibling();\n            root.removeChild(n);\n            n = next;\n          }\n          // optionally strip whitespace\n          if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {\n            root.removeChild(node);\n            continue;\n          }\n        }\n        let childInfo = { parentIndex, parentInfo: nodeInfo };\n        if (this._parseTemplateNode(node, templateInfo, childInfo)) {\n          childInfo.infoIndex = templateInfo.nodeInfoList.push(/** @type {!NodeInfo} */(childInfo)) - 1;\n        }\n        // Increment if not removed\n        walker.currentNode = node;\n        if (walker.parentNode()) {\n          parentIndex++;\n        }\n      }\n    }\n\n    /**\n     * Parses template content for the given nested `<template>`.\n     *\n     * Nested template info is stored as `templateInfo` in the current node's\n     * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.\n     * It will then be the responsibility of the host to set it back to the\n     * template and for users stamping nested templates to use the\n     * `_contentForTemplate` method to retrieve the content for this template\n     * (an optimization to avoid the cost of cloning nested template content).\n     *\n     * @param {HTMLTemplateElement} node Node to parse (a <template>)\n     * @param {TemplateInfo} outerTemplateInfo Template metadata for current template\n     *   that includes the template `node`\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     */\n    static _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {\n      let templateInfo = this._parseTemplate(node, outerTemplateInfo);\n      let content = templateInfo.content =\n        node.content.ownerDocument.createDocumentFragment();\n      content.appendChild(node.content);\n      nodeInfo.templateInfo = templateInfo;\n      return true;\n    }\n\n    /**\n     * Parses template node attributes and adds node metadata to `nodeInfo`\n     * for nodes of interest.\n     *\n     * @param {Element} node Node to parse\n     * @param {TemplateInfo} templateInfo Template metadata for current template\n     * @param {NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     */\n    static _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {\n      // Make copy of original attribute list, since the order may change\n      // as attributes are added and removed\n      let noted = false;\n      let attrs = Array.from(node.attributes);\n      for (let i=attrs.length-1, a; (a=attrs[i]); i--) {\n        noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;\n      }\n      return noted;\n    }\n\n    /**\n     * Parses a single template node attribute and adds node metadata to\n     * `nodeInfo` for attributes of interest.\n     *\n     * This implementation adds metadata for `on-event=\"handler\"` attributes\n     * and `id` attributes.\n     *\n     * @param {Element} node Node to parse\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @param {string} name Attribute name\n     * @param {string} value Attribute value\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     */\n    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\n      // events (on-*)\n      if (name.slice(0, 3) === 'on-') {\n        node.removeAttribute(name);\n        nodeInfo.events = nodeInfo.events || [];\n        nodeInfo.events.push({\n          name: name.slice(3),\n          value\n        });\n        return true;\n      }\n      // static id\n      else if (name === 'id') {\n        nodeInfo.id = value;\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Returns the `content` document fragment for a given template.\n     *\n     * For nested templates, Polymer performs an optimization to cache nested\n     * template content to avoid the cost of cloning deeply nested templates.\n     * This method retrieves the cached content for a given template.\n     *\n     * @param {HTMLTemplateElement} template Template to retrieve `content` for\n     * @return {DocumentFragment} Content fragment\n     */\n    static _contentForTemplate(template) {\n      let templateInfo = /** @type {HTMLTemplateElementWithInfo} */ (template)._templateInfo;\n      return (templateInfo && templateInfo.content) || template.content;\n    }\n\n    /**\n     * Clones the provided template content and returns a document fragment\n     * containing the cloned dom.\n     *\n     * The template is parsed (once and memoized) using this library's\n     * template parsing features, and provides the following value-added\n     * features:\n     * * Adds declarative event listeners for `on-event=\"handler\"` attributes\n     * * Generates an \"id map\" for all nodes with id's under `$` on returned\n     *   document fragment\n     * * Passes template info including `content` back to templates as\n     *   `_templateInfo` (a performance optimization to avoid deep template\n     *   cloning)\n     *\n     * Note that the memoized template parsing process is destructive to the\n     * template: attributes for bindings and declarative event listeners are\n     * removed after being noted in notes, and any nested `<template>.content`\n     * is removed and stored in notes as well.\n     *\n     * @param {!HTMLTemplateElement} template Template to stamp\n     * @return {!StampedTemplate} Cloned template content\n     * @override\n     */\n    _stampTemplate(template) {\n      // Polyfill support: bootstrap the template if it has not already been\n      if (template && !template.content &&\n          window.HTMLTemplateElement && HTMLTemplateElement.decorate) {\n        HTMLTemplateElement.decorate(template);\n      }\n      let templateInfo = this.constructor._parseTemplate(template);\n      let nodeInfo = templateInfo.nodeInfoList;\n      let content = templateInfo.content || template.content;\n      let dom = /** @type {DocumentFragment} */ (document.importNode(content, true));\n      // NOTE: ShadyDom optimization indicating there is an insertion point\n      dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;\n      let nodes = dom.nodeList = new Array(nodeInfo.length);\n      dom.$ = {};\n      for (let i=0, l=nodeInfo.length, info; (i<l) && (info=nodeInfo[i]); i++) {\n        let node = nodes[i] = findTemplateNode(dom, info);\n        applyIdToMap(this, dom.$, node, info);\n        applyTemplateContent(this, node, info);\n        applyEventListener(this, node, info);\n      }\n      dom = /** @type {!StampedTemplate} */(dom); // eslint-disable-line no-self-assign\n      return dom;\n    }\n\n    /**\n     * Adds an event listener by method name for the event provided.\n     *\n     * This method generates a handler function that looks up the method\n     * name at handling time.\n     *\n     * @param {!EventTarget} node Node to add listener on\n     * @param {string} eventName Name of event\n     * @param {string} methodName Name of method\n     * @param {*=} context Context the method will be called on (defaults\n     *   to `node`)\n     * @return {Function} Generated handler function\n     * @override\n     */\n    _addMethodEventListenerToNode(node, eventName, methodName, context) {\n      context = context || node;\n      let handler = createNodeEventHandler(context, eventName, methodName);\n      this._addEventListenerToNode(node, eventName, handler);\n      return handler;\n    }\n\n    /**\n     * Override point for adding custom or simulated event handling.\n     *\n     * @param {!EventTarget} node Node to add event listener to\n     * @param {string} eventName Name of event\n     * @param {function(!Event):void} handler Listener function to add\n     * @return {void}\n     * @override\n     */\n    _addEventListenerToNode(node, eventName, handler) {\n      node.addEventListener(eventName, handler);\n    }\n\n    /**\n     * Override point for adding custom or simulated event handling.\n     *\n     * @param {!EventTarget} node Node to remove event listener from\n     * @param {string} eventName Name of event\n     * @param {function(!Event):void} handler Listener function to remove\n     * @return {void}\n     * @override\n     */\n    _removeEventListenerFromNode(node, eventName, handler) {\n      node.removeEventListener(eventName, handler);\n    }\n\n  }\n\n  return TemplateStamp;\n\n});\n"],"mappings":"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,CAAC,CAACW,MAAM,CAAC;IAClC,CAAC,MAAM;MACLC,OAAO,CAACC,IAAI,CAAC,mBAAmB,GAAGL,UAAU,GAAG,eAAe,CAAC;IAClE;EACF,CAAC;EACD,OAAOE,OAAO;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMI,aAAa,GAAGxD,aAAa;AACtC;AACJ;AACA;AACA;AACA;AACKyD,UAAU,IAAK;EAElB;AACF;AACA;AACA;AACA;EACE,MAAMD,aAAa,SAASC,UAAU,CAAC;IAErC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,OAAOC,cAAcA,CAACC,QAAQ,EAAEC,iBAAiB,EAAE;MACjD;MACA,IAAI,CAACD,QAAQ,CAACb,aAAa,EAAE;QAC3B,IAAID,YAAY,GAAGc,QAAQ,CAACb,aAAa,GAAG,CAAC,CAAC;QAC9CD,YAAY,CAACgB,YAAY,GAAG,EAAE;QAC9BhB,YAAY,CAACiB,eAAe,GACzBF,iBAAiB,IAAIA,iBAAiB,CAACE,eAAe,IACvDH,QAAQ,CAACI,YAAY,CAAC,kBAAkB,CAAC;QAC3C,IAAI,CAACC,qBAAqB,CAACL,QAAQ,EAAEd,YAAY,EAAE;UAACnB,MAAM,EAAE;QAAI,CAAC,CAAC;MACpE;MACA,OAAOiC,QAAQ,CAACb,aAAa;IAC/B;IAEA,OAAOkB,qBAAqBA,CAACL,QAAQ,EAAEd,YAAY,EAAEpB,QAAQ,EAAE;MAC7D,OAAO,IAAI,CAACwC,kBA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"},"metadata":{},"sourceType":"module","externalDependencies":[]}