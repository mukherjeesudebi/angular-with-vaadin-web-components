{"ast":null,"code":"/**\n * @fileoverview\n * @suppress {checkPrototypalTypes}\n * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\nimport '../utils/boot.js';\nimport { rootPath, strictTemplatePolicy, allowTemplateFromDomModule, legacyOptimizations, syncInitialRender } from '../utils/settings.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nimport { stylesFromTemplate, stylesFromModuleImports } from '../utils/style-gather.js';\nimport { pathFromUrl, resolveCss, resolveUrl } from '../utils/resolve-url.js';\nimport { DomModule } from '../elements/dom-module.js';\nimport { PropertyEffects } from './property-effects.js';\nimport { PropertiesMixin } from './properties-mixin.js';\nimport { wrap } from '../utils/wrap.js';\n\n/**\n * Current Polymer version in Semver notation.\n * @type {string} Semver notation of the current version of Polymer.\n */\nexport const version = '3.2.0';\nconst builtCSS = window.ShadyCSS && window.ShadyCSS['cssBuild'];\n\n/**\n * Element class mixin that provides the core API for Polymer's meta-programming\n * features including template stamping, data-binding, attribute deserialization,\n * and property change observation.\n *\n * Subclassers may provide the following static getters to return metadata\n * used to configure Polymer's features for the class:\n *\n * - `static get is()`: When the template is provided via a `dom-module`,\n *   users should return the `dom-module` id from a static `is` getter.  If\n *   no template is needed or the template is provided directly via the\n *   `template` getter, there is no need to define `is` for the element.\n *\n * - `static get template()`: Users may provide the template directly (as\n *   opposed to via `dom-module`) by implementing a static `template` getter.\n *   The getter must return an `HTMLTemplateElement`.\n *\n * - `static get properties()`: Should return an object describing\n *   property-related metadata used by Polymer features (key: property name\n *   value: object containing property metadata). Valid keys in per-property\n *   metadata include:\n *   - `type` (String|Number|Object|Array|...): Used by\n *     `attributeChangedCallback` to determine how string-based attributes\n *     are deserialized to JavaScript property values.\n *   - `notify` (boolean): Causes a change in the property to fire a\n *     non-bubbling event called `<property>-changed`. Elements that have\n *     enabled two-way binding to the property use this event to observe changes.\n *   - `readOnly` (boolean): Creates a getter for the property, but no setter.\n *     To set a read-only property, use the private setter method\n *     `_setProperty(property, value)`.\n *   - `observer` (string): Observer method name that will be called when\n *     the property changes. The arguments of the method are\n *     `(value, previousValue)`.\n *   - `computed` (string): String describing method and dependent properties\n *     for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).\n *     Computed properties are read-only by default and can only be changed\n *     via the return value of the computing method.\n *\n * - `static get observers()`: Array of strings describing multi-property\n *   observer methods and their dependent properties (e.g.\n *   `'observeABC(a, b, c)'`).\n *\n * The base class provides default implementations for the following standard\n * custom element lifecycle callbacks; users may override these, but should\n * call the super method to ensure\n * - `constructor`: Run when the element is created or upgraded\n * - `connectedCallback`: Run each time the element is connected to the\n *   document\n * - `disconnectedCallback`: Run each time the element is disconnected from\n *   the document\n * - `attributeChangedCallback`: Run each time an attribute in\n *   `observedAttributes` is set or removed (note: this element's default\n *   `observedAttributes` implementation will automatically return an array\n *   of dash-cased attributes based on `properties`)\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin PropertyEffects\n * @appliesMixin PropertiesMixin\n * @property rootPath {string} Set to the value of `rootPath`,\n *   which defaults to the main document path\n * @property importPath {string} Set to the value of the class's static\n *   `importPath` property, which defaults to the path of this element's\n *   `dom-module` (when `is` is used), but can be overridden for other\n *   import strategies.\n * @summary Element class mixin that provides the core API for Polymer's\n * meta-programming features.\n */\nexport const ElementMixin = dedupingMixin(base => {\n  /**\n   * @constructor\n   * @implements {Polymer_PropertyEffects}\n   * @implements {Polymer_PropertiesMixin}\n   * @extends {HTMLElement}\n   * @private\n   */\n  const polymerElementBase = PropertiesMixin(PropertyEffects(base));\n\n  /**\n   * Returns a list of properties with default values.\n   * This list is created as an optimization since it is a subset of\n   * the list returned from `_properties`.\n   * This list is used in `_initializeProperties` to set property defaults.\n   *\n   * @param {PolymerElementConstructor} constructor Element class\n   * @return {PolymerElementProperties} Flattened properties for this class\n   *   that have default values\n   * @private\n   */\n  function propertyDefaults(constructor) {\n    if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__propertyDefaults', constructor))) {\n      constructor.__propertyDefaults = null;\n      let props = constructor._properties;\n      for (let p in props) {\n        let info = props[p];\n        if ('value' in info) {\n          constructor.__propertyDefaults = constructor.__propertyDefaults || {};\n          constructor.__propertyDefaults[p] = info;\n        }\n      }\n    }\n    return constructor.__propertyDefaults;\n  }\n\n  /**\n   * Returns a memoized version of the `observers` array.\n   * @param {PolymerElementConstructor} constructor Element class\n   * @return {Array} Array containing own observers for the given class\n   * @protected\n   */\n  function ownObservers(constructor) {\n    if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__ownObservers', constructor))) {\n      constructor.__ownObservers = constructor.hasOwnProperty(JSCompiler_renameProperty('observers', constructor)) ? /** @type {PolymerElementConstructor} */constructor.observers : null;\n    }\n    return constructor.__ownObservers;\n  }\n\n  /**\n   * Creates effects for a property.\n   *\n   * Note, once a property has been set to\n   * `readOnly`, `computed`, `reflectToAttribute`, or `notify`\n   * these values may not be changed. For example, a subclass cannot\n   * alter these settings. However, additional `observers` may be added\n   * by subclasses.\n   *\n   * The info object should contain property metadata as follows:\n   *\n   * * `type`: {function} type to which an attribute matching the property\n   * is deserialized. Note the property is camel-cased from a dash-cased\n   * attribute. For example, 'foo-bar' attribute is deserialized to a\n   * property named 'fooBar'.\n   *\n   * * `readOnly`: {boolean} creates a readOnly property and\n   * makes a private setter for the private of the form '_setFoo' for a\n   * property 'foo',\n   *\n   * * `computed`: {string} creates a computed property. A computed property\n   * is also automatically set to `readOnly: true`. The value is calculated\n   * by running a method and arguments parsed from the given string. For\n   * example 'compute(foo)' will compute a given property when the\n   * 'foo' property changes by executing the 'compute' method. This method\n   * must return the computed value.\n   *\n   * * `reflectToAttribute`: {boolean} If true, the property value is reflected\n   * to an attribute of the same name. Note, the attribute is dash-cased\n   * so a property named 'fooBar' is reflected as 'foo-bar'.\n   *\n   * * `notify`: {boolean} sends a non-bubbling notification event when\n   * the property changes. For example, a property named 'foo' sends an\n   * event named 'foo-changed' with `event.detail` set to the value of\n   * the property.\n   *\n   * * observer: {string} name of a method that runs when the property\n   * changes. The arguments of the method are (value, previousValue).\n   *\n   * Note: Users may want control over modifying property\n   * effects via subclassing. For example, a user might want to make a\n   * reflectToAttribute property not do so in a subclass. We've chosen to\n   * disable this because it leads to additional complication.\n   * For example, a readOnly effect generates a special setter. If a subclass\n   * disables the effect, the setter would fail unexpectedly.\n   * Based on feedback, we may want to try to make effects more malleable\n   * and/or provide an advanced api for manipulating them.\n   *\n   * @param {!PolymerElement} proto Element class prototype to add accessors\n   *   and effects to\n   * @param {string} name Name of the property.\n   * @param {Object} info Info object from which to create property effects.\n   * Supported keys:\n   * @param {Object} allProps Flattened map of all properties defined in this\n   *   element (including inherited properties)\n   * @return {void}\n   * @private\n   */\n  function createPropertyFromConfig(proto, name, info, allProps) {\n    // computed forces readOnly...\n    if (info.computed) {\n      info.readOnly = true;\n    }\n    // Note, since all computed properties are readOnly, this prevents\n    // adding additional computed property effects (which leads to a confusing\n    // setup where multiple triggers for setting a property)\n    // While we do have `hasComputedEffect` this is set on the property's\n    // dependencies rather than itself.\n    if (info.computed) {\n      if (proto._hasReadOnlyEffect(name)) {\n        console.warn(`Cannot redefine computed property '${name}'.`);\n      } else {\n        proto._createComputedProperty(name, info.computed, allProps);\n      }\n    }\n    if (info.readOnly && !proto._hasReadOnlyEffect(name)) {\n      proto._createReadOnlyProperty(name, !info.computed);\n    } else if (info.readOnly === false && proto._hasReadOnlyEffect(name)) {\n      console.warn(`Cannot make readOnly property '${name}' non-readOnly.`);\n    }\n    if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {\n      proto._createReflectedProperty(name);\n    } else if (info.reflectToAttribute === false && proto._hasReflectEffect(name)) {\n      console.warn(`Cannot make reflected property '${name}' non-reflected.`);\n    }\n    if (info.notify && !proto._hasNotifyEffect(name)) {\n      proto._createNotifyingProperty(name);\n    } else if (info.notify === false && proto._hasNotifyEffect(name)) {\n      console.warn(`Cannot make notify property '${name}' non-notify.`);\n    }\n    // always add observer\n    if (info.observer) {\n      proto._createPropertyObserver(name, info.observer, allProps[info.observer]);\n    }\n    // always create the mapping from attribute back to property for deserialization.\n    proto._addPropertyToAttributeMap(name);\n  }\n\n  /**\n   * Process all style elements in the element template. Styles with the\n   * `include` attribute are processed such that any styles in\n   * the associated \"style modules\" are included in the element template.\n   * @param {PolymerElementConstructor} klass Element class\n   * @param {!HTMLTemplateElement} template Template to process\n   * @param {string} is Name of element\n   * @param {string} baseURI Base URI for element\n   * @private\n   */\n  function processElementStyles(klass, template, is, baseURI) {\n    if (!builtCSS) {\n      const templateStyles = template.content.querySelectorAll('style');\n      const stylesWithImports = stylesFromTemplate(template);\n      // insert styles from <link rel=\"import\" type=\"css\"> at the top of the template\n      const linkedStyles = stylesFromModuleImports(is);\n      const firstTemplateChild = template.content.firstElementChild;\n      for (let idx = 0; idx < linkedStyles.length; idx++) {\n        let s = linkedStyles[idx];\n        s.textContent = klass._processStyleText(s.textContent, baseURI);\n        template.content.insertBefore(s, firstTemplateChild);\n      }\n      // keep track of the last \"concrete\" style in the template we have encountered\n      let templateStyleIndex = 0;\n      // ensure all gathered styles are actually in this template.\n      for (let i = 0; i < stylesWithImports.length; i++) {\n        let s = stylesWithImports[i];\n        let templateStyle = templateStyles[templateStyleIndex];\n        // if the style is not in this template, it's been \"included\" and\n        // we put a clone of it in the template before the style that included it\n        if (templateStyle !== s) {\n          s = s.cloneNode(true);\n          templateStyle.parentNode.insertBefore(s, templateStyle);\n        } else {\n          templateStyleIndex++;\n        }\n        s.textContent = klass._processStyleText(s.textContent, baseURI);\n      }\n    }\n    if (window.ShadyCSS) {\n      window.ShadyCSS.prepareTemplate(template, is);\n    }\n  }\n\n  /**\n   * Look up template from dom-module for element\n   *\n   * @param {string} is Element name to look up\n   * @return {?HTMLTemplateElement|undefined} Template found in dom module, or\n   *   undefined if not found\n   * @protected\n   */\n  function getTemplateFromDomModule(is) {\n    let template = null;\n    // Under strictTemplatePolicy in 3.x+, dom-module lookup is only allowed\n    // when opted-in via allowTemplateFromDomModule\n    if (is && (!strictTemplatePolicy || allowTemplateFromDomModule)) {\n      template = /** @type {?HTMLTemplateElement} */\n      DomModule.import(is, 'template');\n      // Under strictTemplatePolicy, require any element with an `is`\n      // specified to have a dom-module\n      if (strictTemplatePolicy && !template) {\n        throw new Error(`strictTemplatePolicy: expecting dom-module or null template for ${is}`);\n      }\n    }\n    return template;\n  }\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @unrestricted\n   * @implements {Polymer_ElementMixin}\n   * @extends {polymerElementBase}\n   */\n  class PolymerElement extends polymerElementBase {\n    /**\n     * Current Polymer version in Semver notation.\n     * @type {string} Semver notation of the current version of Polymer.\n     */\n    static get polymerElementVersion() {\n      return version;\n    }\n\n    /**\n     * Override of PropertiesMixin _finalizeClass to create observers and\n     * find the template.\n     * @return {void}\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     */\n    static _finalizeClass() {\n      super._finalizeClass();\n      const observers = ownObservers(this);\n      if (observers) {\n        this.createObservers(observers, this._properties);\n      }\n      this._prepareTemplate();\n    }\n    static _prepareTemplate() {\n      // note: create \"working\" template that is finalized at instance time\n      let template = /** @type {PolymerElementConstructor} */this.template;\n      if (template) {\n        if (typeof template === 'string') {\n          console.error('template getter must return HTMLTemplateElement');\n          template = null;\n        } else if (!legacyOptimizations) {\n          template = template.cloneNode(true);\n        }\n      }\n      this.prototype._template = template;\n    }\n\n    /**\n     * Override of PropertiesChanged createProperties to create accessors\n     * and property effects for all of the properties.\n     * @param {!Object} props .\n     * @return {void}\n     * @protected\n     */\n    static createProperties(props) {\n      for (let p in props) {\n        createPropertyFromConfig(this.prototype, p, props[p], props);\n      }\n    }\n\n    /**\n     * Creates observers for the given `observers` array.\n     * Leverages `PropertyEffects` to create observers.\n     * @param {Object} observers Array of observer descriptors for\n     *   this class\n     * @param {Object} dynamicFns Object containing keys for any properties\n     *   that are functions and should trigger the effect when the function\n     *   reference is changed\n     * @return {void}\n     * @protected\n     */\n    static createObservers(observers, dynamicFns) {\n      const proto = this.prototype;\n      for (let i = 0; i < observers.length; i++) {\n        proto._createMethodObserver(observers[i], dynamicFns);\n      }\n    }\n\n    /**\n     * Returns the template that will be stamped into this element's shadow root.\n     *\n     * If a `static get is()` getter is defined, the default implementation\n     * will return the first `<template>` in a `dom-module` whose `id`\n     * matches this element's `is`.\n     *\n     * Users may override this getter to return an arbitrary template\n     * (in which case the `is` getter is unnecessary). The template returned\n     * must be an `HTMLTemplateElement`.\n     *\n     * Note that when subclassing, if the super class overrode the default\n     * implementation and the subclass would like to provide an alternate\n     * template via a `dom-module`, it should override this getter and\n     * return `DomModule.import(this.is, 'template')`.\n     *\n     * If a subclass would like to modify the super class template, it should\n     * clone it rather than modify it in place.  If the getter does expensive\n     * work such as cloning/modifying a template, it should memoize the\n     * template for maximum performance:\n     *\n     *   let memoizedTemplate;\n     *   class MySubClass extends MySuperClass {\n     *     static get template() {\n     *       if (!memoizedTemplate) {\n     *         memoizedTemplate = super.template.cloneNode(true);\n     *         let subContent = document.createElement('div');\n     *         subContent.textContent = 'This came from MySubClass';\n     *         memoizedTemplate.content.appendChild(subContent);\n     *       }\n     *       return memoizedTemplate;\n     *     }\n     *   }\n     *\n     * @return {!HTMLTemplateElement|string} Template to be stamped\n     */\n    static get template() {\n      // Explanation of template-related properties:\n      // - constructor.template (this getter): the template for the class.\n      //     This can come from the prototype (for legacy elements), from a\n      //     dom-module, or from the super class's template (or can be overridden\n      //     altogether by the user)\n      // - constructor._template: memoized version of constructor.template\n      // - prototype._template: working template for the element, which will be\n      //     parsed and modified in place. It is a cloned version of\n      //     constructor.template, saved in _finalizeClass(). Note that before\n      //     this getter is called, for legacy elements this could be from a\n      //     _template field on the info object passed to Polymer(), a behavior,\n      //     or set in registered(); once the static getter runs, a clone of it\n      //     will overwrite it on the prototype as the working template.\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {\n        this._template =\n        // If user has put template on prototype (e.g. in legacy via registered\n        // callback or info object), prefer that first\n        this.prototype.hasOwnProperty(JSCompiler_renameProperty('_template', this.prototype)) ? this.prototype._template :\n        // Look in dom-module associated with this element's is\n        getTemplateFromDomModule( /** @type {PolymerElementConstructor}*/this.is) ||\n        // Next look for superclass template (call the super impl this\n        // way so that `this` points to the superclass)\n        Object.getPrototypeOf( /** @type {PolymerElementConstructor}*/this.prototype).constructor.template;\n      }\n      return this._template;\n    }\n\n    /**\n     * Set the template.\n     *\n     * @param {!HTMLTemplateElement|string} value Template to set.\n     */\n    static set template(value) {\n      this._template = value;\n    }\n\n    /**\n     * Path matching the url from which the element was imported.\n     *\n     * This path is used to resolve url's in template style cssText.\n     * The `importPath` property is also set on element instances and can be\n     * used to create bindings relative to the import path.\n     *\n     * For elements defined in ES modules, users should implement\n     * `static get importMeta() { return import.meta; }`, and the default\n     * implementation of `importPath` will  return `import.meta.url`'s path.\n     * For elements defined in HTML imports, this getter will return the path\n     * to the document containing a `dom-module` element matching this\n     * element's static `is` property.\n     *\n     * Note, this path should contain a trailing `/`.\n     *\n     * @return {string} The import path for this element class\n     * @suppress {missingProperties}\n     */\n    static get importPath() {\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {\n        const meta = this.importMeta;\n        if (meta) {\n          this._importPath = pathFromUrl(meta.url);\n        } else {\n          const module = DomModule.import( /** @type {PolymerElementConstructor} */this.is);\n          this._importPath = module && module.assetpath || Object.getPrototypeOf( /** @type {PolymerElementConstructor}*/this.prototype).constructor.importPath;\n        }\n      }\n      return this._importPath;\n    }\n    constructor() {\n      super();\n      /** @type {HTMLTemplateElement} */\n      this._template;\n      /** @type {string} */\n      this._importPath;\n      /** @type {string} */\n      this.rootPath;\n      /** @type {string} */\n      this.importPath;\n      /** @type {StampedTemplate | HTMLElement | ShadowRoot} */\n      this.root;\n      /** @type {!Object<string, !Element>} */\n      this.$;\n    }\n\n    /**\n     * Overrides the default `PropertyAccessors` to ensure class\n     * metaprogramming related to property accessors and effects has\n     * completed (calls `finalize`).\n     *\n     * It also initializes any property defaults provided via `value` in\n     * `properties` metadata.\n     *\n     * @return {void}\n     * @override\n     * @suppress {invalidCasts,missingProperties} go/missingfnprops\n     */\n    _initializeProperties() {\n      this.constructor.finalize();\n      // note: finalize template when we have access to `localName` to\n      // avoid dependence on `is` for polyfilling styling.\n      this.constructor._finalizeTemplate( /** @type {!HTMLElement} */this.localName);\n      super._initializeProperties();\n      // set path defaults\n      this.rootPath = rootPath;\n      this.importPath = this.constructor.importPath;\n      // apply property defaults...\n      let p$ = propertyDefaults(this.constructor);\n      if (!p$) {\n        return;\n      }\n      for (let p in p$) {\n        let info = p$[p];\n        // Don't set default value if there is already an own property, which\n        // happens when a `properties` property with default but no effects had\n        // a property set (e.g. bound) by its host before upgrade\n        if (!this.hasOwnProperty(p)) {\n          let value = typeof info.value == 'function' ? info.value.call(this) : info.value;\n          // Set via `_setProperty` if there is an accessor, to enable\n          // initializing readOnly property defaults\n          if (this._hasAccessor(p)) {\n            this._setPendingProperty(p, value, true);\n          } else {\n            this[p] = value;\n          }\n        }\n      }\n    }\n\n    /**\n     * Gather style text for a style element in the template.\n     *\n     * @param {string} cssText Text containing styling to process\n     * @param {string} baseURI Base URI to rebase CSS paths against\n     * @return {string} The processed CSS text\n     * @protected\n     */\n    static _processStyleText(cssText, baseURI) {\n      return resolveCss(cssText, baseURI);\n    }\n\n    /**\n    * Configures an element `proto` to function with a given `template`.\n    * The element name `is` and extends `ext` must be specified for ShadyCSS\n    * style scoping.\n    *\n    * @param {string} is Tag name (or type extension name) for this element\n    * @return {void}\n    * @protected\n    */\n    static _finalizeTemplate(is) {\n      /** @const {HTMLTemplateElement} */\n      const template = this.prototype._template;\n      if (template && !template.__polymerFinalized) {\n        template.__polymerFinalized = true;\n        const importPath = this.importPath;\n        const baseURI = importPath ? resolveUrl(importPath) : '';\n        // e.g. support `include=\"module-name\"`, and ShadyCSS\n        processElementStyles(this, template, is, baseURI);\n        this.prototype._bindTemplate(template);\n      }\n    }\n\n    /**\n     * Provides a default implementation of the standard Custom Elements\n     * `connectedCallback`.\n     *\n     * The default implementation enables the property effects system and\n     * flushes any pending properties, and updates shimmed CSS properties\n     * when using the ShadyCSS scoping/custom properties polyfill.\n     *\n     * @override\n     * @suppress {missingProperties, invalidCasts} Super may or may not\n     *     implement the callback\n     * @return {void}\n     */\n    connectedCallback() {\n      if (window.ShadyCSS && this._template) {\n        window.ShadyCSS.styleElement( /** @type {!HTMLElement} */this);\n      }\n      super.connectedCallback();\n    }\n\n    /**\n     * Stamps the element template.\n     *\n     * @return {void}\n     * @override\n     */\n    ready() {\n      if (this._template) {\n        this.root = this._stampTemplate(this._template);\n        this.$ = this.root.$;\n      }\n      super.ready();\n    }\n\n    /**\n     * Implements `PropertyEffects`'s `_readyClients` call. Attaches\n     * element dom by calling `_attachDom` with the dom stamped from the\n     * element's template via `_stampTemplate`. Note that this allows\n     * client dom to be attached to the element prior to any observers\n     * running.\n     *\n     * @return {void}\n     * @override\n     */\n    _readyClients() {\n      if (this._template) {\n        this.root = this._attachDom( /** @type {StampedTemplate} */this.root);\n      }\n      // The super._readyClients here sets the clients initialized flag.\n      // We must wait to do this until after client dom is created/attached\n      // so that this flag can be checked to prevent notifications fired\n      // during this process from being handled before clients are ready.\n      super._readyClients();\n    }\n\n    /**\n     * Attaches an element's stamped dom to itself. By default,\n     * this method creates a `shadowRoot` and adds the dom to it.\n     * However, this method may be overridden to allow an element\n     * to put its dom in another location.\n     *\n     * @override\n     * @throws {Error}\n     * @suppress {missingReturn}\n     * @param {StampedTemplate} dom to attach to the element.\n     * @return {ShadowRoot} node to which the dom has been attached.\n     */\n    _attachDom(dom) {\n      const n = wrap(this);\n      if (n.attachShadow) {\n        if (dom) {\n          if (!n.shadowRoot) {\n            n.attachShadow({\n              mode: 'open'\n            });\n          }\n          n.shadowRoot.appendChild(dom);\n          if (syncInitialRender && window.ShadyDOM) {\n            ShadyDOM.flushInitial(n.shadowRoot);\n          }\n          return n.shadowRoot;\n        }\n        return null;\n      } else {\n        throw new Error('ShadowDOM not available. ' +\n        // TODO(sorvell): move to compile-time conditional when supported\n        'PolymerElement can create dom as children instead of in ' + 'ShadowDOM by setting `this.root = this;\\` before \\`ready\\`.');\n      }\n    }\n\n    /**\n     * When using the ShadyCSS scoping and custom property shim, causes all\n     * shimmed styles in this element (and its subtree) to be updated\n     * based on current custom property values.\n     *\n     * The optional parameter overrides inline custom property styles with an\n     * object of properties where the keys are CSS properties, and the values\n     * are strings.\n     *\n     * Example: `this.updateStyles({'--color': 'blue'})`\n     *\n     * These properties are retained unless a value of `null` is set.\n     *\n     * Note: This function does not support updating CSS mixins.\n     * You can not dynamically change the value of an `@apply`.\n     *\n     * @override\n     * @param {Object=} properties Bag of custom property key/values to\n     *   apply to this element.\n     * @return {void}\n     * @suppress {invalidCasts}\n     */\n    updateStyles(properties) {\n      if (window.ShadyCSS) {\n        window.ShadyCSS.styleSubtree( /** @type {!HTMLElement} */this, properties);\n      }\n    }\n\n    /**\n     * Rewrites a given URL relative to a base URL. The base URL defaults to\n     * the original location of the document containing the `dom-module` for\n     * this element. This method will return the same URL before and after\n     * bundling.\n     *\n     * Note that this function performs no resolution for URLs that start\n     * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose\n     * URL resolution, use `window.URL`.\n     *\n     * @override\n     * @param {string} url URL to resolve.\n     * @param {string=} base Optional base URL to resolve against, defaults\n     * to the element's `importPath`\n     * @return {string} Rewritten URL relative to base\n     */\n    resolveUrl(url, base) {\n      if (!base && this.importPath) {\n        base = resolveUrl(this.importPath);\n      }\n      return resolveUrl(url, base);\n    }\n\n    /**\n     * Overrides `PropertyEffects` to add map of dynamic functions on\n     * template info, for consumption by `PropertyEffects` template binding\n     * code. This map determines which method templates should have accessors\n     * created for them.\n     *\n     * @param {!HTMLTemplateElement} template Template\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} .\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     */\n    static _parseTemplateContent(template, templateInfo, nodeInfo) {\n      templateInfo.dynamicFns = templateInfo.dynamicFns || this._properties;\n      return super._parseTemplateContent(template, templateInfo, nodeInfo);\n    }\n\n    /**\n     * Overrides `PropertyEffects` to warn on use of undeclared properties in\n     * template.\n     *\n     * @param {Object} templateInfo Template metadata to add effect to\n     * @param {string} prop Property that should trigger the effect\n     * @param {Object=} effect Effect metadata object\n     * @return {void}\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     */\n    static _addTemplatePropertyEffect(templateInfo, prop, effect) {\n      // Warn if properties are used in template without being declared.\n      // Properties must be listed in `properties` to be included in\n      // `observedAttributes` since CE V1 reads that at registration time, and\n      // since we want to keep template parsing lazy, we can't automatically\n      // add undeclared properties used in templates to `observedAttributes`.\n      // The warning is only enabled in `legacyOptimizations` mode, since\n      // we don't want to spam existing users who might have adopted the\n      // shorthand when attribute deserialization is not important.\n      if (legacyOptimizations && !(prop in this._properties)) {\n        console.warn(`Property '${prop}' used in template but not declared in 'properties'; ` + `attribute will not be observed.`);\n      }\n      return super._addTemplatePropertyEffect(templateInfo, prop, effect);\n    }\n  }\n  return PolymerElement;\n});\n\n/**\n * When using the ShadyCSS scoping and custom property shim, causes all\n * shimmed `styles` (via `custom-style`) in the document (and its subtree)\n * to be updated based on current custom property values.\n *\n * The optional parameter overrides inline custom property styles with an\n * object of properties where the keys are CSS properties, and the values\n * are strings.\n *\n * Example: `updateStyles({'--color': 'blue'})`\n *\n * These properties are retained unless a value of `null` is set.\n *\n * @param {Object=} props Bag of custom property key/values to\n *   apply to the document.\n * @return {void}\n */\nexport const updateStyles = function (props) {\n  if (window.ShadyCSS) {\n    window.ShadyCSS.styleDocument(props);\n  }\n};","map":{"version":3,"names":["rootPath","strictTemplatePolicy","allowTemplateFromDomModule","legacyOptimizations","syncInitialRender","dedupingMixin","stylesFromTemplate","stylesFromModuleImports","pathFromUrl","resolveCss","resolveUrl","DomModule","PropertyEffects","PropertiesMixin","wrap","version","builtCSS","window","ShadyCSS","ElementMixin","base","polymerElementBase","propertyDefaults","constructor","hasOwnProperty","JSCompiler_renameProperty","__propertyDefaults","props","_properties","p","info","ownObservers","__ownObservers","observers","createPropertyFromConfig","proto","name","allProps","computed","readOnly","_hasReadOnlyEffect","console","warn","_createComputedProperty","_createReadOnlyProperty","reflectToAttribute","_hasReflectEffect","_createReflectedProperty","notify","_hasNotifyEffect","_createNotifyingProperty","observer","_createPropertyObserver","_addPropertyToAttributeMap","processElementStyles","klass","template","is","baseURI","templateStyles","content","querySelectorAll","stylesWithImports","linkedStyles","firstTemplateChild","firstElementChild","idx","length","s","textContent","_processStyleText","insertBefore","templateStyleIndex","i","templateStyle","cloneNode","parentNode","prepareTemplate","getTemplateFromDomModule","import","Error","PolymerElement","polymerElementVersion","_finalizeClass","createObservers","_prepareTemplate","error","prototype","_template","createProperties","dynamicFns","_createMethodObserver","Object","getPrototypeOf","value","importPath","meta","importMeta","_importPath","url","module","assetpath","root","$","_initializeProperties","finalize","_finalizeTemplate","localName","p$","call","_hasAccessor","_setPendingProperty","cssText","__polymerFinalized","_bindTemplate","connectedCallback","styleElement","ready","_stampTemplate","_readyClients","_attachDom","dom","n","attachShadow","shadowRoot","mode","appendChild","ShadyDOM","flushInitial","updateStyles","properties","styleSubtree","_parseTemplateContent","templateInfo","nodeInfo","_addTemplatePropertyEffect","prop","effect","styleDocument"],"sources":["C:/Users/Sudebi/Vaadin/Workspace/Angular/AngluarVaadin/using-web-components-in-angular/node_modules/@polymer/polymer/lib/mixins/element-mixin.js"],"sourcesContent":["/**\n * @fileoverview\n * @suppress {checkPrototypalTypes}\n * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\nimport '../utils/boot.js';\n\nimport { rootPath, strictTemplatePolicy, allowTemplateFromDomModule, legacyOptimizations, syncInitialRender } from '../utils/settings.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nimport { stylesFromTemplate, stylesFromModuleImports } from '../utils/style-gather.js';\nimport { pathFromUrl, resolveCss, resolveUrl } from '../utils/resolve-url.js';\nimport { DomModule } from '../elements/dom-module.js';\nimport { PropertyEffects } from './property-effects.js';\nimport { PropertiesMixin } from './properties-mixin.js';\nimport { wrap } from '../utils/wrap.js';\n\n/**\n * Current Polymer version in Semver notation.\n * @type {string} Semver notation of the current version of Polymer.\n */\nexport const version = '3.2.0';\n\nconst builtCSS = window.ShadyCSS && window.ShadyCSS['cssBuild'];\n\n/**\n * Element class mixin that provides the core API for Polymer's meta-programming\n * features including template stamping, data-binding, attribute deserialization,\n * and property change observation.\n *\n * Subclassers may provide the following static getters to return metadata\n * used to configure Polymer's features for the class:\n *\n * - `static get is()`: When the template is provided via a `dom-module`,\n *   users should return the `dom-module` id from a static `is` getter.  If\n *   no template is needed or the template is provided directly via the\n *   `template` getter, there is no need to define `is` for the element.\n *\n * - `static get template()`: Users may provide the template directly (as\n *   opposed to via `dom-module`) by implementing a static `template` getter.\n *   The getter must return an `HTMLTemplateElement`.\n *\n * - `static get properties()`: Should return an object describing\n *   property-related metadata used by Polymer features (key: property name\n *   value: object containing property metadata). Valid keys in per-property\n *   metadata include:\n *   - `type` (String|Number|Object|Array|...): Used by\n *     `attributeChangedCallback` to determine how string-based attributes\n *     are deserialized to JavaScript property values.\n *   - `notify` (boolean): Causes a change in the property to fire a\n *     non-bubbling event called `<property>-changed`. Elements that have\n *     enabled two-way binding to the property use this event to observe changes.\n *   - `readOnly` (boolean): Creates a getter for the property, but no setter.\n *     To set a read-only property, use the private setter method\n *     `_setProperty(property, value)`.\n *   - `observer` (string): Observer method name that will be called when\n *     the property changes. The arguments of the method are\n *     `(value, previousValue)`.\n *   - `computed` (string): String describing method and dependent properties\n *     for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).\n *     Computed properties are read-only by default and can only be changed\n *     via the return value of the computing method.\n *\n * - `static get observers()`: Array of strings describing multi-property\n *   observer methods and their dependent properties (e.g.\n *   `'observeABC(a, b, c)'`).\n *\n * The base class provides default implementations for the following standard\n * custom element lifecycle callbacks; users may override these, but should\n * call the super method to ensure\n * - `constructor`: Run when the element is created or upgraded\n * - `connectedCallback`: Run each time the element is connected to the\n *   document\n * - `disconnectedCallback`: Run each time the element is disconnected from\n *   the document\n * - `attributeChangedCallback`: Run each time an attribute in\n *   `observedAttributes` is set or removed (note: this element's default\n *   `observedAttributes` implementation will automatically return an array\n *   of dash-cased attributes based on `properties`)\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin PropertyEffects\n * @appliesMixin PropertiesMixin\n * @property rootPath {string} Set to the value of `rootPath`,\n *   which defaults to the main document path\n * @property importPath {string} Set to the value of the class's static\n *   `importPath` property, which defaults to the path of this element's\n *   `dom-module` (when `is` is used), but can be overridden for other\n *   import strategies.\n * @summary Element class mixin that provides the core API for Polymer's\n * meta-programming features.\n */\nexport const ElementMixin = dedupingMixin(base => {\n  /**\n   * @constructor\n   * @implements {Polymer_PropertyEffects}\n   * @implements {Polymer_PropertiesMixin}\n   * @extends {HTMLElement}\n   * @private\n   */\n  const polymerElementBase = PropertiesMixin(PropertyEffects(base));\n\n  /**\n   * Returns a list of properties with default values.\n   * This list is created as an optimization since it is a subset of\n   * the list returned from `_properties`.\n   * This list is used in `_initializeProperties` to set property defaults.\n   *\n   * @param {PolymerElementConstructor} constructor Element class\n   * @return {PolymerElementProperties} Flattened properties for this class\n   *   that have default values\n   * @private\n   */\n  function propertyDefaults(constructor) {\n    if (!constructor.hasOwnProperty(\n      JSCompiler_renameProperty('__propertyDefaults', constructor))) {\n      constructor.__propertyDefaults = null;\n      let props = constructor._properties;\n      for (let p in props) {\n        let info = props[p];\n        if ('value' in info) {\n          constructor.__propertyDefaults = constructor.__propertyDefaults || {};\n          constructor.__propertyDefaults[p] = info;\n        }\n      }\n    }\n    return constructor.__propertyDefaults;\n  }\n\n  /**\n   * Returns a memoized version of the `observers` array.\n   * @param {PolymerElementConstructor} constructor Element class\n   * @return {Array} Array containing own observers for the given class\n   * @protected\n   */\n  function ownObservers(constructor) {\n    if (!constructor.hasOwnProperty(\n      JSCompiler_renameProperty('__ownObservers', constructor))) {\n      constructor.__ownObservers =\n          constructor.hasOwnProperty(\n              JSCompiler_renameProperty('observers', constructor)) ?\n          /** @type {PolymerElementConstructor} */ (constructor).observers :\n          null;\n    }\n    return constructor.__ownObservers;\n  }\n\n  /**\n   * Creates effects for a property.\n   *\n   * Note, once a property has been set to\n   * `readOnly`, `computed`, `reflectToAttribute`, or `notify`\n   * these values may not be changed. For example, a subclass cannot\n   * alter these settings. However, additional `observers` may be added\n   * by subclasses.\n   *\n   * The info object should contain property metadata as follows:\n   *\n   * * `type`: {function} type to which an attribute matching the property\n   * is deserialized. Note the property is camel-cased from a dash-cased\n   * attribute. For example, 'foo-bar' attribute is deserialized to a\n   * property named 'fooBar'.\n   *\n   * * `readOnly`: {boolean} creates a readOnly property and\n   * makes a private setter for the private of the form '_setFoo' for a\n   * property 'foo',\n   *\n   * * `computed`: {string} creates a computed property. A computed property\n   * is also automatically set to `readOnly: true`. The value is calculated\n   * by running a method and arguments parsed from the given string. For\n   * example 'compute(foo)' will compute a given property when the\n   * 'foo' property changes by executing the 'compute' method. This method\n   * must return the computed value.\n   *\n   * * `reflectToAttribute`: {boolean} If true, the property value is reflected\n   * to an attribute of the same name. Note, the attribute is dash-cased\n   * so a property named 'fooBar' is reflected as 'foo-bar'.\n   *\n   * * `notify`: {boolean} sends a non-bubbling notification event when\n   * the property changes. For example, a property named 'foo' sends an\n   * event named 'foo-changed' with `event.detail` set to the value of\n   * the property.\n   *\n   * * observer: {string} name of a method that runs when the property\n   * changes. The arguments of the method are (value, previousValue).\n   *\n   * Note: Users may want control over modifying property\n   * effects via subclassing. For example, a user might want to make a\n   * reflectToAttribute property not do so in a subclass. We've chosen to\n   * disable this because it leads to additional complication.\n   * For example, a readOnly effect generates a special setter. If a subclass\n   * disables the effect, the setter would fail unexpectedly.\n   * Based on feedback, we may want to try to make effects more malleable\n   * and/or provide an advanced api for manipulating them.\n   *\n   * @param {!PolymerElement} proto Element class prototype to add accessors\n   *   and effects to\n   * @param {string} name Name of the property.\n   * @param {Object} info Info object from which to create property effects.\n   * Supported keys:\n   * @param {Object} allProps Flattened map of all properties defined in this\n   *   element (including inherited properties)\n   * @return {void}\n   * @private\n   */\n  function createPropertyFromConfig(proto, name, info, allProps) {\n    // computed forces readOnly...\n    if (info.computed) {\n      info.readOnly = true;\n    }\n    // Note, since all computed properties are readOnly, this prevents\n    // adding additional computed property effects (which leads to a confusing\n    // setup where multiple triggers for setting a property)\n    // While we do have `hasComputedEffect` this is set on the property's\n    // dependencies rather than itself.\n    if (info.computed) {\n      if (proto._hasReadOnlyEffect(name)) {\n        console.warn(`Cannot redefine computed property '${name}'.`);\n      } else {\n        proto._createComputedProperty(name, info.computed, allProps);\n      }\n    }\n    if (info.readOnly && !proto._hasReadOnlyEffect(name)) {\n      proto._createReadOnlyProperty(name, !info.computed);\n    } else if (info.readOnly === false && proto._hasReadOnlyEffect(name)) {\n      console.warn(`Cannot make readOnly property '${name}' non-readOnly.`);\n    }\n    if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {\n      proto._createReflectedProperty(name);\n    } else if (info.reflectToAttribute === false && proto._hasReflectEffect(name)) {\n      console.warn(`Cannot make reflected property '${name}' non-reflected.`);\n    }\n    if (info.notify && !proto._hasNotifyEffect(name)) {\n      proto._createNotifyingProperty(name);\n    } else if (info.notify === false && proto._hasNotifyEffect(name)) {\n      console.warn(`Cannot make notify property '${name}' non-notify.`);\n    }\n    // always add observer\n    if (info.observer) {\n      proto._createPropertyObserver(name, info.observer, allProps[info.observer]);\n    }\n    // always create the mapping from attribute back to property for deserialization.\n    proto._addPropertyToAttributeMap(name);\n  }\n\n  /**\n   * Process all style elements in the element template. Styles with the\n   * `include` attribute are processed such that any styles in\n   * the associated \"style modules\" are included in the element template.\n   * @param {PolymerElementConstructor} klass Element class\n   * @param {!HTMLTemplateElement} template Template to process\n   * @param {string} is Name of element\n   * @param {string} baseURI Base URI for element\n   * @private\n   */\n  function processElementStyles(klass, template, is, baseURI) {\n    if (!builtCSS) {\n      const templateStyles = template.content.querySelectorAll('style');\n      const stylesWithImports = stylesFromTemplate(template);\n      // insert styles from <link rel=\"import\" type=\"css\"> at the top of the template\n      const linkedStyles = stylesFromModuleImports(is);\n      const firstTemplateChild = template.content.firstElementChild;\n      for (let idx = 0; idx < linkedStyles.length; idx++) {\n        let s = linkedStyles[idx];\n        s.textContent = klass._processStyleText(s.textContent, baseURI);\n        template.content.insertBefore(s, firstTemplateChild);\n      }\n      // keep track of the last \"concrete\" style in the template we have encountered\n      let templateStyleIndex = 0;\n      // ensure all gathered styles are actually in this template.\n      for (let i = 0; i < stylesWithImports.length; i++) {\n        let s = stylesWithImports[i];\n        let templateStyle = templateStyles[templateStyleIndex];\n        // if the style is not in this template, it's been \"included\" and\n        // we put a clone of it in the template before the style that included it\n        if (templateStyle !== s) {\n          s = s.cloneNode(true);\n          templateStyle.parentNode.insertBefore(s, templateStyle);\n        } else {\n          templateStyleIndex++;\n        }\n        s.textContent = klass._processStyleText(s.textContent, baseURI);\n      }\n    }\n    if (window.ShadyCSS) {\n      window.ShadyCSS.prepareTemplate(template, is);\n    }\n  }\n\n  /**\n   * Look up template from dom-module for element\n   *\n   * @param {string} is Element name to look up\n   * @return {?HTMLTemplateElement|undefined} Template found in dom module, or\n   *   undefined if not found\n   * @protected\n   */\n  function getTemplateFromDomModule(is) {\n    let template = null;\n    // Under strictTemplatePolicy in 3.x+, dom-module lookup is only allowed\n    // when opted-in via allowTemplateFromDomModule\n    if (is && (!strictTemplatePolicy || allowTemplateFromDomModule)) {\n      template = /** @type {?HTMLTemplateElement} */ (\n          DomModule.import(is, 'template'));\n      // Under strictTemplatePolicy, require any element with an `is`\n      // specified to have a dom-module\n      if (strictTemplatePolicy && !template) {\n        throw new Error(`strictTemplatePolicy: expecting dom-module or null template for ${is}`);\n      }\n    }\n    return template;\n  }\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @unrestricted\n   * @implements {Polymer_ElementMixin}\n   * @extends {polymerElementBase}\n   */\n  class PolymerElement extends polymerElementBase {\n\n    /**\n     * Current Polymer version in Semver notation.\n     * @type {string} Semver notation of the current version of Polymer.\n     */\n    static get polymerElementVersion() {\n      return version;\n    }\n\n    /**\n     * Override of PropertiesMixin _finalizeClass to create observers and\n     * find the template.\n     * @return {void}\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     */\n    static _finalizeClass() {\n      super._finalizeClass();\n      const observers = ownObservers(this);\n      if (observers) {\n        this.createObservers(observers, this._properties);\n      }\n      this._prepareTemplate();\n    }\n\n    static _prepareTemplate() {\n      // note: create \"working\" template that is finalized at instance time\n      let template = /** @type {PolymerElementConstructor} */ (this).template;\n      if (template) {\n        if (typeof template === 'string') {\n          console.error('template getter must return HTMLTemplateElement');\n          template = null;\n        } else if (!legacyOptimizations) {\n          template = template.cloneNode(true);\n        }\n      }\n\n      this.prototype._template = template;\n    }\n\n    /**\n     * Override of PropertiesChanged createProperties to create accessors\n     * and property effects for all of the properties.\n     * @param {!Object} props .\n     * @return {void}\n     * @protected\n     */\n    static createProperties(props) {\n      for (let p in props) {\n        createPropertyFromConfig(this.prototype, p, props[p], props);\n      }\n    }\n\n    /**\n     * Creates observers for the given `observers` array.\n     * Leverages `PropertyEffects` to create observers.\n     * @param {Object} observers Array of observer descriptors for\n     *   this class\n     * @param {Object} dynamicFns Object containing keys for any properties\n     *   that are functions and should trigger the effect when the function\n     *   reference is changed\n     * @return {void}\n     * @protected\n     */\n    static createObservers(observers, dynamicFns) {\n      const proto = this.prototype;\n      for (let i=0; i < observers.length; i++) {\n        proto._createMethodObserver(observers[i], dynamicFns);\n      }\n    }\n\n    /**\n     * Returns the template that will be stamped into this element's shadow root.\n     *\n     * If a `static get is()` getter is defined, the default implementation\n     * will return the first `<template>` in a `dom-module` whose `id`\n     * matches this element's `is`.\n     *\n     * Users may override this getter to return an arbitrary template\n     * (in which case the `is` getter is unnecessary). The template returned\n     * must be an `HTMLTemplateElement`.\n     *\n     * Note that when subclassing, if the super class overrode the default\n     * implementation and the subclass would like to provide an alternate\n     * template via a `dom-module`, it should override this getter and\n     * return `DomModule.import(this.is, 'template')`.\n     *\n     * If a subclass would like to modify the super class template, it should\n     * clone it rather than modify it in place.  If the getter does expensive\n     * work such as cloning/modifying a template, it should memoize the\n     * template for maximum performance:\n     *\n     *   let memoizedTemplate;\n     *   class MySubClass extends MySuperClass {\n     *     static get template() {\n     *       if (!memoizedTemplate) {\n     *         memoizedTemplate = super.template.cloneNode(true);\n     *         let subContent = document.createElement('div');\n     *         subContent.textContent = 'This came from MySubClass';\n     *         memoizedTemplate.content.appendChild(subContent);\n     *       }\n     *       return memoizedTemplate;\n     *     }\n     *   }\n     *\n     * @return {!HTMLTemplateElement|string} Template to be stamped\n     */\n    static get template() {\n      // Explanation of template-related properties:\n      // - constructor.template (this getter): the template for the class.\n      //     This can come from the prototype (for legacy elements), from a\n      //     dom-module, or from the super class's template (or can be overridden\n      //     altogether by the user)\n      // - constructor._template: memoized version of constructor.template\n      // - prototype._template: working template for the element, which will be\n      //     parsed and modified in place. It is a cloned version of\n      //     constructor.template, saved in _finalizeClass(). Note that before\n      //     this getter is called, for legacy elements this could be from a\n      //     _template field on the info object passed to Polymer(), a behavior,\n      //     or set in registered(); once the static getter runs, a clone of it\n      //     will overwrite it on the prototype as the working template.\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {\n        this._template =\n          // If user has put template on prototype (e.g. in legacy via registered\n          // callback or info object), prefer that first\n          this.prototype.hasOwnProperty(JSCompiler_renameProperty('_template', this.prototype)) ?\n          this.prototype._template :\n          // Look in dom-module associated with this element's is\n          (getTemplateFromDomModule(/** @type {PolymerElementConstructor}*/ (this).is) ||\n          // Next look for superclass template (call the super impl this\n          // way so that `this` points to the superclass)\n          Object.getPrototypeOf(/** @type {PolymerElementConstructor}*/ (this).prototype).constructor.template);\n      }\n      return this._template;\n    }\n\n    /**\n     * Set the template.\n     *\n     * @param {!HTMLTemplateElement|string} value Template to set.\n     */\n    static set template(value) {\n      this._template = value;\n    }\n\n    /**\n     * Path matching the url from which the element was imported.\n     *\n     * This path is used to resolve url's in template style cssText.\n     * The `importPath` property is also set on element instances and can be\n     * used to create bindings relative to the import path.\n     *\n     * For elements defined in ES modules, users should implement\n     * `static get importMeta() { return import.meta; }`, and the default\n     * implementation of `importPath` will  return `import.meta.url`'s path.\n     * For elements defined in HTML imports, this getter will return the path\n     * to the document containing a `dom-module` element matching this\n     * element's static `is` property.\n     *\n     * Note, this path should contain a trailing `/`.\n     *\n     * @return {string} The import path for this element class\n     * @suppress {missingProperties}\n     */\n    static get importPath() {\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {\n        const meta = this.importMeta;\n        if (meta) {\n          this._importPath = pathFromUrl(meta.url);\n        } else {\n          const module = DomModule.import(/** @type {PolymerElementConstructor} */ (this).is);\n          this._importPath = (module && module.assetpath) ||\n            Object.getPrototypeOf(/** @type {PolymerElementConstructor}*/ (this).prototype).constructor.importPath;\n        }\n      }\n      return this._importPath;\n    }\n\n    constructor() {\n      super();\n      /** @type {HTMLTemplateElement} */\n      this._template;\n      /** @type {string} */\n      this._importPath;\n      /** @type {string} */\n      this.rootPath;\n      /** @type {string} */\n      this.importPath;\n      /** @type {StampedTemplate | HTMLElement | ShadowRoot} */\n      this.root;\n      /** @type {!Object<string, !Element>} */\n      this.$;\n    }\n\n    /**\n     * Overrides the default `PropertyAccessors` to ensure class\n     * metaprogramming related to property accessors and effects has\n     * completed (calls `finalize`).\n     *\n     * It also initializes any property defaults provided via `value` in\n     * `properties` metadata.\n     *\n     * @return {void}\n     * @override\n     * @suppress {invalidCasts,missingProperties} go/missingfnprops\n     */\n    _initializeProperties() {\n      this.constructor.finalize();\n      // note: finalize template when we have access to `localName` to\n      // avoid dependence on `is` for polyfilling styling.\n      this.constructor._finalizeTemplate(/** @type {!HTMLElement} */(this).localName);\n      super._initializeProperties();\n      // set path defaults\n      this.rootPath = rootPath;\n      this.importPath = this.constructor.importPath;\n      // apply property defaults...\n      let p$ = propertyDefaults(this.constructor);\n      if (!p$) {\n        return;\n      }\n      for (let p in p$) {\n        let info = p$[p];\n        // Don't set default value if there is already an own property, which\n        // happens when a `properties` property with default but no effects had\n        // a property set (e.g. bound) by its host before upgrade\n        if (!this.hasOwnProperty(p)) {\n          let value = typeof info.value == 'function' ?\n            info.value.call(this) :\n            info.value;\n          // Set via `_setProperty` if there is an accessor, to enable\n          // initializing readOnly property defaults\n          if (this._hasAccessor(p)) {\n            this._setPendingProperty(p, value, true);\n          } else {\n            this[p] = value;\n          }\n        }\n      }\n    }\n\n    /**\n     * Gather style text for a style element in the template.\n     *\n     * @param {string} cssText Text containing styling to process\n     * @param {string} baseURI Base URI to rebase CSS paths against\n     * @return {string} The processed CSS text\n     * @protected\n     */\n    static _processStyleText(cssText, baseURI) {\n      return resolveCss(cssText, baseURI);\n    }\n\n    /**\n    * Configures an element `proto` to function with a given `template`.\n    * The element name `is` and extends `ext` must be specified for ShadyCSS\n    * style scoping.\n    *\n    * @param {string} is Tag name (or type extension name) for this element\n    * @return {void}\n    * @protected\n    */\n    static _finalizeTemplate(is) {\n      /** @const {HTMLTemplateElement} */\n      const template = this.prototype._template;\n      if (template && !template.__polymerFinalized) {\n        template.__polymerFinalized = true;\n        const importPath = this.importPath;\n        const baseURI = importPath ? resolveUrl(importPath) : '';\n        // e.g. support `include=\"module-name\"`, and ShadyCSS\n        processElementStyles(this, template, is, baseURI);\n        this.prototype._bindTemplate(template);\n      }\n    }\n\n    /**\n     * Provides a default implementation of the standard Custom Elements\n     * `connectedCallback`.\n     *\n     * The default implementation enables the property effects system and\n     * flushes any pending properties, and updates shimmed CSS properties\n     * when using the ShadyCSS scoping/custom properties polyfill.\n     *\n     * @override\n     * @suppress {missingProperties, invalidCasts} Super may or may not\n     *     implement the callback\n     * @return {void}\n     */\n    connectedCallback() {\n      if (window.ShadyCSS && this._template) {\n        window.ShadyCSS.styleElement(/** @type {!HTMLElement} */(this));\n      }\n      super.connectedCallback();\n    }\n\n    /**\n     * Stamps the element template.\n     *\n     * @return {void}\n     * @override\n     */\n    ready() {\n      if (this._template) {\n        this.root = this._stampTemplate(this._template);\n        this.$ = this.root.$;\n      }\n      super.ready();\n    }\n\n    /**\n     * Implements `PropertyEffects`'s `_readyClients` call. Attaches\n     * element dom by calling `_attachDom` with the dom stamped from the\n     * element's template via `_stampTemplate`. Note that this allows\n     * client dom to be attached to the element prior to any observers\n     * running.\n     *\n     * @return {void}\n     * @override\n     */\n    _readyClients() {\n      if (this._template) {\n        this.root = this._attachDom(/** @type {StampedTemplate} */(this.root));\n      }\n      // The super._readyClients here sets the clients initialized flag.\n      // We must wait to do this until after client dom is created/attached\n      // so that this flag can be checked to prevent notifications fired\n      // during this process from being handled before clients are ready.\n      super._readyClients();\n    }\n\n\n    /**\n     * Attaches an element's stamped dom to itself. By default,\n     * this method creates a `shadowRoot` and adds the dom to it.\n     * However, this method may be overridden to allow an element\n     * to put its dom in another location.\n     *\n     * @override\n     * @throws {Error}\n     * @suppress {missingReturn}\n     * @param {StampedTemplate} dom to attach to the element.\n     * @return {ShadowRoot} node to which the dom has been attached.\n     */\n    _attachDom(dom) {\n      const n = wrap(this);\n      if (n.attachShadow) {\n        if (dom) {\n          if (!n.shadowRoot) {\n            n.attachShadow({mode: 'open'});\n          }\n          n.shadowRoot.appendChild(dom);\n          if (syncInitialRender && window.ShadyDOM) {\n            ShadyDOM.flushInitial(n.shadowRoot);\n          }\n          return n.shadowRoot;\n        }\n        return null;\n      } else {\n        throw new Error('ShadowDOM not available. ' +\n          // TODO(sorvell): move to compile-time conditional when supported\n        'PolymerElement can create dom as children instead of in ' +\n        'ShadowDOM by setting `this.root = this;\\` before \\`ready\\`.');\n      }\n    }\n\n    /**\n     * When using the ShadyCSS scoping and custom property shim, causes all\n     * shimmed styles in this element (and its subtree) to be updated\n     * based on current custom property values.\n     *\n     * The optional parameter overrides inline custom property styles with an\n     * object of properties where the keys are CSS properties, and the values\n     * are strings.\n     *\n     * Example: `this.updateStyles({'--color': 'blue'})`\n     *\n     * These properties are retained unless a value of `null` is set.\n     *\n     * Note: This function does not support updating CSS mixins.\n     * You can not dynamically change the value of an `@apply`.\n     *\n     * @override\n     * @param {Object=} properties Bag of custom property key/values to\n     *   apply to this element.\n     * @return {void}\n     * @suppress {invalidCasts}\n     */\n    updateStyles(properties) {\n      if (window.ShadyCSS) {\n        window.ShadyCSS.styleSubtree(/** @type {!HTMLElement} */(this), properties);\n      }\n    }\n\n    /**\n     * Rewrites a given URL relative to a base URL. The base URL defaults to\n     * the original location of the document containing the `dom-module` for\n     * this element. This method will return the same URL before and after\n     * bundling.\n     *\n     * Note that this function performs no resolution for URLs that start\n     * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose\n     * URL resolution, use `window.URL`.\n     *\n     * @override\n     * @param {string} url URL to resolve.\n     * @param {string=} base Optional base URL to resolve against, defaults\n     * to the element's `importPath`\n     * @return {string} Rewritten URL relative to base\n     */\n    resolveUrl(url, base) {\n      if (!base && this.importPath) {\n        base = resolveUrl(this.importPath);\n      }\n      return resolveUrl(url, base);\n    }\n\n    /**\n     * Overrides `PropertyEffects` to add map of dynamic functions on\n     * template info, for consumption by `PropertyEffects` template binding\n     * code. This map determines which method templates should have accessors\n     * created for them.\n     *\n     * @param {!HTMLTemplateElement} template Template\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} .\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     */\n    static _parseTemplateContent(template, templateInfo, nodeInfo) {\n      templateInfo.dynamicFns = templateInfo.dynamicFns || this._properties;\n      return super._parseTemplateContent(template, templateInfo, nodeInfo);\n    }\n\n    /**\n     * Overrides `PropertyEffects` to warn on use of undeclared properties in\n     * template.\n     *\n     * @param {Object} templateInfo Template metadata to add effect to\n     * @param {string} prop Property that should trigger the effect\n     * @param {Object=} effect Effect metadata object\n     * @return {void}\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     */\n    static _addTemplatePropertyEffect(templateInfo, prop, effect) {\n      // Warn if properties are used in template without being declared.\n      // Properties must be listed in `properties` to be included in\n      // `observedAttributes` since CE V1 reads that at registration time, and\n      // since we want to keep template parsing lazy, we can't automatically\n      // add undeclared properties used in templates to `observedAttributes`.\n      // The warning is only enabled in `legacyOptimizations` mode, since\n      // we don't want to spam existing users who might have adopted the\n      // shorthand when attribute deserialization is not important.\n      if (legacyOptimizations && !(prop in this._properties)) {\n        console.warn(`Property '${prop}' used in template but not declared in 'properties'; ` +\n          `attribute will not be observed.`);\n      }\n      return super._addTemplatePropertyEffect(templateInfo, prop, effect);\n    }\n\n  }\n\n  return PolymerElement;\n});\n\n/**\n * When using the ShadyCSS scoping and custom property shim, causes all\n * shimmed `styles` (via `custom-style`) in the document (and its subtree)\n * to be updated based on current custom property values.\n *\n * The optional parameter overrides inline custom property styles with an\n * object of properties where the keys are CSS properties, and the values\n * are strings.\n *\n * Example: `updateStyles({'--color': 'blue'})`\n *\n * These properties are retained unless a value of `null` is set.\n *\n * @param {Object=} props Bag of custom property key/values to\n *   apply to the document.\n * @return {void}\n */\nexport const updateStyles = function(props) {\n  if (window.ShadyCSS) {\n    window.ShadyCSS.styleDocument(props);\n  }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,kBAAkB;AAEzB,SAASA,QAAQ,EAAEC,oBAAoB,EAAEC,0BAA0B,EAAEC,mBAAmB,EAAEC,iBAAiB,QAAQ,sBAAsB;AACzI,SAASC,aAAa,QAAQ,mBAAmB;AACjD,SAASC,kBAAkB,EAAEC,uBAAuB,QAAQ,0BAA0B;AACtF,SAASC,WAAW,EAAEC,UAAU,EAAEC,UAAU,QAAQ,yBAAyB;AAC7E,SAASC,SAAS,QAAQ,2BAA2B;AACrD,SAASC,eAAe,QAAQ,uBAAuB;AACvD,SAASC,eAAe,QAAQ,uBAAuB;AACvD,SAASC,IAAI,QAAQ,kBAAkB;;AAEvC;AACA;AACA;AACA;AACA,OAAO,MAAMC,OAAO,GAAG,OAAO;AAE9B,MAAMC,QAAQ,GAAGC,MAAM,CAACC,QAAQ,IAAID,MAAM,CAACC,QAAQ,CAAC,UAAU,CAAC;;AAE/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,YAAY,GAAGd,aAAa,CAACe,IAAI,IAAI;EAChD;AACF;AACA;AACA;AACA;AACA;AACA;EACE,MAAMC,kBAAkB,GAAGR,eAAe,CAACD,eAAe,CAACQ,IAAI,CAAC,CAAC;;EAEjE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASE,gBAAgBA,CAACC,WAAW,EAAE;IACrC,IAAI,CAACA,WAAW,CAACC,cAAc,CAC7BC,yBAAyB,CAAC,oBAAoB,EAAEF,WAAW,CAAC,CAAC,EAAE;MAC/DA,WAAW,CA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"},"metadata":{},"sourceType":"module","externalDependencies":[]}